<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>FFmpegfs Fuse Multi Media Filesystem: Buffer Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">FFmpegfs Fuse Multi Media Filesystem
   &#160;<span id="projectnumber">2.3</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classBuffer-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Buffer Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The <a class="el" href="classBuffer.html" title="The Buffer class.">Buffer</a> class.  
 <a href="classBuffer.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="buffer_8h_source.html">buffer.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Buffer:</div>
<div class="dyncontent">
<div class="center"><img src="classBuffer__inherit__graph.png" border="0" usemap="#aBuffer_inherit__map" alt="Inheritance graph"/></div>
<map name="aBuffer_inherit__map" id="aBuffer_inherit__map">
<area shape="rect" title="The Buffer class." alt="" coords="5,80,67,107"/>
<area shape="rect" href="classFileIO.html" title="Base class for I/O." alt="" coords="7,5,65,32"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for Buffer:</div>
<div class="dyncontent">
<div class="center"><img src="classBuffer__coll__graph.png" border="0" usemap="#aBuffer_coll__map" alt="Collaboration graph"/></div>
<map name="aBuffer_coll__map" id="aBuffer_coll__map">
<area shape="rect" title="The Buffer class." alt="" coords="871,127,932,153"/>
<area shape="rect" href="classFileIO.html" title="Base class for I/O." alt="" coords="643,93,702,120"/>
<area shape="rect" href="structVIRTUALFILE.html" title="Virtual file definition." alt="" coords="347,93,451,120"/>
<area shape="rect" href="structVIRTUALFILE_1_1VCD__CHAPTER.html" title="Extra value structure for Video CDs." alt="" coords="6,5,214,32"/>
<area shape="rect" href="structVIRTUALFILE_1_1BLURAY__CHAPTER.html" title="Extra value structure for Bluray disks." alt="" coords="29,57,191,98"/>
<area shape="rect" href="structVIRTUALFILE_1_1DVD__CHAPTER.html" title="Extra value structure for DVDs." alt="" coords="5,123,215,149"/>
<area shape="rect" href="structVIRTUALFILE_1_1CUESHEET__TRACK.html" title="Extra value structure for cue sheets." alt="" coords="19,174,201,215"/>
<area shape="rect" href="structBuffer_1_1__tagCACHEINFO.html" title="Structure to hold current cache state." alt="" coords="585,144,760,171"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBuffer_1_1__tagCACHEINFO.html">_tagCACHEINFO</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure to hold current cache state.  <a href="structBuffer_1_1__tagCACHEINFO.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:aadb6390b55aac6776448a8adc81696ed"><td class="memItemLeft" align="right" valign="top"><a id="aadb6390b55aac6776448a8adc81696ed"></a>
typedef struct <a class="el" href="structBuffer_1_1__tagCACHEINFO.html">Buffer::_tagCACHEINFO</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBuffer.html#aadb6390b55aac6776448a8adc81696ed">CACHEINFO</a></td></tr>
<tr class="memdesc:aadb6390b55aac6776448a8adc81696ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure to hold current cache state. <br /></td></tr>
<tr class="separator:aadb6390b55aac6776448a8adc81696ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2b0f8fddd154c040e9b62dae6938bc0"><td class="memItemLeft" align="right" valign="top"><a id="ad2b0f8fddd154c040e9b62dae6938bc0"></a>
typedef struct <a class="el" href="structBuffer_1_1__tagCACHEINFO.html">Buffer::_tagCACHEINFO</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBuffer.html#ad2b0f8fddd154c040e9b62dae6938bc0">LPCACHEINFO</a></td></tr>
<tr class="memdesc:ad2b0f8fddd154c040e9b62dae6938bc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer version of CACHEINFO. <br /></td></tr>
<tr class="separator:ad2b0f8fddd154c040e9b62dae6938bc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a839b6c6f82af952cd68e2e112804dadf"><td class="memItemLeft" align="right" valign="top"><a id="a839b6c6f82af952cd68e2e112804dadf"></a>
typedef <a class="el" href="classBuffer.html#aadb6390b55aac6776448a8adc81696ed">CACHEINFO</a> const  *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBuffer.html#a839b6c6f82af952cd68e2e112804dadf">LPCCACHEINFO</a></td></tr>
<tr class="memdesc:a839b6c6f82af952cd68e2e112804dadf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to const version of CACHEINFO. <br /></td></tr>
<tr class="separator:a839b6c6f82af952cd68e2e112804dadf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ae7ef2cd201190fde551dcb902627112b"><td class="memItemLeft" align="right" valign="top"><a id="ae7ef2cd201190fde551dcb902627112b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBuffer.html#ae7ef2cd201190fde551dcb902627112b">Buffer</a> ()</td></tr>
<tr class="memdesc:ae7ef2cd201190fde551dcb902627112b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create <a class="el" href="classBuffer.html" title="The Buffer class.">Buffer</a> object. <br /></td></tr>
<tr class="separator:ae7ef2cd201190fde551dcb902627112b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59b8743e4a5f731bdd0c4185c9ef263b"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBuffer.html#a59b8743e4a5f731bdd0c4185c9ef263b">~Buffer</a> ()</td></tr>
<tr class="memdesc:a59b8743e4a5f731bdd0c4185c9ef263b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free <a class="el" href="classBuffer.html" title="The Buffer class.">Buffer</a> object.  <a href="classBuffer.html#a59b8743e4a5f731bdd0c4185c9ef263b">More...</a><br /></td></tr>
<tr class="separator:a59b8743e4a5f731bdd0c4185c9ef263b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac118c54b9b67435a466f932e3ebc5a9"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="fileio_8h.html#a1199d38534b11312b0210e527499a805">VIRTUALTYPE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBuffer.html#aac118c54b9b67435a466f932e3ebc5a9">type</a> () const</td></tr>
<tr class="memdesc:aac118c54b9b67435a466f932e3ebc5a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get type of this virtual file.  <a href="classBuffer.html#aac118c54b9b67435a466f932e3ebc5a9">More...</a><br /></td></tr>
<tr class="separator:aac118c54b9b67435a466f932e3ebc5a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e315544b35bbaf0706ef8fbd6bfdbfb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBuffer.html#a6e315544b35bbaf0706ef8fbd6bfdbfb">init</a> (bool erase_cache)</td></tr>
<tr class="memdesc:a6e315544b35bbaf0706ef8fbd6bfdbfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialise cache.  <a href="classBuffer.html#a6e315544b35bbaf0706ef8fbd6bfdbfb">More...</a><br /></td></tr>
<tr class="separator:a6e315544b35bbaf0706ef8fbd6bfdbfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7504c5ecdb98fef9897fd40a7d1fcf4d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBuffer.html#a7504c5ecdb98fef9897fd40a7d1fcf4d">set_segment</a> (uint32_t segment_no)</td></tr>
<tr class="memdesc:a7504c5ecdb98fef9897fd40a7d1fcf4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the current segment.  <a href="classBuffer.html#a7504c5ecdb98fef9897fd40a7d1fcf4d">More...</a><br /></td></tr>
<tr class="separator:a7504c5ecdb98fef9897fd40a7d1fcf4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf8eacdb0ced6906905dbd90d356894d"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBuffer.html#acf8eacdb0ced6906905dbd90d356894d">segment_count</a> ()</td></tr>
<tr class="memdesc:acf8eacdb0ced6906905dbd90d356894d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get segment count.  <a href="classBuffer.html#acf8eacdb0ced6906905dbd90d356894d">More...</a><br /></td></tr>
<tr class="separator:acf8eacdb0ced6906905dbd90d356894d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa356d401405307f29e73586c7cad10c4"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBuffer.html#aa356d401405307f29e73586c7cad10c4">current_segment_no</a> ()</td></tr>
<tr class="memdesc:aa356d401405307f29e73586c7cad10c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get currently selected segment.  <a href="classBuffer.html#aa356d401405307f29e73586c7cad10c4">More...</a><br /></td></tr>
<tr class="separator:aa356d401405307f29e73586c7cad10c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35d04b77b37654d81397bbf6df193bd1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBuffer.html#a35d04b77b37654d81397bbf6df193bd1">segment_exists</a> (uint32_t segment_no)</td></tr>
<tr class="memdesc:a35d04b77b37654d81397bbf6df193bd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if segment exists. Returns true if it exists, or false if it still has to be decoded.  <a href="classBuffer.html#a35d04b77b37654d81397bbf6df193bd1">More...</a><br /></td></tr>
<tr class="separator:a35d04b77b37654d81397bbf6df193bd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31676a28709fcd1cd236e4cbeb2d3bc2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBuffer.html#a31676a28709fcd1cd236e4cbeb2d3bc2">release</a> (int flags=<a class="el" href="buffer_8h.html#ae6bbe3443d78677335623b58e90dfbf0">CACHE_CLOSE_NOOPT</a>)</td></tr>
<tr class="memdesc:a31676a28709fcd1cd236e4cbeb2d3bc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release cache buffer.  <a href="classBuffer.html#a31676a28709fcd1cd236e4cbeb2d3bc2">More...</a><br /></td></tr>
<tr class="separator:a31676a28709fcd1cd236e4cbeb2d3bc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cbffc6461e103922decdded784def8e"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBuffer.html#a4cbffc6461e103922decdded784def8e">bufsize</a> () const</td></tr>
<tr class="memdesc:a4cbffc6461e103922decdded784def8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size of this buffer.  <a href="classBuffer.html#a4cbffc6461e103922decdded784def8e">More...</a><br /></td></tr>
<tr class="separator:a4cbffc6461e103922decdded784def8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44b960357ac39ad7e4047691cbf8fa86"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBuffer.html#a44b960357ac39ad7e4047691cbf8fa86">open</a> (<a class="el" href="fileio_8h.html#ae8356f209b2b74cc385a8d7551f1f27a">LPVIRTUALFILE</a> <a class="el" href="classFileIO.html#a2e330b909423f2118b8482732f50986a">virtualfile</a>)</td></tr>
<tr class="memdesc:a44b960357ac39ad7e4047691cbf8fa86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open a virtual file.  <a href="classBuffer.html#a44b960357ac39ad7e4047691cbf8fa86">More...</a><br /></td></tr>
<tr class="separator:a44b960357ac39ad7e4047691cbf8fa86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac954e92d6f137aa7664fb1415c6af8a9"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBuffer.html#ac954e92d6f137aa7664fb1415c6af8a9">read</a> (void *data, size_t <a class="el" href="classBuffer.html#a18db71f5a21c3c39b6e0a531e9d0f7fa">size</a>)</td></tr>
<tr class="memdesc:ac954e92d6f137aa7664fb1415c6af8a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Not implemented.  <a href="classBuffer.html#ac954e92d6f137aa7664fb1415c6af8a9">More...</a><br /></td></tr>
<tr class="separator:ac954e92d6f137aa7664fb1415c6af8a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afca4140c510e88c2a3c2b505c4e7febe"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBuffer.html#afca4140c510e88c2a3c2b505c4e7febe">read_frame</a> (std::vector&lt; uint8_t &gt; *data, uint32_t frame_no)</td></tr>
<tr class="memdesc:afca4140c510e88c2a3c2b505c4e7febe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write image data for the frame number into the <a class="el" href="classBuffer.html" title="The Buffer class.">Buffer</a>.  <a href="classBuffer.html#afca4140c510e88c2a3c2b505c4e7febe">More...</a><br /></td></tr>
<tr class="separator:afca4140c510e88c2a3c2b505c4e7febe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33be90e718956cdb86d4f7b641b7178b"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBuffer.html#a33be90e718956cdb86d4f7b641b7178b">error</a> () const</td></tr>
<tr class="memdesc:a33be90e718956cdb86d4f7b641b7178b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get last error.  <a href="classBuffer.html#a33be90e718956cdb86d4f7b641b7178b">More...</a><br /></td></tr>
<tr class="separator:a33be90e718956cdb86d4f7b641b7178b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c531f5faca100f397a3d6fc5ca63b6d"><td class="memItemLeft" align="right" valign="top">virtual int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBuffer.html#a5c531f5faca100f397a3d6fc5ca63b6d">duration</a> () const</td></tr>
<tr class="memdesc:a5c531f5faca100f397a3d6fc5ca63b6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the duration of the file, in AV_TIME_BASE fractional seconds.  <a href="classBuffer.html#a5c531f5faca100f397a3d6fc5ca63b6d">More...</a><br /></td></tr>
<tr class="separator:a5c531f5faca100f397a3d6fc5ca63b6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18db71f5a21c3c39b6e0a531e9d0f7fa"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBuffer.html#a18db71f5a21c3c39b6e0a531e9d0f7fa">size</a> () const</td></tr>
<tr class="memdesc:a18db71f5a21c3c39b6e0a531e9d0f7fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the value of the internal buffer size pointer.  <a href="classBuffer.html#a18db71f5a21c3c39b6e0a531e9d0f7fa">More...</a><br /></td></tr>
<tr class="separator:a18db71f5a21c3c39b6e0a531e9d0f7fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab53c4d61870eb1107c750a433af447a1"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBuffer.html#ab53c4d61870eb1107c750a433af447a1">size</a> (uint32_t segment_no) const</td></tr>
<tr class="memdesc:ab53c4d61870eb1107c750a433af447a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the value of the internal buffer size pointer.  <a href="classBuffer.html#ab53c4d61870eb1107c750a433af447a1">More...</a><br /></td></tr>
<tr class="separator:ab53c4d61870eb1107c750a433af447a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c75c4d7bbe1b2cc1e6542be08ebf5ef"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBuffer.html#a0c75c4d7bbe1b2cc1e6542be08ebf5ef">tell</a> () const</td></tr>
<tr class="memdesc:a0c75c4d7bbe1b2cc1e6542be08ebf5ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the value of the internal read position pointer.  <a href="classBuffer.html#a0c75c4d7bbe1b2cc1e6542be08ebf5ef">More...</a><br /></td></tr>
<tr class="separator:a0c75c4d7bbe1b2cc1e6542be08ebf5ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7c0ba630a439abf0b5ba4357b1eeec4"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBuffer.html#ac7c0ba630a439abf0b5ba4357b1eeec4">tell</a> (uint32_t segment_no) const</td></tr>
<tr class="memdesc:ac7c0ba630a439abf0b5ba4357b1eeec4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the value of the internal read position pointer.  <a href="classBuffer.html#ac7c0ba630a439abf0b5ba4357b1eeec4">More...</a><br /></td></tr>
<tr class="separator:ac7c0ba630a439abf0b5ba4357b1eeec4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17c6c9e98cfce397d937259e1e4712e6"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBuffer.html#a17c6c9e98cfce397d937259e1e4712e6">seek</a> (int64_t offset, int whence)</td></tr>
<tr class="memdesc:a17c6c9e98cfce397d937259e1e4712e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Seek to position in file.  <a href="classBuffer.html#a17c6c9e98cfce397d937259e1e4712e6">More...</a><br /></td></tr>
<tr class="separator:a17c6c9e98cfce397d937259e1e4712e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1eafabf58188673da1a3700d72628d7"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBuffer.html#ab1eafabf58188673da1a3700d72628d7">seek</a> (int64_t offset, int whence, uint32_t segment_no)</td></tr>
<tr class="memdesc:ab1eafabf58188673da1a3700d72628d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Seek to position in file.  <a href="classBuffer.html#ab1eafabf58188673da1a3700d72628d7">More...</a><br /></td></tr>
<tr class="separator:ab1eafabf58188673da1a3700d72628d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89274d05a22f724037ee669fffc741cf"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBuffer.html#a89274d05a22f724037ee669fffc741cf">eof</a> () const</td></tr>
<tr class="memdesc:a89274d05a22f724037ee669fffc741cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if at end of file.  <a href="classBuffer.html#a89274d05a22f724037ee669fffc741cf">More...</a><br /></td></tr>
<tr class="separator:a89274d05a22f724037ee669fffc741cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6b9ebe68de81852063d2b4f6f7e6cd4"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBuffer.html#ae6b9ebe68de81852063d2b4f6f7e6cd4">eof</a> (uint32_t segment_no) const</td></tr>
<tr class="memdesc:ae6b9ebe68de81852063d2b4f6f7e6cd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if at end of file.  <a href="classBuffer.html#ae6b9ebe68de81852063d2b4f6f7e6cd4">More...</a><br /></td></tr>
<tr class="separator:ae6b9ebe68de81852063d2b4f6f7e6cd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79ad4f6aee9896a8849dfea5b5e66832"><td class="memItemLeft" align="right" valign="top"><a id="a79ad4f6aee9896a8849dfea5b5e66832"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBuffer.html#a79ad4f6aee9896a8849dfea5b5e66832">close</a> ()</td></tr>
<tr class="memdesc:a79ad4f6aee9896a8849dfea5b5e66832"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close buffer. <br /></td></tr>
<tr class="separator:a79ad4f6aee9896a8849dfea5b5e66832"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12d20083f843dfa5ebd240df3308e9d6"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBuffer.html#a12d20083f843dfa5ebd240df3308e9d6">write</a> (const uint8_t *data, size_t length)</td></tr>
<tr class="memdesc:a12d20083f843dfa5ebd240df3308e9d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write data to the current position into the buffer. The position pointer will be updated.  <a href="classBuffer.html#a12d20083f843dfa5ebd240df3308e9d6">More...</a><br /></td></tr>
<tr class="separator:a12d20083f843dfa5ebd240df3308e9d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a812f0147433355162b1d0bb215aae3bd"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBuffer.html#a812f0147433355162b1d0bb215aae3bd">write_frame</a> (const uint8_t *data, size_t length, uint32_t frame_no)</td></tr>
<tr class="memdesc:a812f0147433355162b1d0bb215aae3bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write image data for the frame number into the buffer.  <a href="classBuffer.html#a812f0147433355162b1d0bb215aae3bd">More...</a><br /></td></tr>
<tr class="separator:a812f0147433355162b1d0bb215aae3bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a959151baf1ef09510d9e535844776690"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBuffer.html#a959151baf1ef09510d9e535844776690">flush</a> ()</td></tr>
<tr class="memdesc:a959151baf1ef09510d9e535844776690"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flush buffer to disk.  <a href="classBuffer.html#a959151baf1ef09510d9e535844776690">More...</a><br /></td></tr>
<tr class="separator:a959151baf1ef09510d9e535844776690"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b3dfc964718593fb99e6296ae90e982"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBuffer.html#a4b3dfc964718593fb99e6296ae90e982">clear</a> ()</td></tr>
<tr class="memdesc:a4b3dfc964718593fb99e6296ae90e982"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear (delete) buffer.  <a href="classBuffer.html#a4b3dfc964718593fb99e6296ae90e982">More...</a><br /></td></tr>
<tr class="separator:a4b3dfc964718593fb99e6296ae90e982"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa08968d973089252fc5e06e7af4c5303"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBuffer.html#aa08968d973089252fc5e06e7af4c5303">reserve</a> (size_t <a class="el" href="classBuffer.html#a18db71f5a21c3c39b6e0a531e9d0f7fa">size</a>)</td></tr>
<tr class="memdesc:aa08968d973089252fc5e06e7af4c5303"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reserve memory without changing size to reduce re-allocations.  <a href="classBuffer.html#aa08968d973089252fc5e06e7af4c5303">More...</a><br /></td></tr>
<tr class="separator:aa08968d973089252fc5e06e7af4c5303"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af40aa3d2d92dbae336dca9de9705c927"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBuffer.html#af40aa3d2d92dbae336dca9de9705c927">buffer_watermark</a> (uint32_t segment_no=0) const</td></tr>
<tr class="memdesc:af40aa3d2d92dbae336dca9de9705c927"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the current watermark of the file while transcoding.  <a href="classBuffer.html#af40aa3d2d92dbae336dca9de9705c927">More...</a><br /></td></tr>
<tr class="separator:af40aa3d2d92dbae336dca9de9705c927"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3641f3ebc9db8c804b8c23c3f0f4754"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBuffer.html#ac3641f3ebc9db8c804b8c23c3f0f4754">copy</a> (std::vector&lt; uint8_t &gt; *out_data, size_t offset, uint32_t segment_no=0)</td></tr>
<tr class="memdesc:ac3641f3ebc9db8c804b8c23c3f0f4754"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy buffered data into output buffer.  <a href="classBuffer.html#ac3641f3ebc9db8c804b8c23c3f0f4754">More...</a><br /></td></tr>
<tr class="separator:ac3641f3ebc9db8c804b8c23c3f0f4754"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3fece94b7da8cac563554333a781f82"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBuffer.html#af3fece94b7da8cac563554333a781f82">copy</a> (uint8_t *out_data, size_t offset, size_t <a class="el" href="classBuffer.html#a4cbffc6461e103922decdded784def8e">bufsize</a>, uint32_t segment_no=0)</td></tr>
<tr class="memdesc:af3fece94b7da8cac563554333a781f82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy buffered data into output buffer.  <a href="classBuffer.html#af3fece94b7da8cac563554333a781f82">More...</a><br /></td></tr>
<tr class="separator:af3fece94b7da8cac563554333a781f82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88d7838706b8e4fa9f9c8f63812b6602"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBuffer.html#a88d7838706b8e4fa9f9c8f63812b6602">cachefile</a> (uint32_t segment_no) const</td></tr>
<tr class="memdesc:a88d7838706b8e4fa9f9c8f63812b6602"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get cache filename.  <a href="classBuffer.html#a88d7838706b8e4fa9f9c8f63812b6602">More...</a><br /></td></tr>
<tr class="separator:a88d7838706b8e4fa9f9c8f63812b6602"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a945f720e4cccfd811467cf0302121377"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBuffer.html#a945f720e4cccfd811467cf0302121377">have_frame</a> (uint32_t frame_no)</td></tr>
<tr class="memdesc:a945f720e4cccfd811467cf0302121377"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if we have the requested frame number. Works only when processing a frame set.  <a href="classBuffer.html#a945f720e4cccfd811467cf0302121377">More...</a><br /></td></tr>
<tr class="separator:a945f720e4cccfd811467cf0302121377"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fab95e5034961d75f12cdc861337972"><td class="memItemLeft" align="right" valign="top"><a id="a3fab95e5034961d75f12cdc861337972"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBuffer.html#a3fab95e5034961d75f12cdc861337972">finished_segment</a> ()</td></tr>
<tr class="memdesc:a3fab95e5034961d75f12cdc861337972"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finish decoded segment. <br /></td></tr>
<tr class="separator:a3fab95e5034961d75f12cdc861337972"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cb529c4a6f6558cd26e450a72e149e9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBuffer.html#a7cb529c4a6f6558cd26e450a72e149e9">is_segment_finished</a> (uint32_t segment_no) const</td></tr>
<tr class="memdesc:a7cb529c4a6f6558cd26e450a72e149e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if transcoding segement finished.  <a href="classBuffer.html#a7cb529c4a6f6558cd26e450a72e149e9">More...</a><br /></td></tr>
<tr class="separator:a7cb529c4a6f6558cd26e450a72e149e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27ae89f93e5d473b8e78fe3f5b91f5fa"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBuffer.html#a27ae89f93e5d473b8e78fe3f5b91f5fa">open_file</a> (uint32_t index, uint32_t flags)</td></tr>
<tr class="memdesc:a27ae89f93e5d473b8e78fe3f5b91f5fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open cache file if not already open.  <a href="classBuffer.html#a27ae89f93e5d473b8e78fe3f5b91f5fa">More...</a><br /></td></tr>
<tr class="separator:a27ae89f93e5d473b8e78fe3f5b91f5fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c43e72349578f36d7c4f4b3dc44aee1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBuffer.html#a3c43e72349578f36d7c4f4b3dc44aee1">close_file</a> (uint32_t index, uint32_t flags)</td></tr>
<tr class="memdesc:a3c43e72349578f36d7c4f4b3dc44aee1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close cache file if not already closed.  <a href="classBuffer.html#a3c43e72349578f36d7c4f4b3dc44aee1">More...</a><br /></td></tr>
<tr class="separator:a3c43e72349578f36d7c4f4b3dc44aee1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classFileIO"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classFileIO')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classFileIO.html">FileIO</a></td></tr>
<tr class="memitem:a8b0d602c3461181e12c05f655dea5018 inherit pub_methods_classFileIO"><td class="memItemLeft" align="right" valign="top"><a id="a8b0d602c3461181e12c05f655dea5018"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFileIO.html#a8b0d602c3461181e12c05f655dea5018">FileIO</a> ()</td></tr>
<tr class="memdesc:a8b0d602c3461181e12c05f655dea5018 inherit pub_methods_classFileIO"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create <a class="el" href="classFileIO.html" title="Base class for I/O.">FileIO</a> object. <br /></td></tr>
<tr class="separator:a8b0d602c3461181e12c05f655dea5018 inherit pub_methods_classFileIO"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc3caa8f1e5d76274d8ffb8b5c17288b inherit pub_methods_classFileIO"><td class="memItemLeft" align="right" valign="top"><a id="adc3caa8f1e5d76274d8ffb8b5c17288b"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFileIO.html#adc3caa8f1e5d76274d8ffb8b5c17288b">~FileIO</a> ()</td></tr>
<tr class="memdesc:adc3caa8f1e5d76274d8ffb8b5c17288b inherit pub_methods_classFileIO"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free <a class="el" href="classFileIO.html" title="Base class for I/O.">FileIO</a> object. <br /></td></tr>
<tr class="separator:adc3caa8f1e5d76274d8ffb8b5c17288b inherit pub_methods_classFileIO"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e330b909423f2118b8482732f50986a inherit pub_methods_classFileIO"><td class="memItemLeft" align="right" valign="top"><a class="el" href="fileio_8h.html#ae8356f209b2b74cc385a8d7551f1f27a">LPVIRTUALFILE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFileIO.html#a2e330b909423f2118b8482732f50986a">virtualfile</a> ()</td></tr>
<tr class="memdesc:a2e330b909423f2118b8482732f50986a inherit pub_methods_classFileIO"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get virtual file object.  <a href="classFileIO.html#a2e330b909423f2118b8482732f50986a">More...</a><br /></td></tr>
<tr class="separator:a2e330b909423f2118b8482732f50986a inherit pub_methods_classFileIO"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcea64fae124756c68302ed355cc457f inherit pub_methods_classFileIO"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFileIO.html#afcea64fae124756c68302ed355cc457f">filename</a> () const</td></tr>
<tr class="memdesc:afcea64fae124756c68302ed355cc457f inherit pub_methods_classFileIO"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get source filename.  <a href="classFileIO.html#afcea64fae124756c68302ed355cc457f">More...</a><br /></td></tr>
<tr class="separator:afcea64fae124756c68302ed355cc457f inherit pub_methods_classFileIO"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a175ab839cce4af8b15749e31fd596e00 inherit pub_methods_classFileIO"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFileIO.html#a175ab839cce4af8b15749e31fd596e00">path</a> () const</td></tr>
<tr class="memdesc:a175ab839cce4af8b15749e31fd596e00 inherit pub_methods_classFileIO"><td class="mdescLeft">&#160;</td><td class="mdescRight">Path to source file (without file name)  <a href="classFileIO.html#a175ab839cce4af8b15749e31fd596e00">More...</a><br /></td></tr>
<tr class="separator:a175ab839cce4af8b15749e31fd596e00 inherit pub_methods_classFileIO"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a53adb0d9d3cd9c426d4384e46c116a08"><td class="memItemLeft" align="right" valign="top">static const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBuffer.html#a53adb0d9d3cd9c426d4384e46c116a08">make_cachefile_name</a> (std::string &amp;<a class="el" href="classBuffer.html#a88d7838706b8e4fa9f9c8f63812b6602">cachefile</a>, const std::string &amp;<a class="el" href="classFileIO.html#afcea64fae124756c68302ed355cc457f">filename</a>, const std::string &amp;fileext, bool is_idx)</td></tr>
<tr class="memdesc:a53adb0d9d3cd9c426d4384e46c116a08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make up a cache file name including full path.  <a href="classBuffer.html#a53adb0d9d3cd9c426d4384e46c116a08">More...</a><br /></td></tr>
<tr class="separator:a53adb0d9d3cd9c426d4384e46c116a08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d5aeca1d1b53238938a1d6d43b4e2dc"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBuffer.html#a7d5aeca1d1b53238938a1d6d43b4e2dc">remove_file</a> (const std::string &amp;<a class="el" href="classFileIO.html#afcea64fae124756c68302ed355cc457f">filename</a>)</td></tr>
<tr class="memdesc:a7d5aeca1d1b53238938a1d6d43b4e2dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove (unlink) file.  <a href="classBuffer.html#a7d5aeca1d1b53238938a1d6d43b4e2dc">More...</a><br /></td></tr>
<tr class="separator:a7d5aeca1d1b53238938a1d6d43b4e2dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_methods_classFileIO"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classFileIO')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classFileIO.html">FileIO</a></td></tr>
<tr class="memitem:ab67ef47f0295909426a82d9fb29afa9e inherit pub_static_methods_classFileIO"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classFileIO.html">FileIO</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFileIO.html#ab67ef47f0295909426a82d9fb29afa9e">alloc</a> (<a class="el" href="fileio_8h.html#a1199d38534b11312b0210e527499a805">VIRTUALTYPE</a> <a class="el" href="classFileIO.html#a6b56f0b1fcf994ff403335463d0eca9b">type</a>)</td></tr>
<tr class="memdesc:ab67ef47f0295909426a82d9fb29afa9e inherit pub_static_methods_classFileIO"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate the correct object for <a class="el" href="classFileIO.html#a6b56f0b1fcf994ff403335463d0eca9b" title="Get type of the virtual file.">type()</a>.  <a href="classFileIO.html#ab67ef47f0295909426a82d9fb29afa9e">More...</a><br /></td></tr>
<tr class="separator:ab67ef47f0295909426a82d9fb29afa9e inherit pub_static_methods_classFileIO"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:ade7078b11e9139252bf3717fa8f1a2e8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBuffer.html#ade7078b11e9139252bf3717fa8f1a2e8">remove_cachefile</a> (uint32_t segment_no=0)</td></tr>
<tr class="memdesc:ade7078b11e9139252bf3717fa8f1a2e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the cachefile.  <a href="classBuffer.html#ade7078b11e9139252bf3717fa8f1a2e8">More...</a><br /></td></tr>
<tr class="separator:ade7078b11e9139252bf3717fa8f1a2e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae98664dd11c6e2051d7de98cb15dee29"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBuffer.html#ae98664dd11c6e2051d7de98cb15dee29">is_open</a> ()</td></tr>
<tr class="memdesc:ae98664dd11c6e2051d7de98cb15dee29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the cache file is open.  <a href="classBuffer.html#ae98664dd11c6e2051d7de98cb15dee29">More...</a><br /></td></tr>
<tr class="separator:ae98664dd11c6e2051d7de98cb15dee29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classFileIO"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classFileIO')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classFileIO.html">FileIO</a></td></tr>
<tr class="memitem:a6596a9c65d31ef13a09d1fa162e76bba inherit pro_methods_classFileIO"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFileIO.html#a6596a9c65d31ef13a09d1fa162e76bba">set_virtualfile</a> (<a class="el" href="fileio_8h.html#ae8356f209b2b74cc385a8d7551f1f27a">LPVIRTUALFILE</a> <a class="el" href="classFileIO.html#a2e330b909423f2118b8482732f50986a">virtualfile</a>)</td></tr>
<tr class="memdesc:a6596a9c65d31ef13a09d1fa162e76bba inherit pro_methods_classFileIO"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the virtual file object.  <a href="classFileIO.html#a6596a9c65d31ef13a09d1fa162e76bba">More...</a><br /></td></tr>
<tr class="separator:a6596a9c65d31ef13a09d1fa162e76bba inherit pro_methods_classFileIO"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a303fc10672c2812a7b34bd203a6882ef"><td class="memItemLeft" align="right" valign="top">uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBuffer.html#a303fc10672c2812a7b34bd203a6882ef">write_prepare</a> (size_t length)</td></tr>
<tr class="memdesc:a303fc10672c2812a7b34bd203a6882ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepare write operation.  <a href="classBuffer.html#a303fc10672c2812a7b34bd203a6882ef">More...</a><br /></td></tr>
<tr class="separator:a303fc10672c2812a7b34bd203a6882ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2408e983616a750858abadf29100c6f4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBuffer.html#a2408e983616a750858abadf29100c6f4">increment_pos</a> (size_t increment)</td></tr>
<tr class="memdesc:a2408e983616a750858abadf29100c6f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increment buffer position.  <a href="classBuffer.html#a2408e983616a750858abadf29100c6f4">More...</a><br /></td></tr>
<tr class="separator:a2408e983616a750858abadf29100c6f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbd9386f99f609c04764db011731f264"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBuffer.html#abbd9386f99f609c04764db011731f264">reallocate</a> (size_t newsize)</td></tr>
<tr class="memdesc:abbd9386f99f609c04764db011731f264"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reallocate buffer to new size.  <a href="classBuffer.html#abbd9386f99f609c04764db011731f264">More...</a><br /></td></tr>
<tr class="separator:abbd9386f99f609c04764db011731f264"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8608a76fc9d6f729bce7df3af7268356"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBuffer.html#a8608a76fc9d6f729bce7df3af7268356">map_file</a> (const std::string &amp;<a class="el" href="classFileIO.html#afcea64fae124756c68302ed355cc457f">filename</a>, int *fd, uint8_t **p, size_t *filesize, bool *isdefaultsize, off_t defaultsize) const</td></tr>
<tr class="memdesc:a8608a76fc9d6f729bce7df3af7268356"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map memory to file.  <a href="classBuffer.html#a8608a76fc9d6f729bce7df3af7268356">More...</a><br /></td></tr>
<tr class="separator:a8608a76fc9d6f729bce7df3af7268356"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af37d881ca60a6f5482428eb5eee591fc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBuffer.html#af37d881ca60a6f5482428eb5eee591fc">unmap_file</a> (const std::string &amp;<a class="el" href="classFileIO.html#afcea64fae124756c68302ed355cc457f">filename</a>, int *fd, uint8_t **p, size_t *filesize) const</td></tr>
<tr class="memdesc:af37d881ca60a6f5482428eb5eee591fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unmap memory from file.  <a href="classBuffer.html#af37d881ca60a6f5482428eb5eee591fc">More...</a><br /></td></tr>
<tr class="separator:af37d881ca60a6f5482428eb5eee591fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2eee1fab320110be86686ff522d2c433"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classBuffer.html#ad2b0f8fddd154c040e9b62dae6938bc0">LPCACHEINFO</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBuffer.html#a2eee1fab320110be86686ff522d2c433">cacheinfo</a> (uint32_t segment_no)</td></tr>
<tr class="memdesc:a2eee1fab320110be86686ff522d2c433"><td class="mdescLeft">&#160;</td><td class="mdescRight">cacheinfo  <a href="classBuffer.html#a2eee1fab320110be86686ff522d2c433">More...</a><br /></td></tr>
<tr class="separator:a2eee1fab320110be86686ff522d2c433"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac73dbc698f23a66b900ccd5923df10a9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classBuffer.html#a839b6c6f82af952cd68e2e112804dadf">LPCCACHEINFO</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBuffer.html#ac73dbc698f23a66b900ccd5923df10a9">const_cacheinfo</a> (uint32_t segment_no) const</td></tr>
<tr class="memdesc:ac73dbc698f23a66b900ccd5923df10a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">cacheinfo  <a href="classBuffer.html#ac73dbc698f23a66b900ccd5923df10a9">More...</a><br /></td></tr>
<tr class="separator:ac73dbc698f23a66b900ccd5923df10a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a7c412682c4217d94c97663d197f235c0"><td class="memItemLeft" align="right" valign="top"><a id="a7c412682c4217d94c97663d197f235c0"></a>
std::recursive_mutex&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBuffer.html#a7c412682c4217d94c97663d197f235c0">m_mutex</a></td></tr>
<tr class="memdesc:a7c412682c4217d94c97663d197f235c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access mutex. <br /></td></tr>
<tr class="separator:a7c412682c4217d94c97663d197f235c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf27b7a77e5d22d16becf8ced3cb75ed"><td class="memItemLeft" align="right" valign="top"><a id="adf27b7a77e5d22d16becf8ced3cb75ed"></a>
<a class="el" href="classBuffer.html#ad2b0f8fddd154c040e9b62dae6938bc0">LPCACHEINFO</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBuffer.html#adf27b7a77e5d22d16becf8ced3cb75ed">m_cur_ci</a></td></tr>
<tr class="memdesc:adf27b7a77e5d22d16becf8ced3cb75ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience pointer to current write segment. <br /></td></tr>
<tr class="separator:adf27b7a77e5d22d16becf8ced3cb75ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3291d599d037e29e1e9957e978258756"><td class="memItemLeft" align="right" valign="top"><a id="a3291d599d037e29e1e9957e978258756"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBuffer.html#a3291d599d037e29e1e9957e978258756">m_cur_open</a></td></tr>
<tr class="memdesc:a3291d599d037e29e1e9957e978258756"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of open files. <br /></td></tr>
<tr class="separator:a3291d599d037e29e1e9957e978258756"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06d70fd4eff6ff0addb7bbd41f4654a1"><td class="memItemLeft" align="right" valign="top"><a id="a06d70fd4eff6ff0addb7bbd41f4654a1"></a>
std::vector&lt; <a class="el" href="classBuffer.html#aadb6390b55aac6776448a8adc81696ed">CACHEINFO</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBuffer.html#a06d70fd4eff6ff0addb7bbd41f4654a1">m_ci</a></td></tr>
<tr class="memdesc:a06d70fd4eff6ff0addb7bbd41f4654a1"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classCache.html" title="The Cache class.">Cache</a> info. <br /></td></tr>
<tr class="separator:a06d70fd4eff6ff0addb7bbd41f4654a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The <a class="el" href="classBuffer.html" title="The Buffer class.">Buffer</a> class. </p>

<p class="definition">Definition at line <a class="el" href="buffer_8h_source.html#l00055">55</a> of file <a class="el" href="buffer_8h_source.html">buffer.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a59b8743e4a5f731bdd0c4185c9ef263b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59b8743e4a5f731bdd0c4185c9ef263b">&#9670;&nbsp;</a></span>~Buffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Buffer::~Buffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Free <a class="el" href="classBuffer.html" title="The Buffer class.">Buffer</a> object. </p>
<p>Release memory and close files </p>

<p class="definition">Definition at line <a class="el" href="buffer_8cc_source.html#l00050">50</a> of file <a class="el" href="buffer_8cc_source.html">buffer.cc</a>.</p>

<p class="reference">References <a class="el" href="buffer_8cc_source.html#l00465">release()</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="af40aa3d2d92dbae336dca9de9705c927"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af40aa3d2d92dbae336dca9de9705c927">&#9670;&nbsp;</a></span>buffer_watermark()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t Buffer::buffer_watermark </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>segment_no</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the current watermark of the file while transcoding. </p>
<p>While transcoding, this value reflects the current size of the transcoded file. This is the maximum byte offset until the file can be read so far.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">segment_no</td><td>- If &gt; 0 returns watermark for specific segment. If 0, returns watermark for current write segment. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the current watermark. </dd></dl>

<p class="definition">Definition at line <a class="el" href="buffer_8cc_source.html#l00826">826</a> of file <a class="el" href="buffer_8cc_source.html">buffer.cc</a>.</p>

<p class="reference">References <a class="el" href="buffer_8cc_source.html#l01077">const_cacheinfo()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ffmpeg__transcoder_8cc_source.html#l04607">FFmpeg_Transcoder::encode_finish()</a>, <a class="el" href="cache__entry_8cc_source.html#l00262">Cache_Entry::size()</a>, <a class="el" href="transcode_8cc_source.html#l00139">transcode_finish()</a>, <a class="el" href="transcode_8cc_source.html#l00713">transcoder_buffer_watermark()</a>, <a class="el" href="transcode_8cc_source.html#l00756">transcoder_thread()</a>, and <a class="el" href="buffer_8cc_source.html#l00651">write_frame()</a>.</p>

</div>
</div>
<a id="a4cbffc6461e103922decdded784def8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cbffc6461e103922decdded784def8e">&#9670;&nbsp;</a></span>bufsize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t Buffer::bufsize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Size of this buffer. </p>
<dl class="section return"><dt>Returns</dt><dd>Not applicable, returns 0. </dd></dl>

<p>Implements <a class="el" href="classFileIO.html#a9ef072d7a6f475c0b185c3912d828342">FileIO</a>.</p>

<p class="definition">Definition at line <a class="el" href="buffer_8cc_source.html#l00060">60</a> of file <a class="el" href="buffer_8cc_source.html">buffer.cc</a>.</p>

<p class="reference">Referenced by <a class="el" href="buffer_8cc_source.html#l00844">copy()</a>.</p>

</div>
</div>
<a id="a88d7838706b8e4fa9f9c8f63812b6602"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88d7838706b8e4fa9f9c8f63812b6602">&#9670;&nbsp;</a></span>cachefile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string &amp; Buffer::cachefile </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>segment_no</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get cache filename. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">segment_no</td><td>- HLS segment file number [1..n] or 0 for current segment. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns cache filename. </dd></dl>

<p class="definition">Definition at line <a class="el" href="buffer_8cc_source.html#l00899">899</a> of file <a class="el" href="buffer_8cc_source.html">buffer.cc</a>.</p>

<p class="reference">References <a class="el" href="buffer_8cc_source.html#l01077">const_cacheinfo()</a>.</p>

<p class="reference">Referenced by <a class="el" href="buffer_8cc_source.html#l00164">init()</a>, and <a class="el" href="buffer_8cc_source.html#l00913">make_cachefile_name()</a>.</p>

</div>
</div>
<a id="a2eee1fab320110be86686ff522d2c433"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2eee1fab320110be86686ff522d2c433">&#9670;&nbsp;</a></span>cacheinfo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBuffer.html#ad2b0f8fddd154c040e9b62dae6938bc0">Buffer::LPCACHEINFO</a> Buffer::cacheinfo </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>segment_no</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>cacheinfo </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">segment_no</td><td>- HLS segment file number [1..n] or 0 for current segment or 0 for current segment. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

<p class="definition">Definition at line <a class="el" href="buffer_8cc_source.html#l01060">1060</a> of file <a class="el" href="buffer_8cc_source.html">buffer.cc</a>.</p>

<p class="reference">References <a class="el" href="buffer_8h_source.html#l00447">m_ci</a>, <a class="el" href="buffer_8h_source.html#l00444">m_cur_ci</a>, and <a class="el" href="buffer_8cc_source.html#l00311">segment_count()</a>.</p>

<p class="reference">Referenced by <a class="el" href="buffer_8cc_source.html#l00732">seek()</a>.</p>

</div>
</div>
<a id="a4b3dfc964718593fb99e6296ae90e982"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b3dfc964718593fb99e6296ae90e982">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Buffer::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear (delete) buffer. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns true on success; false on error. Check errno for details. </dd></dl>

<p class="definition">Definition at line <a class="el" href="buffer_8cc_source.html#l00558">558</a> of file <a class="el" href="buffer_8cc_source.html">buffer.cc</a>.</p>

<p class="reference">References <a class="el" href="logging_8h_source.html#l00254">Logging::error()</a>, <a class="el" href="buffer_8h_source.html#l00081">Buffer::_tagCACHEINFO::m_buffer</a>, <a class="el" href="buffer_8h_source.html#l00089">Buffer::_tagCACHEINFO::m_buffer_idx</a>, <a class="el" href="buffer_8h_source.html#l00082">Buffer::_tagCACHEINFO::m_buffer_pos</a>, <a class="el" href="buffer_8h_source.html#l00084">Buffer::_tagCACHEINFO::m_buffer_size</a>, <a class="el" href="buffer_8h_source.html#l00090">Buffer::_tagCACHEINFO::m_buffer_size_idx</a>, <a class="el" href="buffer_8h_source.html#l00083">Buffer::_tagCACHEINFO::m_buffer_watermark</a>, <a class="el" href="buffer_8h_source.html#l00079">Buffer::_tagCACHEINFO::m_cachefile</a>, <a class="el" href="buffer_8h_source.html#l00444">m_cur_ci</a>, <a class="el" href="buffer_8h_source.html#l00080">Buffer::_tagCACHEINFO::m_fd</a>, <a class="el" href="buffer_8h_source.html#l00088">Buffer::_tagCACHEINFO::m_fd_idx</a>, <a class="el" href="buffer_8h_source.html#l00443">m_mutex</a>, <a class="el" href="buffer_8h_source.html#l00085">Buffer::_tagCACHEINFO::m_seg_finished</a>, and <a class="el" href="buffer_8cc_source.html#l00311">segment_count()</a>.</p>

<p class="reference">Referenced by <a class="el" href="cache__entry_8cc_source.html#l00088">Cache_Entry::clear()</a>.</p>

</div>
</div>
<a id="a3c43e72349578f36d7c4f4b3dc44aee1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c43e72349578f36d7c4f4b3dc44aee1">&#9670;&nbsp;</a></span>close_file()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Buffer::close_file </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Close cache file if not already closed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>- Index of segment file number [0..n-1]. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>- CACHE_FLAG_* options </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true on success or file already closed; false on error. </dd></dl>

<p class="definition">Definition at line <a class="el" href="buffer_8cc_source.html#l00126">126</a> of file <a class="el" href="buffer_8cc_source.html">buffer.cc</a>.</p>

<p class="reference">References <a class="el" href="buffer_8h_source.html#l00447">m_ci</a>, <a class="el" href="buffer_8h_source.html#l00445">m_cur_open</a>, <a class="el" href="logging_8h_source.html#l00162">Logging::trace()</a>, and <a class="el" href="buffer_8cc_source.html#l00415">unmap_file()</a>.</p>

<p class="reference">Referenced by <a class="el" href="fuseops_8cc_source.html#l01869">ffmpegfs_release()</a>, <a class="el" href="buffer_8cc_source.html#l00465">release()</a>, and <a class="el" href="buffer_8cc_source.html#l00286">set_segment()</a>.</p>

</div>
</div>
<a id="ac73dbc698f23a66b900ccd5923df10a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac73dbc698f23a66b900ccd5923df10a9">&#9670;&nbsp;</a></span>const_cacheinfo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBuffer.html#a839b6c6f82af952cd68e2e112804dadf">Buffer::LPCCACHEINFO</a> Buffer::const_cacheinfo </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>segment_no</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>cacheinfo </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">segment_no</td><td>- HLS segment file number [1..n] or 0 for current segment. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

<p class="definition">Definition at line <a class="el" href="buffer_8cc_source.html#l01077">1077</a> of file <a class="el" href="buffer_8cc_source.html">buffer.cc</a>.</p>

<p class="reference">References <a class="el" href="buffer_8h_source.html#l00447">m_ci</a>, and <a class="el" href="buffer_8h_source.html#l00444">m_cur_ci</a>.</p>

<p class="reference">Referenced by <a class="el" href="buffer_8cc_source.html#l00826">buffer_watermark()</a>, <a class="el" href="buffer_8cc_source.html#l00899">cachefile()</a>, <a class="el" href="buffer_8cc_source.html#l00844">copy()</a>, <a class="el" href="buffer_8cc_source.html#l01047">is_segment_finished()</a>, <a class="el" href="buffer_8cc_source.html#l00813">size()</a>, and <a class="el" href="buffer_8cc_source.html#l00789">tell()</a>.</p>

</div>
</div>
<a id="ac3641f3ebc9db8c804b8c23c3f0f4754"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3641f3ebc9db8c804b8c23c3f0f4754">&#9670;&nbsp;</a></span>copy() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Buffer::copy </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; uint8_t &gt; *&#160;</td>
          <td class="paramname"><em>out_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>segment_no</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy buffered data into output buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">out_data</td><td>- <a class="el" href="classBuffer.html" title="The Buffer class.">Buffer</a> to copy data to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>- Offset in buffer to copy data from. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">segment_no</td><td>- HLS segment file number [1..n] or 0 for current segment. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true on success; false on error. </dd></dl>

<p class="definition">Definition at line <a class="el" href="buffer_8cc_source.html#l00839">839</a> of file <a class="el" href="buffer_8cc_source.html">buffer.cc</a>.</p>

<p class="reference">Referenced by <a class="el" href="buffer_8cc_source.html#l00954">read_frame()</a>.</p>

</div>
</div>
<a id="af3fece94b7da8cac563554333a781f82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3fece94b7da8cac563554333a781f82">&#9670;&nbsp;</a></span>copy() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Buffer::copy </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>out_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bufsize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>segment_no</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy buffered data into output buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">out_data</td><td>- <a class="el" href="classBuffer.html" title="The Buffer class.">Buffer</a> to copy data to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>- Offset in buffer to copy data from. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bufsize</td><td>- Size of out_data buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">segment_no</td><td>- HLS segment file number [1..n] or 0 for current segment. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true on success; false on error. </dd></dl>

<p class="definition">Definition at line <a class="el" href="buffer_8cc_source.html#l00844">844</a> of file <a class="el" href="buffer_8cc_source.html">buffer.cc</a>.</p>

<p class="reference">References <a class="el" href="buffer_8cc_source.html#l00060">bufsize()</a>, <a class="el" href="buffer_8cc_source.html#l01077">const_cacheinfo()</a>, <a class="el" href="buffer_8h_source.html#l00443">m_mutex</a>, and <a class="el" href="buffer_8cc_source.html#l00808">size()</a>.</p>

</div>
</div>
<a id="aa356d401405307f29e73586c7cad10c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa356d401405307f29e73586c7cad10c4">&#9670;&nbsp;</a></span>current_segment_no()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t Buffer::current_segment_no </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get currently selected segment. </p>
<dl class="section return"><dt>Returns</dt><dd>Current segment number [1..n] or 0 if none selected. </dd></dl>

<p class="definition">Definition at line <a class="el" href="buffer_8cc_source.html#l00318">318</a> of file <a class="el" href="buffer_8cc_source.html">buffer.cc</a>.</p>

<p class="reference">References <a class="el" href="buffer_8h_source.html#l00447">m_ci</a>, <a class="el" href="buffer_8h_source.html#l00444">m_cur_ci</a>, <a class="el" href="buffer_8h_source.html#l00443">m_mutex</a>, and <a class="el" href="buffer_8cc_source.html#l00311">segment_count()</a>.</p>

<p class="reference">Referenced by <a class="el" href="buffer_8cc_source.html#l00286">set_segment()</a>.</p>

</div>
</div>
<a id="a5c531f5faca100f397a3d6fc5ca63b6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c531f5faca100f397a3d6fc5ca63b6d">&#9670;&nbsp;</a></span>duration()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int64_t Buffer::duration </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the duration of the file, in AV_TIME_BASE fractional seconds. </p>
<dl class="section return"><dt>Returns</dt><dd>Not applicable to buffer, always returns AV_NOPTS_VALUE. </dd></dl>

<p>Implements <a class="el" href="classFileIO.html#aaffdefd15fa7c5e54a9733b1770c8bcd">FileIO</a>.</p>

<p class="definition">Definition at line <a class="el" href="buffer_8cc_source.html#l00803">803</a> of file <a class="el" href="buffer_8cc_source.html">buffer.cc</a>.</p>

</div>
</div>
<a id="a89274d05a22f724037ee669fffc741cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89274d05a22f724037ee669fffc741cf">&#9670;&nbsp;</a></span>eof() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Buffer::eof </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if at end of file. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns true if at end of buffer. </dd></dl>

<p>Implements <a class="el" href="classFileIO.html#ad7bf956d13e66a11644c30c4b2b7d0ee">FileIO</a>.</p>

<p class="definition">Definition at line <a class="el" href="buffer_8cc_source.html#l00986">986</a> of file <a class="el" href="buffer_8cc_source.html">buffer.cc</a>.</p>

</div>
</div>
<a id="ae6b9ebe68de81852063d2b4f6f7e6cd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6b9ebe68de81852063d2b4f6f7e6cd4">&#9670;&nbsp;</a></span>eof() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Buffer::eof </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>segment_no</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if at end of file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">segment_no</td><td>- HLS segment file number [1..n] or 0 for current segment. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true if at end of buffer. </dd></dl>

<p class="definition">Definition at line <a class="el" href="buffer_8cc_source.html#l00991">991</a> of file <a class="el" href="buffer_8cc_source.html">buffer.cc</a>.</p>

<p class="reference">References <a class="el" href="buffer_8cc_source.html#l00808">size()</a>, and <a class="el" href="buffer_8cc_source.html#l00784">tell()</a>.</p>

</div>
</div>
<a id="a33be90e718956cdb86d4f7b641b7178b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33be90e718956cdb86d4f7b641b7178b">&#9670;&nbsp;</a></span>error()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Buffer::error </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get last error. </p>
<dl class="section return"><dt>Returns</dt><dd>errno value of last error. </dd></dl>

<p>Implements <a class="el" href="classFileIO.html#a705727f41def56f0d14c631514d3b115">FileIO</a>.</p>

<p class="definition">Definition at line <a class="el" href="buffer_8cc_source.html#l00981">981</a> of file <a class="el" href="buffer_8cc_source.html">buffer.cc</a>.</p>

</div>
</div>
<a id="a959151baf1ef09510d9e535844776690"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a959151baf1ef09510d9e535844776690">&#9670;&nbsp;</a></span>flush()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Buffer::flush </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flush buffer to disk. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns true on success; false on error. Check errno for details. </dd></dl>

<p class="definition">Definition at line <a class="el" href="buffer_8cc_source.html#l00530">530</a> of file <a class="el" href="buffer_8cc_source.html">buffer.cc</a>.</p>

<p class="reference">References <a class="el" href="logging_8h_source.html#l00254">Logging::error()</a>, <a class="el" href="buffer_8h_source.html#l00081">Buffer::_tagCACHEINFO::m_buffer</a>, <a class="el" href="buffer_8h_source.html#l00089">Buffer::_tagCACHEINFO::m_buffer_idx</a>, <a class="el" href="buffer_8h_source.html#l00084">Buffer::_tagCACHEINFO::m_buffer_size</a>, <a class="el" href="buffer_8h_source.html#l00090">Buffer::_tagCACHEINFO::m_buffer_size_idx</a>, <a class="el" href="buffer_8h_source.html#l00079">Buffer::_tagCACHEINFO::m_cachefile</a>, <a class="el" href="buffer_8h_source.html#l00087">Buffer::_tagCACHEINFO::m_cachefile_idx</a>, <a class="el" href="buffer_8h_source.html#l00444">m_cur_ci</a>, <a class="el" href="buffer_8h_source.html#l00443">m_mutex</a>, and <a class="el" href="buffer_8cc_source.html#l00311">segment_count()</a>.</p>

<p class="reference">Referenced by <a class="el" href="buffer_8cc_source.html#l01035">finished_segment()</a>, <a class="el" href="cache__entry_8cc_source.html#l00248">Cache_Entry::flush()</a>, and <a class="el" href="buffer_8cc_source.html#l00465">release()</a>.</p>

</div>
</div>
<a id="a945f720e4cccfd811467cf0302121377"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a945f720e4cccfd811467cf0302121377">&#9670;&nbsp;</a></span>have_frame()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Buffer::have_frame </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>frame_no</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if we have the requested frame number. Works only when processing a frame set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">frame_no</td><td>- 1...frames </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true of frame is already in cache, false if not. </dd></dl>

<p class="definition">Definition at line <a class="el" href="buffer_8cc_source.html#l01001">1001</a> of file <a class="el" href="buffer_8cc_source.html">buffer.cc</a>.</p>

<p class="reference">References <a class="el" href="buffer_8h_source.html#l00089">Buffer::_tagCACHEINFO::m_buffer_idx</a>, <a class="el" href="buffer_8h_source.html#l00444">m_cur_ci</a>, <a class="el" href="buffer_8h_source.html#l00443">m_mutex</a>, and <a class="el" href="fileio_8cc_source.html#l00123">FileIO::virtualfile()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ffmpeg__transcoder_8cc_source.html#l03845">FFmpeg_Transcoder::process_single_fr()</a>, and <a class="el" href="ffmpeg__transcoder_8cc_source.html#l03799">FFmpeg_Transcoder::skip_decoded_frames()</a>.</p>

</div>
</div>
<a id="a2408e983616a750858abadf29100c6f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2408e983616a750858abadf29100c6f4">&#9670;&nbsp;</a></span>increment_pos()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Buffer::increment_pos </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>increment</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Increment buffer position. </p>
<p>Increment the location of the internal pointer. This cannot fail and so returns void. It does not ensure the position is valid memory because that is done by the write_prepare methods via reallocate. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">increment</td><td>- Increment size. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="buffer_8cc_source.html#l00722">722</a> of file <a class="el" href="buffer_8cc_source.html">buffer.cc</a>.</p>

<p class="reference">References <a class="el" href="buffer_8h_source.html#l00082">Buffer::_tagCACHEINFO::m_buffer_pos</a>, and <a class="el" href="buffer_8h_source.html#l00444">m_cur_ci</a>.</p>

<p class="reference">Referenced by <a class="el" href="buffer_8cc_source.html#l00627">write()</a>.</p>

</div>
</div>
<a id="a6e315544b35bbaf0706ef8fbd6bfdbfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e315544b35bbaf0706ef8fbd6bfdbfb">&#9670;&nbsp;</a></span>init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Buffer::init </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>erase_cache</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialise cache. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">erase_cache</td><td>- if true delete old file before opening. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true on success; false on error. </dd></dl>

<p class="definition">Definition at line <a class="el" href="buffer_8cc_source.html#l00164">164</a> of file <a class="el" href="buffer_8cc_source.html">buffer.cc</a>.</p>

<p class="reference">References <a class="el" href="buffer_8cc_source.html#l00899">cachefile()</a>, <a class="el" href="ffmpegfs_8cc_source.html#l00154">FFMPEGFS_PARAMS::current_format()</a>, <a class="el" href="logging_8h_source.html#l00254">Logging::error()</a>, <a class="el" href="fileio_8cc_source.html#l00133">FileIO::filename()</a>, <a class="el" href="fileio_8cc_source.html#l00048">VIRTUALFILE::get_segment_count()</a>, <a class="el" href="buffer_8cc_source.html#l01020">is_open()</a>, <a class="el" href="buffer_8h_source.html#l00447">m_ci</a>, <a class="el" href="buffer_8h_source.html#l00444">m_cur_ci</a>, <a class="el" href="buffer_8h_source.html#l00443">m_mutex</a>, <a class="el" href="buffer_8cc_source.html#l00913">make_cachefile_name()</a>, <a class="el" href="ffmpeg__utils_8cc_source.html#l01335">make_filename()</a>, <a class="el" href="buffer_8cc_source.html#l00340">map_file()</a>, <a class="el" href="ffmpeg__utils_8cc_source.html#l00669">mktree()</a>, <a class="el" href="ffmpeg__utils_8cc_source.html#l00419">new_strdup()</a>, <a class="el" href="ffmpegfs_8cc_source.html#l00066">params</a>, <a class="el" href="buffer_8cc_source.html#l00515">remove_cachefile()</a>, <a class="el" href="buffer_8cc_source.html#l00311">segment_count()</a>, <a class="el" href="fileio_8cc_source.html#l00123">FileIO::virtualfile()</a>, <a class="el" href="fileio_8h_source.html#l00110">VIRTUALFLAG_FRAME</a>, and <a class="el" href="fileio_8h_source.html#l00111">VIRTUALFLAG_HLS</a>.</p>

<p class="reference">Referenced by <a class="el" href="cache__entry_8cc_source.html#l00163">Cache_Entry::open()</a>.</p>

</div>
</div>
<a id="ae98664dd11c6e2051d7de98cb15dee29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae98664dd11c6e2051d7de98cb15dee29">&#9670;&nbsp;</a></span>is_open()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Buffer::is_open </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the cache file is open. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns true if the cache file is open; false if not. </dd></dl>

<p class="definition">Definition at line <a class="el" href="buffer_8cc_source.html#l01020">1020</a> of file <a class="el" href="buffer_8cc_source.html">buffer.cc</a>.</p>

<p class="reference">References <a class="el" href="buffer_8h_source.html#l00447">m_ci</a>, <a class="el" href="buffer_8h_source.html#l00443">m_mutex</a>, and <a class="el" href="buffer_8cc_source.html#l00311">segment_count()</a>.</p>

<p class="reference">Referenced by <a class="el" href="buffer_8cc_source.html#l00164">init()</a>, and <a class="el" href="buffer_8cc_source.html#l00465">release()</a>.</p>

</div>
</div>
<a id="a7cb529c4a6f6558cd26e450a72e149e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cb529c4a6f6558cd26e450a72e149e9">&#9670;&nbsp;</a></span>is_segment_finished()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Buffer::is_segment_finished </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>segment_no</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if transcoding segement finished. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">segment_no</td><td>- HLS segment file number [1..n] or 0 for current segment. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true if finished, false if not. </dd></dl>

<p class="definition">Definition at line <a class="el" href="buffer_8cc_source.html#l01047">1047</a> of file <a class="el" href="buffer_8cc_source.html">buffer.cc</a>.</p>

<p class="reference">References <a class="el" href="buffer_8cc_source.html#l01077">const_cacheinfo()</a>.</p>

<p class="reference">Referenced by <a class="el" href="transcode_8cc_source.html#l00080">transcode_until()</a>.</p>

</div>
</div>
<a id="a53adb0d9d3cd9c426d4384e46c116a08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53adb0d9d3cd9c426d4384e46c116a08">&#9670;&nbsp;</a></span>make_cachefile_name()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string &amp; Buffer::make_cachefile_name </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>cachefile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fileext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make up a cache file name including full path. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">cachefile</td><td>- Name of cache file. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filename</td><td>- Source file name. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fileext</td><td>- File extension (MP4, WEBM etc.). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">is_idx</td><td>- If true, create index file; otherwise create a cache. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the name of the cache file. </dd></dl>

<p class="definition">Definition at line <a class="el" href="buffer_8cc_source.html#l00913">913</a> of file <a class="el" href="buffer_8cc_source.html">buffer.cc</a>.</p>

<p class="reference">References <a class="el" href="buffer_8cc_source.html#l00899">cachefile()</a>, <a class="el" href="fileio_8cc_source.html#l00133">FileIO::filename()</a>, <a class="el" href="ffmpegfs_8h_source.html#l00129">FFMPEGFS_PARAMS::m_mountpath</a>, <a class="el" href="ffmpegfs_8cc_source.html#l00066">params</a>, and <a class="el" href="transcode_8cc_source.html#l00178">transcoder_cache_path()</a>.</p>

<p class="reference">Referenced by <a class="el" href="buffer_8cc_source.html#l00164">init()</a>, and <a class="el" href="fuseops_8cc_source.html#l00782">make_hls_fileset()</a>.</p>

</div>
</div>
<a id="a8608a76fc9d6f729bce7df3af7268356"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8608a76fc9d6f729bce7df3af7268356">&#9670;&nbsp;</a></span>map_file()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Buffer::map_file </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t **&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>filesize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>isdefaultsize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">off_t&#160;</td>
          <td class="paramname"><em>defaultsize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Map memory to file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">filename</td><td>- Name of cache file to open. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">fd</td><td>- The file descriptor of the open cache file. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">p</td><td>- Memory pointer to cache file. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">filesize</td><td>- Actual size of the cache file after this call. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">isdefaultsize</td><td>-<br  />
In: If false, the file size will be the size of the existing file, returning the size in filesize. If the file does not exist, it will be sized to defaultsize. If true, the defaultsize will be used in any case, resizing an existing file if necessary.<br  />
Out: true if the file size was set to default. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">defaultsize</td><td>- Default size of the file if it does not exist. This parameter can be zero in which case the size will be set to the system's page size. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true if successful and fd, p, filesize, isdefaultsize filled in or false on error. </dd></dl>

<p class="definition">Definition at line <a class="el" href="buffer_8cc_source.html#l00340">340</a> of file <a class="el" href="buffer_8cc_source.html">buffer.cc</a>.</p>

<p class="reference">References <a class="el" href="buffer_8cc_source.html#l00996">close()</a>, <a class="el" href="logging_8h_source.html#l00254">Logging::error()</a>, <a class="el" href="fileio_8cc_source.html#l00133">FileIO::filename()</a>, <a class="el" href="buffer_8cc_source.html#l00065">open()</a>, and <a class="el" href="logging_8h_source.html#l00162">Logging::trace()</a>.</p>

<p class="reference">Referenced by <a class="el" href="buffer_8cc_source.html#l00164">init()</a>, and <a class="el" href="buffer_8cc_source.html#l00078">open_file()</a>.</p>

</div>
</div>
<a id="a44b960357ac39ad7e4047691cbf8fa86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44b960357ac39ad7e4047691cbf8fa86">&#9670;&nbsp;</a></span>open()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Buffer::open </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="fileio_8h.html#ae8356f209b2b74cc385a8d7551f1f27a">LPVIRTUALFILE</a>&#160;</td>
          <td class="paramname"><em>virtualfile</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Open a virtual file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">virtualfile</td><td>- LPCVIRTUALFILE of file to open </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Upon successful completion, <a class="el" href="classBuffer.html#a44b960357ac39ad7e4047691cbf8fa86" title="Open a virtual file.">open()</a> returns 0. On error, an nonzero value is returned and errno is set to indicate the error. </dd></dl>

<p>Implements <a class="el" href="classFileIO.html#ac6f8d683c47d7b37a8d20351f084af10">FileIO</a>.</p>

<p class="definition">Definition at line <a class="el" href="buffer_8cc_source.html#l00065">65</a> of file <a class="el" href="buffer_8cc_source.html">buffer.cc</a>.</p>

<p class="reference">References <a class="el" href="fileio_8cc_source.html#l00106">FileIO::set_virtualfile()</a>, and <a class="el" href="fileio_8cc_source.html#l00123">FileIO::virtualfile()</a>.</p>

<p class="reference">Referenced by <a class="el" href="cache__entry_8cc_source.html#l00039">Cache_Entry::Cache_Entry()</a>, and <a class="el" href="buffer_8cc_source.html#l00340">map_file()</a>.</p>

</div>
</div>
<a id="a27ae89f93e5d473b8e78fe3f5b91f5fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27ae89f93e5d473b8e78fe3f5b91f5fa">&#9670;&nbsp;</a></span>open_file()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Buffer::open_file </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Open cache file if not already open. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>- Index of segment file number [0..n-1]. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>- CACHE_FLAG_* options </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true on success or file already open; false on error. </dd></dl>

<p class="definition">Definition at line <a class="el" href="buffer_8cc_source.html#l00078">78</a> of file <a class="el" href="buffer_8cc_source.html">buffer.cc</a>.</p>

<p class="reference">References <a class="el" href="buffer_8h_source.html#l00050">CACHE_FLAG_RW</a>, <a class="el" href="logging_8h_source.html#l00185">Logging::debug()</a>, <a class="el" href="buffer_8h_source.html#l00447">m_ci</a>, <a class="el" href="buffer_8h_source.html#l00445">m_cur_open</a>, <a class="el" href="buffer_8cc_source.html#l00340">map_file()</a>, and <a class="el" href="logging_8h_source.html#l00162">Logging::trace()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ffmpeg__transcoder_8cc_source.html#l00858">FFmpeg_Transcoder::open_output()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l00730">FFmpeg_Transcoder::open_output_frame_set()</a>, <a class="el" href="buffer_8cc_source.html#l00286">set_segment()</a>, <a class="el" href="transcode_8cc_source.html#l00451">transcoder_read()</a>, and <a class="el" href="transcode_8cc_source.html#l00585">transcoder_read_frame()</a>.</p>

</div>
</div>
<a id="ac954e92d6f137aa7664fb1415c6af8a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac954e92d6f137aa7664fb1415c6af8a9">&#9670;&nbsp;</a></span>read()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t Buffer::read </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Not implemented. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">data</td><td>- unused </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>- unused </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Always returns 0 and errno is EPERM. </dd></dl>

<p>Implements <a class="el" href="classFileIO.html#afe9ad83e019855f655e4c69c3a282f26">FileIO</a>.</p>

<p class="definition">Definition at line <a class="el" href="buffer_8cc_source.html#l00947">947</a> of file <a class="el" href="buffer_8cc_source.html">buffer.cc</a>.</p>

</div>
</div>
<a id="afca4140c510e88c2a3c2b505c4e7febe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afca4140c510e88c2a3c2b505c4e7febe">&#9670;&nbsp;</a></span>read_frame()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t Buffer::read_frame </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; uint8_t &gt; *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>frame_no</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write image data for the frame number into the <a class="el" href="classBuffer.html" title="The Buffer class.">Buffer</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">data</td><td>- <a class="el" href="classBuffer.html" title="The Buffer class.">Buffer</a> to read data in. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">frame_no</td><td>- Number of the frame to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Upon successful completion, <a class="el" href="classBuffer.html#ac954e92d6f137aa7664fb1415c6af8a9" title="Not implemented.">read()</a> returns the number of bytes read. <br  />
 This may be less than size. <br  />
 On error, the value 0 is returned and errno is set to indicate the error. <br  />
 If at end of file, 0 may be returned by errno not set. <a class="el" href="classBuffer.html#a33be90e718956cdb86d4f7b641b7178b" title="Get last error.">error()</a> will return 0 if at EOF. If the image frame is not yet read, the function also returns 0 and errno is EAGAIN. </dd></dl>

<p class="definition">Definition at line <a class="el" href="buffer_8cc_source.html#l00954">954</a> of file <a class="el" href="buffer_8cc_source.html">buffer.cc</a>.</p>

<p class="reference">References <a class="el" href="buffer_8cc_source.html#l00839">copy()</a>, <a class="el" href="buffer_8h_source.html#l00089">Buffer::_tagCACHEINFO::m_buffer_idx</a>, <a class="el" href="buffer_8h_source.html#l00444">m_cur_ci</a>, <a class="el" href="buffer_8h_source.html#l00443">m_mutex</a>, and <a class="el" href="fileio_8cc_source.html#l00123">FileIO::virtualfile()</a>.</p>

<p class="reference">Referenced by <a class="el" href="transcode_8cc_source.html#l00585">transcoder_read_frame()</a>.</p>

</div>
</div>
<a id="abbd9386f99f609c04764db011731f264"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbd9386f99f609c04764db011731f264">&#9670;&nbsp;</a></span>reallocate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Buffer::reallocate </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>newsize</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reallocate buffer to new size. </p>
<p>Ensure the allocation has at least size bytes available. If not, reallocate memory to make more available. Fill the newly allocated memory with zeroes. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">newsize</td><td>- New buffer size </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true on success; false on error. </dd></dl>

<p class="definition">Definition at line <a class="el" href="buffer_8cc_source.html#l00883">883</a> of file <a class="el" href="buffer_8cc_source.html">buffer.cc</a>.</p>

<p class="reference">References <a class="el" href="fileio_8cc_source.html#l00133">FileIO::filename()</a>, <a class="el" href="buffer_8cc_source.html#l00595">reserve()</a>, <a class="el" href="buffer_8cc_source.html#l00808">size()</a>, and <a class="el" href="logging_8h_source.html#l00162">Logging::trace()</a>.</p>

<p class="reference">Referenced by <a class="el" href="buffer_8cc_source.html#l00705">write_prepare()</a>.</p>

</div>
</div>
<a id="a31676a28709fcd1cd236e4cbeb2d3bc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31676a28709fcd1cd236e4cbeb2d3bc2">&#9670;&nbsp;</a></span>release()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Buffer::release </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="buffer_8h.html#ae6bbe3443d78677335623b58e90dfbf0">CACHE_CLOSE_NOOPT</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Release cache buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>- One of the CACHE_CLOSE_* flags. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true on success; false on error. </dd></dl>

<p class="definition">Definition at line <a class="el" href="buffer_8cc_source.html#l00465">465</a> of file <a class="el" href="buffer_8cc_source.html">buffer.cc</a>.</p>

<p class="reference">References <a class="el" href="buffer_8h_source.html#l00043">CACHE_CHECK_BIT</a>, <a class="el" href="buffer_8h_source.html#l00047">CACHE_CLOSE_DELETE</a>, <a class="el" href="buffer_8h_source.html#l00049">CACHE_FLAG_RO</a>, <a class="el" href="buffer_8h_source.html#l00050">CACHE_FLAG_RW</a>, <a class="el" href="buffer_8cc_source.html#l00126">close_file()</a>, <a class="el" href="buffer_8cc_source.html#l00530">flush()</a>, <a class="el" href="buffer_8cc_source.html#l01020">is_open()</a>, <a class="el" href="buffer_8h_source.html#l00447">m_ci</a>, <a class="el" href="buffer_8h_source.html#l00443">m_mutex</a>, <a class="el" href="buffer_8cc_source.html#l00515">remove_cachefile()</a>, <a class="el" href="buffer_8cc_source.html#l00311">segment_count()</a>, and <a class="el" href="buffer_8cc_source.html#l00415">unmap_file()</a>.</p>

<p class="reference">Referenced by <a class="el" href="buffer_8cc_source.html#l00996">close()</a>, <a class="el" href="cache__entry_8cc_source.html#l00208">Cache_Entry::close_buffer()</a>, and <a class="el" href="buffer_8cc_source.html#l00050">~Buffer()</a>.</p>

</div>
</div>
<a id="ade7078b11e9139252bf3717fa8f1a2e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade7078b11e9139252bf3717fa8f1a2e8">&#9670;&nbsp;</a></span>remove_cachefile()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Buffer::remove_cachefile </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>segment_no</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove the cachefile. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">segment_no</td><td>- HLS segment file number [1..n] or 0 for current segment. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true on success; false on error. </dd></dl>

<p class="definition">Definition at line <a class="el" href="buffer_8cc_source.html#l00515">515</a> of file <a class="el" href="buffer_8cc_source.html">buffer.cc</a>.</p>

<p class="reference">References <a class="el" href="buffer_8h_source.html#l00079">Buffer::_tagCACHEINFO::m_cachefile</a>, <a class="el" href="buffer_8h_source.html#l00087">Buffer::_tagCACHEINFO::m_cachefile_idx</a>, <a class="el" href="buffer_8h_source.html#l00447">m_ci</a>, <a class="el" href="buffer_8h_source.html#l00444">m_cur_ci</a>, and <a class="el" href="buffer_8cc_source.html#l00933">remove_file()</a>.</p>

<p class="reference">Referenced by <a class="el" href="buffer_8cc_source.html#l00164">init()</a>, and <a class="el" href="buffer_8cc_source.html#l00465">release()</a>.</p>

</div>
</div>
<a id="a7d5aeca1d1b53238938a1d6d43b4e2dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d5aeca1d1b53238938a1d6d43b4e2dc">&#9670;&nbsp;</a></span>remove_file()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Buffer::remove_file </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove (unlink) file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">filename</td><td>- Name of file to remove. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true on success; false on error. </dd></dl>

<p class="definition">Definition at line <a class="el" href="buffer_8cc_source.html#l00933">933</a> of file <a class="el" href="buffer_8cc_source.html">buffer.cc</a>.</p>

<p class="reference">References <a class="el" href="fileio_8cc_source.html#l00133">FileIO::filename()</a>, and <a class="el" href="logging_8h_source.html#l00231">Logging::warning()</a>.</p>

<p class="reference">Referenced by <a class="el" href="buffer_8cc_source.html#l00515">remove_cachefile()</a>.</p>

</div>
</div>
<a id="aa08968d973089252fc5e06e7af4c5303"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa08968d973089252fc5e06e7af4c5303">&#9670;&nbsp;</a></span>reserve()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Buffer::reserve </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reserve memory without changing size to reduce re-allocations. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>- Size of buffer to reserve. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true on success; false on error. </dd></dl>

<p class="definition">Definition at line <a class="el" href="buffer_8cc_source.html#l00595">595</a> of file <a class="el" href="buffer_8cc_source.html">buffer.cc</a>.</p>

<p class="reference">References <a class="el" href="logging_8h_source.html#l00254">Logging::error()</a>, <a class="el" href="buffer_8h_source.html#l00081">Buffer::_tagCACHEINFO::m_buffer</a>, <a class="el" href="buffer_8h_source.html#l00084">Buffer::_tagCACHEINFO::m_buffer_size</a>, <a class="el" href="buffer_8h_source.html#l00079">Buffer::_tagCACHEINFO::m_cachefile</a>, <a class="el" href="buffer_8h_source.html#l00444">m_cur_ci</a>, <a class="el" href="buffer_8h_source.html#l00080">Buffer::_tagCACHEINFO::m_fd</a>, <a class="el" href="buffer_8h_source.html#l00443">m_mutex</a>, and <a class="el" href="buffer_8cc_source.html#l00808">size()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ffmpeg__transcoder_8cc_source.html#l00858">FFmpeg_Transcoder::open_output()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l00730">FFmpeg_Transcoder::open_output_frame_set()</a>, <a class="el" href="buffer_8cc_source.html#l00883">reallocate()</a>, and <a class="el" href="transcode_8cc_source.html#l00139">transcode_finish()</a>.</p>

</div>
</div>
<a id="a17c6c9e98cfce397d937259e1e4712e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17c6c9e98cfce397d937259e1e4712e6">&#9670;&nbsp;</a></span>seek() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Buffer::seek </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>whence</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Seek to position in file. </p>
<p>Repositions the offset of the open file to the argument offset according to the directive whence. May block for a long time if buffer has not been filled to the requested offset.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>- offset in bytes </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">whence</td><td>- how to seek: <br  />
SEEK_SET: The offset is set to offset bytes. <br  />
SEEK_CUR: The offset is set to its current location plus offset bytes. <br  />
SEEK_END: The offset is set to the size of the file plus offset bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Upon successful completion, <a class="el" href="classBuffer.html#a17c6c9e98cfce397d937259e1e4712e6" title="Seek to position in file.">seek()</a> returns the resulting offset location as measured in bytes from the beginning of the file. </dd></dl>

<p>Implements <a class="el" href="classFileIO.html#a0171ca18c497a09971e22cc5c381304b">FileIO</a>.</p>

<p class="definition">Definition at line <a class="el" href="buffer_8cc_source.html#l00727">727</a> of file <a class="el" href="buffer_8cc_source.html">buffer.cc</a>.</p>

<p class="reference">Referenced by <a class="el" href="buffer_8cc_source.html#l00651">write_frame()</a>.</p>

</div>
</div>
<a id="ab1eafabf58188673da1a3700d72628d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1eafabf58188673da1a3700d72628d7">&#9670;&nbsp;</a></span>seek() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Buffer::seek </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>whence</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>segment_no</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Seek to position in file. </p>
<p>Repositions the offset of the open file to the argument offset according to the directive whence. May block for a long time if buffer has not been filled to the requested offset.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>- offset in bytes </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">whence</td><td>- how to seek: <br  />
SEEK_SET: The offset is set to offset bytes. <br  />
SEEK_CUR: The offset is set to its current location plus offset bytes. <br  />
SEEK_END: The offset is set to the size of the file plus offset bytes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">segment_no</td><td>- HLS segment file number [1..n] or 0 for current segment. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Upon successful completion, <a class="el" href="classBuffer.html#a17c6c9e98cfce397d937259e1e4712e6" title="Seek to position in file.">seek()</a> returns the resulting offset location as measured in bytes from the beginning of the file. </dd></dl>

<p class="definition">Definition at line <a class="el" href="buffer_8cc_source.html#l00732">732</a> of file <a class="el" href="buffer_8cc_source.html">buffer.cc</a>.</p>

<p class="reference">References <a class="el" href="buffer_8cc_source.html#l01060">cacheinfo()</a>, <a class="el" href="buffer_8h_source.html#l00081">Buffer::_tagCACHEINFO::m_buffer</a>, <a class="el" href="buffer_8h_source.html#l00082">Buffer::_tagCACHEINFO::m_buffer_pos</a>, <a class="el" href="buffer_8cc_source.html#l00808">size()</a>, and <a class="el" href="buffer_8cc_source.html#l00784">tell()</a>.</p>

</div>
</div>
<a id="acf8eacdb0ced6906905dbd90d356894d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf8eacdb0ced6906905dbd90d356894d">&#9670;&nbsp;</a></span>segment_count()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t Buffer::segment_count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get segment count. </p>
<dl class="section return"><dt>Returns</dt><dd>Number of segments. </dd></dl>

<p class="definition">Definition at line <a class="el" href="buffer_8cc_source.html#l00311">311</a> of file <a class="el" href="buffer_8cc_source.html">buffer.cc</a>.</p>

<p class="reference">References <a class="el" href="buffer_8h_source.html#l00447">m_ci</a>, and <a class="el" href="buffer_8h_source.html#l00443">m_mutex</a>.</p>

<p class="reference">Referenced by <a class="el" href="buffer_8cc_source.html#l01060">cacheinfo()</a>, <a class="el" href="buffer_8cc_source.html#l00558">clear()</a>, <a class="el" href="buffer_8cc_source.html#l00318">current_segment_no()</a>, <a class="el" href="buffer_8cc_source.html#l00530">flush()</a>, <a class="el" href="buffer_8cc_source.html#l00164">init()</a>, <a class="el" href="buffer_8cc_source.html#l01020">is_open()</a>, <a class="el" href="buffer_8cc_source.html#l00465">release()</a>, <a class="el" href="buffer_8cc_source.html#l00329">segment_exists()</a>, and <a class="el" href="buffer_8cc_source.html#l00286">set_segment()</a>.</p>

</div>
</div>
<a id="a35d04b77b37654d81397bbf6df193bd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35d04b77b37654d81397bbf6df193bd1">&#9670;&nbsp;</a></span>segment_exists()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Buffer::segment_exists </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>segment_no</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if segment exists. Returns true if it exists, or false if it still has to be decoded. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">segment_no</td><td>- HLS segment file number [1..n]. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true if it exists, or false if not. </dd></dl>

<p class="definition">Definition at line <a class="el" href="buffer_8cc_source.html#l00329">329</a> of file <a class="el" href="buffer_8cc_source.html">buffer.cc</a>.</p>

<p class="reference">References <a class="el" href="ffmpeg__utils_8cc_source.html#l01340">file_exists()</a>, <a class="el" href="buffer_8h_source.html#l00447">m_ci</a>, <a class="el" href="buffer_8h_source.html#l00444">m_cur_ci</a>, <a class="el" href="buffer_8h_source.html#l00443">m_mutex</a>, and <a class="el" href="buffer_8cc_source.html#l00311">segment_count()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ffmpeg__transcoder_8cc_source.html#l03845">FFmpeg_Transcoder::process_single_fr()</a>, and <a class="el" href="transcode_8cc_source.html#l00451">transcoder_read()</a>.</p>

</div>
</div>
<a id="a7504c5ecdb98fef9897fd40a7d1fcf4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7504c5ecdb98fef9897fd40a7d1fcf4d">&#9670;&nbsp;</a></span>set_segment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Buffer::set_segment </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>segment_no</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the current segment. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">segment_no</td><td>- HLS segment file number [1..n]. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true on success; if segment_no is 0 or greated then <a class="el" href="classBuffer.html#acf8eacdb0ced6906905dbd90d356894d" title="Get segment count.">segment_count()</a> returns false and sets errno to EINVALID. </dd></dl>

<p class="definition">Definition at line <a class="el" href="buffer_8cc_source.html#l00286">286</a> of file <a class="el" href="buffer_8cc_source.html">buffer.cc</a>.</p>

<p class="reference">References <a class="el" href="buffer_8h_source.html#l00050">CACHE_FLAG_RW</a>, <a class="el" href="buffer_8cc_source.html#l00126">close_file()</a>, <a class="el" href="buffer_8cc_source.html#l00318">current_segment_no()</a>, <a class="el" href="buffer_8h_source.html#l00447">m_ci</a>, <a class="el" href="buffer_8h_source.html#l00444">m_cur_ci</a>, <a class="el" href="buffer_8h_source.html#l00443">m_mutex</a>, <a class="el" href="buffer_8cc_source.html#l00078">open_file()</a>, and <a class="el" href="buffer_8cc_source.html#l00311">segment_count()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ffmpeg__transcoder_8cc_source.html#l03845">FFmpeg_Transcoder::process_single_fr()</a>.</p>

</div>
</div>
<a id="a18db71f5a21c3c39b6e0a531e9d0f7fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18db71f5a21c3c39b6e0a531e9d0f7fa">&#9670;&nbsp;</a></span>size() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t Buffer::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the value of the internal buffer size pointer. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the value of the internal buffer size pointer. </dd></dl>

<p>Implements <a class="el" href="classFileIO.html#a28df61747de114001d67ef6abad2ca7d">FileIO</a>.</p>

<p class="definition">Definition at line <a class="el" href="buffer_8cc_source.html#l00808">808</a> of file <a class="el" href="buffer_8cc_source.html">buffer.cc</a>.</p>

<p class="reference">Referenced by <a class="el" href="buffer_8cc_source.html#l00844">copy()</a>, <a class="el" href="buffer_8cc_source.html#l00991">eof()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l00858">FFmpeg_Transcoder::open_output()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l00730">FFmpeg_Transcoder::open_output_frame_set()</a>, <a class="el" href="buffer_8cc_source.html#l00883">reallocate()</a>, <a class="el" href="buffer_8cc_source.html#l00595">reserve()</a>, <a class="el" href="buffer_8cc_source.html#l00732">seek()</a>, and <a class="el" href="transcode_8cc_source.html#l00080">transcode_until()</a>.</p>

</div>
</div>
<a id="ab53c4d61870eb1107c750a433af447a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab53c4d61870eb1107c750a433af447a1">&#9670;&nbsp;</a></span>size() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t Buffer::size </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>segment_no</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the value of the internal buffer size pointer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">segment_no</td><td>- HLS segment file number [1..n] or 0 for current segment. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the value of the internal buffer size pointer. </dd></dl>

<p class="definition">Definition at line <a class="el" href="buffer_8cc_source.html#l00813">813</a> of file <a class="el" href="buffer_8cc_source.html">buffer.cc</a>.</p>

<p class="reference">References <a class="el" href="buffer_8cc_source.html#l01077">const_cacheinfo()</a>.</p>

</div>
</div>
<a id="a0c75c4d7bbe1b2cc1e6542be08ebf5ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c75c4d7bbe1b2cc1e6542be08ebf5ef">&#9670;&nbsp;</a></span>tell() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t Buffer::tell </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the value of the internal read position pointer. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the value of the internal read position pointer. </dd></dl>

<p>Implements <a class="el" href="classFileIO.html#a3a40140f766ff539cde0da854a1a9526">FileIO</a>.</p>

<p class="definition">Definition at line <a class="el" href="buffer_8cc_source.html#l00784">784</a> of file <a class="el" href="buffer_8cc_source.html">buffer.cc</a>.</p>

<p class="reference">Referenced by <a class="el" href="buffer_8cc_source.html#l00991">eof()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l03845">FFmpeg_Transcoder::process_single_fr()</a>, <a class="el" href="buffer_8cc_source.html#l00732">seek()</a>, <a class="el" href="transcode_8cc_source.html#l00080">transcode_until()</a>, and <a class="el" href="transcode_8cc_source.html#l00718">transcoder_buffer_tell()</a>.</p>

</div>
</div>
<a id="ac7c0ba630a439abf0b5ba4357b1eeec4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7c0ba630a439abf0b5ba4357b1eeec4">&#9670;&nbsp;</a></span>tell() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t Buffer::tell </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>segment_no</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the value of the internal read position pointer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">segment_no</td><td>- HLS segment file number [1..n] or 0 for current segment. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the value of the internal read position pointer. </dd></dl>

<p class="definition">Definition at line <a class="el" href="buffer_8cc_source.html#l00789">789</a> of file <a class="el" href="buffer_8cc_source.html">buffer.cc</a>.</p>

<p class="reference">References <a class="el" href="buffer_8cc_source.html#l01077">const_cacheinfo()</a>.</p>

</div>
</div>
<a id="aac118c54b9b67435a466f932e3ebc5a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac118c54b9b67435a466f932e3ebc5a9">&#9670;&nbsp;</a></span>type()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="fileio_8h.html#a1199d38534b11312b0210e527499a805">VIRTUALTYPE</a> Buffer::type </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get type of this virtual file. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns VIRTUALTYPE_BUFFER. </dd></dl>

<p>Implements <a class="el" href="classFileIO.html#a6b56f0b1fcf994ff403335463d0eca9b">FileIO</a>.</p>

<p class="definition">Definition at line <a class="el" href="buffer_8cc_source.html#l00055">55</a> of file <a class="el" href="buffer_8cc_source.html">buffer.cc</a>.</p>

<p class="reference">References <a class="el" href="fileio_8h_source.html#l00101">VIRTUALTYPE_BUFFER</a>.</p>

</div>
</div>
<a id="af37d881ca60a6f5482428eb5eee591fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af37d881ca60a6f5482428eb5eee591fc">&#9670;&nbsp;</a></span>unmap_file()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Buffer::unmap_file </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t **&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>filesize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unmap memory from file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">filename</td><td>- Name of cache file to unmap. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fd</td><td>- The file descriptor of the open cache file. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>- Memory pointer to cache file. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filesize</td><td>- Actual size of the cache file. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true on success; false on error. </dd></dl>

<p class="definition">Definition at line <a class="el" href="buffer_8cc_source.html#l00415">415</a> of file <a class="el" href="buffer_8cc_source.html">buffer.cc</a>.</p>

<p class="reference">References <a class="el" href="buffer_8cc_source.html#l00996">close()</a>, <a class="el" href="logging_8h_source.html#l00254">Logging::error()</a>, <a class="el" href="fileio_8cc_source.html#l00133">FileIO::filename()</a>, and <a class="el" href="logging_8h_source.html#l00162">Logging::trace()</a>.</p>

<p class="reference">Referenced by <a class="el" href="buffer_8cc_source.html#l00126">close_file()</a>, and <a class="el" href="buffer_8cc_source.html#l00465">release()</a>.</p>

</div>
</div>
<a id="a12d20083f843dfa5ebd240df3308e9d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12d20083f843dfa5ebd240df3308e9d6">&#9670;&nbsp;</a></span>write()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t Buffer::write </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write data to the current position into the buffer. The position pointer will be updated. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>- <a class="el" href="classBuffer.html" title="The Buffer class.">Buffer</a> with data to write. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>- Length of buffer to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the bytes written to the buffer. If less than length this indicates an error, consult errno for details. </dd></dl>

<p class="definition">Definition at line <a class="el" href="buffer_8cc_source.html#l00627">627</a> of file <a class="el" href="buffer_8cc_source.html">buffer.cc</a>.</p>

<p class="reference">References <a class="el" href="buffer_8cc_source.html#l00722">increment_pos()</a>, <a class="el" href="buffer_8h_source.html#l00081">Buffer::_tagCACHEINFO::m_buffer</a>, <a class="el" href="buffer_8h_source.html#l00444">m_cur_ci</a>, <a class="el" href="buffer_8h_source.html#l00443">m_mutex</a>, and <a class="el" href="buffer_8cc_source.html#l00705">write_prepare()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ffmpeg__transcoder_8cc_source.html#l04674">FFmpeg_Transcoder::output_write()</a>, and <a class="el" href="buffer_8cc_source.html#l00651">write_frame()</a>.</p>

</div>
</div>
<a id="a812f0147433355162b1d0bb215aae3bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a812f0147433355162b1d0bb215aae3bd">&#9670;&nbsp;</a></span>write_frame()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t Buffer::write_frame </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>frame_no</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write image data for the frame number into the buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>- <a class="el" href="classBuffer.html" title="The Buffer class.">Buffer</a> with data to write. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>- Length of buffer to write. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">frame_no</td><td>- Number of the frame to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the bytes written to the buffer. If less than length this indicates an error, consult errno for details. </dd></dl>

<p class="definition">Definition at line <a class="el" href="buffer_8cc_source.html#l00651">651</a> of file <a class="el" href="buffer_8cc_source.html">buffer.cc</a>.</p>

<p class="reference">References <a class="el" href="buffer_8cc_source.html#l00826">buffer_watermark()</a>, <a class="el" href="fileio_8h_source.html#l00064">IMAGE_FRAME_TAG</a>, <a class="el" href="buffer_8h_source.html#l00089">Buffer::_tagCACHEINFO::m_buffer_idx</a>, <a class="el" href="buffer_8h_source.html#l00444">m_cur_ci</a>, <a class="el" href="fileio_8h_source.html#l00074">IMAGE_FRAME::m_frame_no</a>, <a class="el" href="buffer_8h_source.html#l00443">m_mutex</a>, <a class="el" href="fileio_8h_source.html#l00075">IMAGE_FRAME::m_offset</a>, <a class="el" href="fileio_8h_source.html#l00076">IMAGE_FRAME::m_size</a>, <a class="el" href="fileio_8h_source.html#l00073">IMAGE_FRAME::m_tag</a>, <a class="el" href="buffer_8cc_source.html#l00727">seek()</a>, <a class="el" href="fileio_8cc_source.html#l00123">FileIO::virtualfile()</a>, and <a class="el" href="buffer_8cc_source.html#l00627">write()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ffmpeg__transcoder_8cc_source.html#l03288">FFmpeg_Transcoder::encode_image_frame()</a>.</p>

</div>
</div>
<a id="a303fc10672c2812a7b34bd203a6882ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a303fc10672c2812a7b34bd203a6882ef">&#9670;&nbsp;</a></span>write_prepare()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t * Buffer::write_prepare </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prepare write operation. </p>
<p>Ensure the <a class="el" href="classBuffer.html" title="The Buffer class.">Buffer</a> has sufficient space for a quantity of data and return a pointer where the data may be written. The position pointer should be updated afterward with <a class="el" href="classBuffer.html#a2408e983616a750858abadf29100c6f4" title="Increment buffer position.">increment_pos()</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>- Length of buffer to prepare. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a pointer to the memory to write. </dd></dl>

<p class="definition">Definition at line <a class="el" href="buffer_8cc_source.html#l00705">705</a> of file <a class="el" href="buffer_8cc_source.html">buffer.cc</a>.</p>

<p class="reference">References <a class="el" href="buffer_8h_source.html#l00081">Buffer::_tagCACHEINFO::m_buffer</a>, <a class="el" href="buffer_8h_source.html#l00082">Buffer::_tagCACHEINFO::m_buffer_pos</a>, <a class="el" href="buffer_8h_source.html#l00083">Buffer::_tagCACHEINFO::m_buffer_watermark</a>, <a class="el" href="buffer_8h_source.html#l00444">m_cur_ci</a>, and <a class="el" href="buffer_8cc_source.html#l00883">reallocate()</a>.</p>

<p class="reference">Referenced by <a class="el" href="buffer_8cc_source.html#l00627">write()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/<a class="el" href="buffer_8h_source.html">buffer.h</a></li>
<li>src/<a class="el" href="buffer_8cc_source.html">buffer.cc</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
