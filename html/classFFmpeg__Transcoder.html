<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>FFmpegfs Fuse Multi Media Filesystem: FFmpeg_Transcoder Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">FFmpegfs Fuse Multi Media Filesystem
   &#160;<span id="projectnumber">2.12</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-types">Protected Types</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-static-methods">Static Protected Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="#pri-static-attribs">Static Private Attributes</a> &#124;
<a href="classFFmpeg__Transcoder-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">FFmpeg_Transcoder Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The <a class="el" href="classFFmpeg__Transcoder.html" title="The FFmpeg_Transcoder class.">FFmpeg_Transcoder</a> class.  
 <a href="classFFmpeg__Transcoder.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="ffmpeg__transcoder_8h_source.html">ffmpeg_transcoder.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for FFmpeg_Transcoder:</div>
<div class="dyncontent">
<div class="center"><img src="classFFmpeg__Transcoder__inherit__graph.png" border="0" usemap="#aFFmpeg__Transcoder_inherit__map" alt="Inheritance graph"/></div>
<map name="aFFmpeg__Transcoder_inherit__map" id="aFFmpeg__Transcoder_inherit__map">
<area shape="rect" title="The FFmpeg_Transcoder class." alt="" coords="59,80,213,107"/>
<area shape="rect" href="classFFmpeg__Base.html" title="The FFmpeg_Base class." alt="" coords="5,5,120,32"/>
<area shape="rect" href="classFFmpeg__Profiles.html" title="The FFmpeg_Profiles class." alt="" coords="144,5,275,32"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for FFmpeg_Transcoder:</div>
<div class="dyncontent">
<div class="center"><img src="classFFmpeg__Transcoder__coll__graph.png" border="0" usemap="#aFFmpeg__Transcoder_coll__map" alt="Collaboration graph"/></div>
<map name="aFFmpeg__Transcoder_coll__map" id="aFFmpeg__Transcoder_coll__map">
<area shape="rect" title="The FFmpeg_Transcoder class." alt="" coords="1341,195,1495,221"/>
<area shape="rect" href="classFFmpeg__Base.html" title="The FFmpeg_Base class." alt="" coords="871,136,985,163"/>
<area shape="rect" href="structVIRTUALFILE.html" title="Virtual file definition." alt="" coords="357,151,463,177"/>
<area shape="rect" href="structVIRTUALFILE_1_1CUESHEET__TRACK.html" title="Extra value structure for cue sheets." alt="" coords="663,179,845,221"/>
<area shape="rect" href="classFileIO.html" title="Base class for I/O." alt="" coords="725,77,783,104"/>
<area shape="rect" href="structVIRTUALFILE_1_1VCD__CHAPTER.html" title="Extra value structure for Video CDs." alt="" coords="6,92,215,119"/>
<area shape="rect" href="structVIRTUALFILE_1_1BLURAY__CHAPTER.html" title="Extra value structure for Blu&#45;ray disks." alt="" coords="29,143,192,185"/>
<area shape="rect" href="structVIRTUALFILE_1_1DVD__CHAPTER.html" title="Extra value structure for DVDs." alt="" coords="5,209,216,236"/>
<area shape="rect" href="classFFmpeg__Profiles.html" title="The FFmpeg_Profiles class." alt="" coords="1026,195,1157,221"/>
<area shape="rect" href="classBuffer.html" title="The Buffer class." alt="" coords="1060,31,1123,57"/>
<area shape="rect" href="classFFmpegfs__Format.html" title="The FFmpegfs_Format class." alt="" coords="1021,245,1161,272"/>
<area shape="rect" href="structFormat__Options.html" title=" " alt="" coords="691,245,817,272"/>
<area shape="rect" href="structFFmpeg__Transcoder_1_1INPUTFILE.html" title="Input file definition." alt="" coords="673,357,835,398"/>
<area shape="rect" href="structFFmpeg__Transcoder_1_1OUTPUTFILE.html" title="Output file definition." alt="" coords="1011,297,1172,338"/>
<area shape="rect" href="classFFmpeg__Transcoder_1_1StreamRef.html" title="In/output stream reference data." alt="" coords="329,357,491,398"/>
<area shape="rect" href="structID3v1.html" title="ID3 version 1 tag" alt="" coords="724,296,784,323"/>
<area shape="rect" href="structBuffer_1_1__tagCACHEINFO.html" title="Structure to hold current cache state." alt="" coords="667,5,841,32"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structFFmpeg__Transcoder_1_1BUFFER__DATA.html">BUFFER_DATA</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classBuffer.html" title="The Buffer class.">Buffer</a> structure, used in <a class="el" href="classFFmpeg__Transcoder.html#aa4515e5c135b1ca3fd7fab1d8bc0d943" title="FFmpeg_Transcoder::read_packet.">FFmpeg_Transcoder::read_packet</a>.  <a href="structFFmpeg__Transcoder_1_1BUFFER__DATA.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structFFmpeg__Transcoder_1_1INPUTFILE.html">INPUTFILE</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Input file definition.  <a href="structFFmpeg__Transcoder_1_1INPUTFILE.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structFFmpeg__Transcoder_1_1OUTPUTFILE.html">OUTPUTFILE</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output file definition.  <a href="structFFmpeg__Transcoder_1_1OUTPUTFILE.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structFFmpeg__Transcoder_1_1PRORES__BITRATE.html">PRORES_BITRATE</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Predicted bitrates for Apple Prores, see <a href="https://www.apple.com/final-cut-pro/docs/Apple_ProRes_White_Paper.pdf">https://www.apple.com/final-cut-pro/docs/Apple_ProRes_White_Paper.pdf</a>.  <a href="structFFmpeg__Transcoder_1_1PRORES__BITRATE.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Transcoder_1_1StreamRef.html">StreamRef</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">In/output stream reference data.  <a href="classFFmpeg__Transcoder_1_1StreamRef.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a65d1570366ac1d759e197a754840ae27"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Transcoder.html#a65d1570366ac1d759e197a754840ae27">FFmpeg_Transcoder</a> ()</td></tr>
<tr class="separator:a65d1570366ac1d759e197a754840ae27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af20ff945bd865539207ea927cb5f7ec8"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Transcoder.html#af20ff945bd865539207ea927cb5f7ec8">~FFmpeg_Transcoder</a> ()</td></tr>
<tr class="separator:af20ff945bd865539207ea927cb5f7ec8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abae5d70063ce52f3b9ccf5157265d97b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Transcoder.html#abae5d70063ce52f3b9ccf5157265d97b">is_open</a> () const</td></tr>
<tr class="separator:abae5d70063ce52f3b9ccf5157265d97b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a556a0c7071ee2e8e249ef35eb7c64ec7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Transcoder.html#a556a0c7071ee2e8e249ef35eb7c64ec7">open_input_file</a> (<a class="el" href="fileio_8h.html#ae8356f209b2b74cc385a8d7551f1f27a">LPVIRTUALFILE</a> virtualfile, <a class="el" href="classFileIO.html">FileIO</a> *fio=nullptr)</td></tr>
<tr class="separator:a556a0c7071ee2e8e249ef35eb7c64ec7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac17eddfaa818018ceabb87165d44b968"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Transcoder.html#ac17eddfaa818018ceabb87165d44b968">open_output_file</a> (<a class="el" href="classBuffer.html">Buffer</a> *buffer)</td></tr>
<tr class="memdesc:ac17eddfaa818018ceabb87165d44b968"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open output file. Data will actually be written to buffer and copied by FUSE when accessed.  <a href="classFFmpeg__Transcoder.html#ac17eddfaa818018ceabb87165d44b968">More...</a><br /></td></tr>
<tr class="separator:ac17eddfaa818018ceabb87165d44b968"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33fe2abcc0767204dcd6dab22980d54e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Transcoder.html#a33fe2abcc0767204dcd6dab22980d54e">process_single_fr</a> (int &amp;status)</td></tr>
<tr class="separator:a33fe2abcc0767204dcd6dab22980d54e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a521bb83e1e6862028fc272e1667355f7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Transcoder.html#a521bb83e1e6862028fc272e1667355f7">encode_finish</a> ()</td></tr>
<tr class="separator:a521bb83e1e6862028fc272e1667355f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacd9f5d19d16bc7b11579609e242c559"><td class="memItemLeft" align="right" valign="top"><a id="aacd9f5d19d16bc7b11579609e242c559"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Transcoder.html#aacd9f5d19d16bc7b11579609e242c559">close</a> ()</td></tr>
<tr class="memdesc:aacd9f5d19d16bc7b11579609e242c559"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close transcoder, free all ressources. <br /></td></tr>
<tr class="separator:aacd9f5d19d16bc7b11579609e242c559"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac390e42bd912f1579fc27b33495f2f08"><td class="memItemLeft" align="right" valign="top">time_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Transcoder.html#ac390e42bd912f1579fc27b33495f2f08">mtime</a> () const</td></tr>
<tr class="memdesc:ac390e42bd912f1579fc27b33495f2f08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get last modification time of file.  <a href="classFFmpeg__Transcoder.html#ac390e42bd912f1579fc27b33495f2f08">More...</a><br /></td></tr>
<tr class="separator:ac390e42bd912f1579fc27b33495f2f08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbb7051543ede55afe8eae8c8ab345dd"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Transcoder.html#acbb7051543ede55afe8eae8c8ab345dd">duration</a> () const</td></tr>
<tr class="memdesc:acbb7051543ede55afe8eae8c8ab345dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the file duration.  <a href="classFFmpeg__Transcoder.html#acbb7051543ede55afe8eae8c8ab345dd">More...</a><br /></td></tr>
<tr class="separator:acbb7051543ede55afe8eae8c8ab345dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a6211a8309c94b646b7f24adb4128ce"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Transcoder.html#a7a6211a8309c94b646b7f24adb4128ce">predicted_filesize</a> () const</td></tr>
<tr class="memdesc:a7a6211a8309c94b646b7f24adb4128ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to predict the recoded file size. This may (better will surely) be inaccurate.  <a href="classFFmpeg__Transcoder.html#a7a6211a8309c94b646b7f24adb4128ce">More...</a><br /></td></tr>
<tr class="separator:a7a6211a8309c94b646b7f24adb4128ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72f7d34c6a08488495a7a8e154e3d155"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Transcoder.html#a72f7d34c6a08488495a7a8e154e3d155">video_frame_count</a> () const</td></tr>
<tr class="memdesc:a72f7d34c6a08488495a7a8e154e3d155"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of video frames in file.  <a href="classFFmpeg__Transcoder.html#a72f7d34c6a08488495a7a8e154e3d155">More...</a><br /></td></tr>
<tr class="separator:a72f7d34c6a08488495a7a8e154e3d155"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b7f7fba2c298180d3febf6bc8c4fd08"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Transcoder.html#a8b7f7fba2c298180d3febf6bc8c4fd08">segment_count</a> () const</td></tr>
<tr class="memdesc:a8b7f7fba2c298180d3febf6bc8c4fd08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of HLS segments of file.  <a href="classFFmpeg__Transcoder.html#a8b7f7fba2c298180d3febf6bc8c4fd08">More...</a><br /></td></tr>
<tr class="separator:a8b7f7fba2c298180d3febf6bc8c4fd08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84df98a3cadf75bd48b2bdc6afbd4846"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structID3v1.html">ID3v1</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Transcoder.html#a84df98a3cadf75bd48b2bdc6afbd4846">id3v1tag</a> () const</td></tr>
<tr class="memdesc:a84df98a3cadf75bd48b2bdc6afbd4846"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assemble an <a class="el" href="structID3v1.html" title="ID3 version 1 tag">ID3v1</a> file tag.  <a href="classFFmpeg__Transcoder.html#a84df98a3cadf75bd48b2bdc6afbd4846">More...</a><br /></td></tr>
<tr class="separator:a84df98a3cadf75bd48b2bdc6afbd4846"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14a05b2b9cd40816da547e71e619c833"><td class="memItemLeft" align="right" valign="top">virtual const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Transcoder.html#a14a05b2b9cd40816da547e71e619c833">filename</a> () const override</td></tr>
<tr class="memdesc:a14a05b2b9cd40816da547e71e619c833"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return source filename.  <a href="classFFmpeg__Transcoder.html#a14a05b2b9cd40816da547e71e619c833">More...</a><br /></td></tr>
<tr class="separator:a14a05b2b9cd40816da547e71e619c833"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa21bee00bb4def2325d179dc1198beba"><td class="memItemLeft" align="right" valign="top">virtual const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Transcoder.html#aa21bee00bb4def2325d179dc1198beba">destname</a> () const override</td></tr>
<tr class="memdesc:aa21bee00bb4def2325d179dc1198beba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return destination filename.  <a href="classFFmpeg__Transcoder.html#aa21bee00bb4def2325d179dc1198beba">More...</a><br /></td></tr>
<tr class="separator:aa21bee00bb4def2325d179dc1198beba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa09c2468c04eb793d4d006b6c79d4073"><td class="memItemLeft" align="right" valign="top">virtual const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Transcoder.html#aa09c2468c04eb793d4d006b6c79d4073">virtname</a> () const override</td></tr>
<tr class="memdesc:aa09c2468c04eb793d4d006b6c79d4073"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return virtual filename. Same as destination filename, but with virtual (mount) path..  <a href="classFFmpeg__Transcoder.html#aa09c2468c04eb793d4d006b6c79d4073">More...</a><br /></td></tr>
<tr class="separator:aa09c2468c04eb793d4d006b6c79d4073"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3da80243660c43fca519725321d3907"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Transcoder.html#ac3da80243660c43fca519725321d3907">close_output_file</a> ()</td></tr>
<tr class="memdesc:ac3da80243660c43fca519725321d3907"><td class="mdescLeft">&#160;</td><td class="mdescRight">Closes the output file if open and reports lost packets. Can safely be called again after the file was already closed or if the file was never open.  <a href="classFFmpeg__Transcoder.html#ac3da80243660c43fca519725321d3907">More...</a><br /></td></tr>
<tr class="separator:ac3da80243660c43fca519725321d3907"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55add6e3975e57bfe1e73f017a74c584"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Transcoder.html#a55add6e3975e57bfe1e73f017a74c584">close_input_file</a> ()</td></tr>
<tr class="memdesc:a55add6e3975e57bfe1e73f017a74c584"><td class="mdescLeft">&#160;</td><td class="mdescRight">Closes the input file if open. Can safely be called again after the file was already closed or if the file was never open.  <a href="classFFmpeg__Transcoder.html#a55add6e3975e57bfe1e73f017a74c584">More...</a><br /></td></tr>
<tr class="separator:a55add6e3975e57bfe1e73f017a74c584"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a104053334212dc85d388b6471760224f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Transcoder.html#a104053334212dc85d388b6471760224f">stack_seek_frame</a> (uint32_t frame_no)</td></tr>
<tr class="memdesc:a104053334212dc85d388b6471760224f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Seek to a specific frame. Does not actually perform the seek, this is done asynchronously by the transcoder thread.  <a href="classFFmpeg__Transcoder.html#a104053334212dc85d388b6471760224f">More...</a><br /></td></tr>
<tr class="separator:a104053334212dc85d388b6471760224f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4c437963492a1e162f3075f76ac9a3e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Transcoder.html#ae4c437963492a1e162f3075f76ac9a3e">stack_seek_segment</a> (uint32_t segment_no)</td></tr>
<tr class="memdesc:ae4c437963492a1e162f3075f76ac9a3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Seek to a specific HLS segment. Does not actually perform the seek, this is done asynchronously by the transcoder thread.  <a href="classFFmpeg__Transcoder.html#ae4c437963492a1e162f3075f76ac9a3e">More...</a><br /></td></tr>
<tr class="separator:ae4c437963492a1e162f3075f76ac9a3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9952d0e524a33781ff89f3cbd7c93aa1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Transcoder.html#a9952d0e524a33781ff89f3cbd7c93aa1">is_multiformat</a> () const</td></tr>
<tr class="memdesc:a9952d0e524a33781ff89f3cbd7c93aa1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check for an export frame format.  <a href="classFFmpeg__Transcoder.html#a9952d0e524a33781ff89f3cbd7c93aa1">More...</a><br /></td></tr>
<tr class="separator:a9952d0e524a33781ff89f3cbd7c93aa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad14124399e5f41dac9c9c9c9a501edbe"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Transcoder.html#ad14124399e5f41dac9c9c9c9a501edbe">is_frameset</a> () const</td></tr>
<tr class="memdesc:ad14124399e5f41dac9c9c9c9a501edbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check for an export frame format.  <a href="classFFmpeg__Transcoder.html#ad14124399e5f41dac9c9c9c9a501edbe">More...</a><br /></td></tr>
<tr class="separator:ad14124399e5f41dac9c9c9c9a501edbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a730037b1e5595dbe44664e3d2944d544"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Transcoder.html#a730037b1e5595dbe44664e3d2944d544">is_hls</a> () const</td></tr>
<tr class="memdesc:a730037b1e5595dbe44664e3d2944d544"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check for HLS format.  <a href="classFFmpeg__Transcoder.html#a730037b1e5595dbe44664e3d2944d544">More...</a><br /></td></tr>
<tr class="separator:a730037b1e5595dbe44664e3d2944d544"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38dbce3d014b331e215341cb711385e7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Transcoder.html#a38dbce3d014b331e215341cb711385e7">have_seeked</a> () const</td></tr>
<tr class="memdesc:a38dbce3d014b331e215341cb711385e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if we made a seek operation.  <a href="classFFmpeg__Transcoder.html#a38dbce3d014b331e215341cb711385e7">More...</a><br /></td></tr>
<tr class="separator:a38dbce3d014b331e215341cb711385e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b06bec039629fa6a2333ce2185b592d"><td class="memItemLeft" align="right" valign="top"><a id="a5b06bec039629fa6a2333ce2185b592d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Transcoder.html#a5b06bec039629fa6a2333ce2185b592d">flush_buffers</a> ()</td></tr>
<tr class="memdesc:a5b06bec039629fa6a2333ce2185b592d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flush FFmpeg's input buffers. <br /></td></tr>
<tr class="separator:a5b06bec039629fa6a2333ce2185b592d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83072d170c0a285077ff00c5c7c892d4"><td class="memItemLeft" align="right" valign="top"><a id="a83072d170c0a285077ff00c5c7c892d4"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Transcoder.html#a83072d170c0a285077ff00c5c7c892d4">flush_delayed_audio</a> ()</td></tr>
<tr class="memdesc:a83072d170c0a285077ff00c5c7c892d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flush delayed audio packets, if there are any. <br /></td></tr>
<tr class="separator:a83072d170c0a285077ff00c5c7c892d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc68a22d26997e5be8f6ff1600c419ba"><td class="memItemLeft" align="right" valign="top"><a id="adc68a22d26997e5be8f6ff1600c419ba"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Transcoder.html#adc68a22d26997e5be8f6ff1600c419ba">flush_delayed_video</a> ()</td></tr>
<tr class="memdesc:adc68a22d26997e5be8f6ff1600c419ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flush delayed video packets, if there are any. <br /></td></tr>
<tr class="separator:adc68a22d26997e5be8f6ff1600c419ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7fc3ccbcad63d267dcc99a688348115"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Transcoder.html#ab7fc3ccbcad63d267dcc99a688348115">flush_delayed_subtitles</a> ()</td></tr>
<tr class="memdesc:ab7fc3ccbcad63d267dcc99a688348115"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flush delayed subtitle packets, if there are any.  <a href="classFFmpeg__Transcoder.html#ab7fc3ccbcad63d267dcc99a688348115">More...</a><br /></td></tr>
<tr class="separator:ab7fc3ccbcad63d267dcc99a688348115"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classFFmpeg__Base"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classFFmpeg__Base')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classFFmpeg__Base.html">FFmpeg_Base</a></td></tr>
<tr class="memitem:aec5b2722c3e7a1b2fbc70256e48890e2 inherit pub_methods_classFFmpeg__Base"><td class="memItemLeft" align="right" valign="top"><a id="aec5b2722c3e7a1b2fbc70256e48890e2"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Base.html#aec5b2722c3e7a1b2fbc70256e48890e2">FFmpeg_Base</a> ()</td></tr>
<tr class="memdesc:aec5b2722c3e7a1b2fbc70256e48890e2 inherit pub_methods_classFFmpeg__Base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct <a class="el" href="classFFmpeg__Base.html" title="The FFmpeg_Base class.">FFmpeg_Base</a> object. <br /></td></tr>
<tr class="separator:aec5b2722c3e7a1b2fbc70256e48890e2 inherit pub_methods_classFFmpeg__Base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68b57c9f3129c6a0b3ff1601b4f26b6e inherit pub_methods_classFFmpeg__Base"><td class="memItemLeft" align="right" valign="top"><a id="a68b57c9f3129c6a0b3ff1601b4f26b6e"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Base.html#a68b57c9f3129c6a0b3ff1601b4f26b6e">~FFmpeg_Base</a> ()=default</td></tr>
<tr class="memdesc:a68b57c9f3129c6a0b3ff1601b4f26b6e inherit pub_methods_classFFmpeg__Base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destruct <a class="el" href="classFFmpeg__Base.html" title="The FFmpeg_Base class.">FFmpeg_Base</a> object. <br /></td></tr>
<tr class="separator:a68b57c9f3129c6a0b3ff1601b4f26b6e inherit pub_methods_classFFmpeg__Base"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a37eefe55ee19037bb7c230b6d1498ba9"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Transcoder.html#a37eefe55ee19037bb7c230b6d1498ba9">audio_size</a> (size_t *filesize, AVCodecID codec_id, <a class="el" href="ffmpeg__utils_8h.html#a17468d10f0c67a4ee7b38aab09d9e096">BITRATE</a> bit_rate, int64_t <a class="el" href="classFFmpeg__Transcoder.html#acbb7051543ede55afe8eae8c8ab345dd">duration</a>, int channels, int sample_rate, AVSampleFormat sample_format)</td></tr>
<tr class="memdesc:a37eefe55ee19037bb7c230b6d1498ba9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Predict audio file size. This may (better will surely) be inaccurate.  <a href="classFFmpeg__Transcoder.html#a37eefe55ee19037bb7c230b6d1498ba9">More...</a><br /></td></tr>
<tr class="separator:a37eefe55ee19037bb7c230b6d1498ba9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03d1d37a915852aaa88a62331d729198"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Transcoder.html#a03d1d37a915852aaa88a62331d729198">video_size</a> (size_t *filesize, AVCodecID codec_id, <a class="el" href="ffmpeg__utils_8h.html#a17468d10f0c67a4ee7b38aab09d9e096">BITRATE</a> bit_rate, int64_t <a class="el" href="classFFmpeg__Transcoder.html#acbb7051543ede55afe8eae8c8ab345dd">duration</a>, int width, int height, bool interleaved, const AVRational &amp;framerate)</td></tr>
<tr class="memdesc:a03d1d37a915852aaa88a62331d729198"><td class="mdescLeft">&#160;</td><td class="mdescRight">Predict video file size. This may (better will surely) be inaccurate.  <a href="classFFmpeg__Transcoder.html#a03d1d37a915852aaa88a62331d729198">More...</a><br /></td></tr>
<tr class="separator:a03d1d37a915852aaa88a62331d729198"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cf0e2c40fbe581a645c8c8015bcc3db"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Transcoder.html#a7cf0e2c40fbe581a645c8c8015bcc3db">total_overhead</a> (size_t *filesize, <a class="el" href="ffmpeg__utils_8h.html#adf12e2d9ad420681d96f755088d37237">FILETYPE</a> filetype)</td></tr>
<tr class="memdesc:a7cf0e2c40fbe581a645c8c8015bcc3db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Predict overhead in file size. This may (better will surely) be inaccurate.  <a href="classFFmpeg__Transcoder.html#a7cf0e2c40fbe581a645c8c8015bcc3db">More...</a><br /></td></tr>
<tr class="separator:a7cf0e2c40fbe581a645c8c8015bcc3db"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-types"></a>
Protected Types</h2></td></tr>
<tr class="memitem:a069bfc8760dc23399d2f9a044aeacf51"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Transcoder.html#a069bfc8760dc23399d2f9a044aeacf51">HWACCELMODE</a> { <a class="el" href="classFFmpeg__Transcoder.html#a069bfc8760dc23399d2f9a044aeacf51a5f6ad8669ced8c0309664f29cafd8c91">HWACCELMODE_NONE</a>
, <a class="el" href="classFFmpeg__Transcoder.html#a069bfc8760dc23399d2f9a044aeacf51a58cdc8554f2784ac92074a2d36057d14">HWACCELMODE_ENABLED</a>
, <a class="el" href="classFFmpeg__Transcoder.html#a069bfc8760dc23399d2f9a044aeacf51afc06420ac0aaa932f8f4b02a1836f4ff">HWACCELMODE_FALLBACK</a>
 }</td></tr>
<tr class="memdesc:a069bfc8760dc23399d2f9a044aeacf51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Currently active hardware acceleration mode.  <a href="classFFmpeg__Transcoder.html#a069bfc8760dc23399d2f9a044aeacf51">More...</a><br /></td></tr>
<tr class="separator:a069bfc8760dc23399d2f9a044aeacf51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a247d365c635c81bc86b4b553c3dde5ea"><td class="memItemLeft" align="right" valign="top"><a id="a247d365c635c81bc86b4b553c3dde5ea"></a>
typedef struct <a class="el" href="structFFmpeg__Transcoder_1_1BUFFER__DATA.html">FFmpeg_Transcoder::BUFFER_DATA</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Transcoder.html#a247d365c635c81bc86b4b553c3dde5ea">BUFFER_DATA</a></td></tr>
<tr class="memdesc:a247d365c635c81bc86b4b553c3dde5ea"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classBuffer.html" title="The Buffer class.">Buffer</a> structure, used in <a class="el" href="classFFmpeg__Transcoder.html#aa4515e5c135b1ca3fd7fab1d8bc0d943" title="FFmpeg_Transcoder::read_packet.">FFmpeg_Transcoder::read_packet</a>. <br /></td></tr>
<tr class="separator:a247d365c635c81bc86b4b553c3dde5ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1db28dbe32ef55964ad61349a2058a5"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structFFmpeg__Transcoder_1_1PRORES__BITRATE.html">FFmpeg_Transcoder::PRORES_BITRATE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Transcoder.html#aa1db28dbe32ef55964ad61349a2058a5">PRORES_BITRATE</a></td></tr>
<tr class="memdesc:aa1db28dbe32ef55964ad61349a2058a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Predicted bitrates for Apple Prores, see <a href="https://www.apple.com/final-cut-pro/docs/Apple_ProRes_White_Paper.pdf">https://www.apple.com/final-cut-pro/docs/Apple_ProRes_White_Paper.pdf</a>.  <a href="classFFmpeg__Transcoder.html#aa1db28dbe32ef55964ad61349a2058a5">More...</a><br /></td></tr>
<tr class="separator:aa1db28dbe32ef55964ad61349a2058a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a521e0bc5c7fb5f9a96db0d2f738cfca0"><td class="memItemLeft" align="right" valign="top"><a id="a521e0bc5c7fb5f9a96db0d2f738cfca0"></a>
typedef struct <a class="el" href="structFFmpeg__Transcoder_1_1PRORES__BITRATE.html">FFmpeg_Transcoder::PRORES_BITRATE</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Transcoder.html#a521e0bc5c7fb5f9a96db0d2f738cfca0">LPPRORES_BITRATE</a></td></tr>
<tr class="memdesc:a521e0bc5c7fb5f9a96db0d2f738cfca0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer version of <a class="el" href="structFFmpeg__Transcoder_1_1PRORES__BITRATE.html" title="Predicted bitrates for Apple Prores, see https://www.apple.com/final-cut-pro/docs/Apple_ProRes_White_...">PRORES_BITRATE</a>. <br /></td></tr>
<tr class="separator:a521e0bc5c7fb5f9a96db0d2f738cfca0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c03a48640c4c606583646aa36748e77"><td class="memItemLeft" align="right" valign="top"><a id="a1c03a48640c4c606583646aa36748e77"></a>
typedef <a class="el" href="structFFmpeg__Transcoder_1_1PRORES__BITRATE.html">PRORES_BITRATE</a> const  *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Transcoder.html#a1c03a48640c4c606583646aa36748e77">LPCPRORES_BITRATE</a></td></tr>
<tr class="memdesc:a1c03a48640c4c606583646aa36748e77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to const version of <a class="el" href="structFFmpeg__Transcoder_1_1PRORES__BITRATE.html" title="Predicted bitrates for Apple Prores, see https://www.apple.com/final-cut-pro/docs/Apple_ProRes_White_...">PRORES_BITRATE</a>. <br /></td></tr>
<tr class="separator:a1c03a48640c4c606583646aa36748e77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e63ca4a683588925bf0f1bdeae796ff"><td class="memItemLeft" align="right" valign="top"><a id="a5e63ca4a683588925bf0f1bdeae796ff"></a>
typedef std::map&lt; int, <a class="el" href="classFFmpeg__Transcoder_1_1StreamRef.html">StreamRef</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Transcoder.html#a5e63ca4a683588925bf0f1bdeae796ff">StreamRef_map</a></td></tr>
<tr class="memdesc:a5e63ca4a683588925bf0f1bdeae796ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map stream index to <a class="el" href="classFFmpeg__Transcoder_1_1StreamRef.html" title="In/output stream reference data.">StreamRef</a>. <br /></td></tr>
<tr class="separator:a5e63ca4a683588925bf0f1bdeae796ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9f065a7a574e400abac168cec2a556f"><td class="memItemLeft" align="right" valign="top"><a id="ac9f065a7a574e400abac168cec2a556f"></a>
typedef std::map&lt; AVHWDeviceType, AVPixelFormat &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Transcoder.html#ac9f065a7a574e400abac168cec2a556f">DEVICETYPE_MAP</a></td></tr>
<tr class="memdesc:ac9f065a7a574e400abac168cec2a556f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map device types to pixel formats. <br /></td></tr>
<tr class="separator:ac9f065a7a574e400abac168cec2a556f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0963a5147f86b572c97255540219d43"><td class="memItemLeft" align="right" valign="top">typedef enum <a class="el" href="classFFmpeg__Transcoder.html#a069bfc8760dc23399d2f9a044aeacf51">FFmpeg_Transcoder::HWACCELMODE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Transcoder.html#ac0963a5147f86b572c97255540219d43">HWACCELMODE</a></td></tr>
<tr class="memdesc:ac0963a5147f86b572c97255540219d43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Currently active hardware acceleration mode.  <a href="classFFmpeg__Transcoder.html#ac0963a5147f86b572c97255540219d43">More...</a><br /></td></tr>
<tr class="separator:ac0963a5147f86b572c97255540219d43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98c9923bf5a7d887350eed80fad48496"><td class="memItemLeft" align="right" valign="top"><a id="a98c9923bf5a7d887350eed80fad48496"></a>
typedef std::variant&lt; <a class="el" href="classFFmpeg__Frame.html">FFmpeg_Frame</a>, <a class="el" href="classFFmpeg__Subtitle.html">FFmpeg_Subtitle</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Transcoder.html#a98c9923bf5a7d887350eed80fad48496">MULTIFRAME</a></td></tr>
<tr class="memdesc:a98c9923bf5a7d887350eed80fad48496"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combined audio/videoframe and subtitle. <br /></td></tr>
<tr class="separator:a98c9923bf5a7d887350eed80fad48496"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2465e20c57b92f3fc045031a94707544"><td class="memItemLeft" align="right" valign="top"><a id="a2465e20c57b92f3fc045031a94707544"></a>
typedef std::multimap&lt; int64_t, <a class="el" href="classFFmpeg__Transcoder.html#a98c9923bf5a7d887350eed80fad48496">MULTIFRAME</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Transcoder.html#a2465e20c57b92f3fc045031a94707544">MULTIFRAME_MAP</a></td></tr>
<tr class="memdesc:a2465e20c57b92f3fc045031a94707544"><td class="mdescLeft">&#160;</td><td class="mdescRight">Audio frame/video frame/subtitle buffer. <br /></td></tr>
<tr class="separator:a2465e20c57b92f3fc045031a94707544"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5845955828e107d3e3e36b6de8354adb"><td class="memItemLeft" align="right" valign="top"><a id="a5845955828e107d3e3e36b6de8354adb"></a>
typedef std::map&lt; int, int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Transcoder.html#a5845955828e107d3e3e36b6de8354adb">STREAM_MAP</a></td></tr>
<tr class="memdesc:a5845955828e107d3e3e36b6de8354adb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map input subtitle stream to output stream. <br /></td></tr>
<tr class="separator:a5845955828e107d3e3e36b6de8354adb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a737ed97af13b2c5324aadb8f4ffa3ca3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Transcoder.html#a737ed97af13b2c5324aadb8f4ffa3ca3">copy_audio_to_frame_buffer</a> (int *finished)</td></tr>
<tr class="memdesc:a737ed97af13b2c5324aadb8f4ffa3ca3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy data from audio FIFO to frame buffer. Divides WAV data into proper chunks to be fed into the encoder.  <a href="classFFmpeg__Transcoder.html#a737ed97af13b2c5324aadb8f4ffa3ca3">More...</a><br /></td></tr>
<tr class="separator:a737ed97af13b2c5324aadb8f4ffa3ca3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2bea40522d0bf8c4fb31e55c97881a7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Transcoder.html#ac2bea40522d0bf8c4fb31e55c97881a7">open_bestmatch_decoder</a> (AVFormatContext *format_ctx, AVCodecContext **codec_ctx, int *stream_idx, AVMediaType type)</td></tr>
<tr class="memdesc:ac2bea40522d0bf8c4fb31e55c97881a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find best match stream and open codec context for it.  <a href="classFFmpeg__Transcoder.html#ac2bea40522d0bf8c4fb31e55c97881a7">More...</a><br /></td></tr>
<tr class="separator:ac2bea40522d0bf8c4fb31e55c97881a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b605803534f5b45472efc419952ffc3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Transcoder.html#a4b605803534f5b45472efc419952ffc3">open_bestmatch_video</a> ()</td></tr>
<tr class="memdesc:a4b605803534f5b45472efc419952ffc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open the best match video stream, if present in input file.  <a href="classFFmpeg__Transcoder.html#a4b605803534f5b45472efc419952ffc3">More...</a><br /></td></tr>
<tr class="separator:a4b605803534f5b45472efc419952ffc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13cc0b11c9ec3cb067bd9baa72550b7d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Transcoder.html#a13cc0b11c9ec3cb067bd9baa72550b7d">open_bestmatch_audio</a> ()</td></tr>
<tr class="memdesc:a13cc0b11c9ec3cb067bd9baa72550b7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open the best match audio stream.  <a href="classFFmpeg__Transcoder.html#a13cc0b11c9ec3cb067bd9baa72550b7d">More...</a><br /></td></tr>
<tr class="separator:a13cc0b11c9ec3cb067bd9baa72550b7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47031e756634d90dc5e82eef8b38a618"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Transcoder.html#a47031e756634d90dc5e82eef8b38a618">open_subtitles</a> ()</td></tr>
<tr class="memdesc:a47031e756634d90dc5e82eef8b38a618"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open all subtitles streams, if present in input file and if supported by output file. The input and output codec type must also match: Can only transcode bitmap subtitles into bitmap subtitles or text to text.  <a href="classFFmpeg__Transcoder.html#a47031e756634d90dc5e82eef8b38a618">More...</a><br /></td></tr>
<tr class="separator:a47031e756634d90dc5e82eef8b38a618"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c9bf0428b8c28d8c09e748ed987c1aa"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Transcoder.html#a0c9bf0428b8c28d8c09e748ed987c1aa">open_albumarts</a> ()</td></tr>
<tr class="memdesc:a0c9bf0428b8c28d8c09e748ed987c1aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">open_albumarts  <a href="classFFmpeg__Transcoder.html#a0c9bf0428b8c28d8c09e748ed987c1aa">More...</a><br /></td></tr>
<tr class="separator:a0c9bf0428b8c28d8c09e748ed987c1aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8082130dde633c72a01bfc392387d3d9"><td class="memItemLeft" align="right" valign="top">AVPixelFormat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Transcoder.html#a8082130dde633c72a01bfc392387d3d9">get_hw_pix_fmt</a> (const AVCodec *codec, AVHWDeviceType dev_type, bool use_device_ctx) const</td></tr>
<tr class="memdesc:a8082130dde633c72a01bfc392387d3d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine the hardware pixel format for the codec, if applicable.  <a href="classFFmpeg__Transcoder.html#a8082130dde633c72a01bfc392387d3d9">More...</a><br /></td></tr>
<tr class="separator:a8082130dde633c72a01bfc392387d3d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa930a77b301f5a24bb3c2fafa85b89e9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Transcoder.html#aa930a77b301f5a24bb3c2fafa85b89e9">open_decoder</a> (AVFormatContext *format_ctx, AVCodecContext **codec_ctx, int stream_idx, const AVCodec *input_codec, AVMediaType mediatype)</td></tr>
<tr class="memdesc:aa930a77b301f5a24bb3c2fafa85b89e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open codec context for stream_idx.  <a href="classFFmpeg__Transcoder.html#aa930a77b301f5a24bb3c2fafa85b89e9">More...</a><br /></td></tr>
<tr class="separator:aa930a77b301f5a24bb3c2fafa85b89e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac45e5ea83a42253119635023ce8d8e6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Transcoder.html#aac45e5ea83a42253119635023ce8d8e6">open_output_frame_set</a> (<a class="el" href="classBuffer.html">Buffer</a> *buffer)</td></tr>
<tr class="memdesc:aac45e5ea83a42253119635023ce8d8e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open output frame set. Data will actually be written to buffer and copied by FUSE when accessed.  <a href="classFFmpeg__Transcoder.html#aac45e5ea83a42253119635023ce8d8e6">More...</a><br /></td></tr>
<tr class="separator:aac45e5ea83a42253119635023ce8d8e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d77a6730de37eff3a8dc295e95a4c9d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Transcoder.html#a0d77a6730de37eff3a8dc295e95a4c9d">open_output</a> (<a class="el" href="classBuffer.html">Buffer</a> *buffer)</td></tr>
<tr class="memdesc:a0d77a6730de37eff3a8dc295e95a4c9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open output file. Data will actually be written to buffer and copied by FUSE when accessed.  <a href="classFFmpeg__Transcoder.html#a0d77a6730de37eff3a8dc295e95a4c9d">More...</a><br /></td></tr>
<tr class="separator:a0d77a6730de37eff3a8dc295e95a4c9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5bdbf25667f6f7440ddc5194e39aac9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Transcoder.html#ad5bdbf25667f6f7440ddc5194e39aac9">process_output</a> ()</td></tr>
<tr class="memdesc:ad5bdbf25667f6f7440ddc5194e39aac9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Process headers of output file Write file header, process meta data and add album arts.  <a href="classFFmpeg__Transcoder.html#ad5bdbf25667f6f7440ddc5194e39aac9">More...</a><br /></td></tr>
<tr class="separator:ad5bdbf25667f6f7440ddc5194e39aac9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e5172ec9ba20ff8229712b2ce4d2c11"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Transcoder.html#a6e5172ec9ba20ff8229712b2ce4d2c11">is_video</a> () const</td></tr>
<tr class="separator:a6e5172ec9ba20ff8229712b2ce4d2c11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5aa9df18335022dc4127fb601b6c2ce2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Transcoder.html#a5aa9df18335022dc4127fb601b6c2ce2">update_codec</a> (void *opt, const <a class="el" href="classFFmpeg__Profiles.html#a8c96ed075fd81ebc334ad2a0e89bc114">PROFILE_OPTION_VEC</a> &amp;profile_option_vec) const</td></tr>
<tr class="memdesc:a5aa9df18335022dc4127fb601b6c2ce2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepare codec options.  <a href="classFFmpeg__Transcoder.html#a5aa9df18335022dc4127fb601b6c2ce2">More...</a><br /></td></tr>
<tr class="separator:a5aa9df18335022dc4127fb601b6c2ce2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a942d65ca55684bbca639af2d0ea30143"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Transcoder.html#a942d65ca55684bbca639af2d0ea30143">prepare_codec</a> (void *opt, <a class="el" href="ffmpeg__utils_8h.html#adf12e2d9ad420681d96f755088d37237">FILETYPE</a> filetype) const</td></tr>
<tr class="memdesc:a942d65ca55684bbca639af2d0ea30143"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepare codec options for a file type.  <a href="classFFmpeg__Transcoder.html#a942d65ca55684bbca639af2d0ea30143">More...</a><br /></td></tr>
<tr class="separator:a942d65ca55684bbca639af2d0ea30143"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe22b3a4c7ad7fa2ca8219f5b76f2542"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Transcoder.html#afe22b3a4c7ad7fa2ca8219f5b76f2542">add_stream</a> (AVCodecID codec_id)</td></tr>
<tr class="memdesc:afe22b3a4c7ad7fa2ca8219f5b76f2542"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add new stream to output file.  <a href="classFFmpeg__Transcoder.html#afe22b3a4c7ad7fa2ca8219f5b76f2542">More...</a><br /></td></tr>
<tr class="separator:afe22b3a4c7ad7fa2ca8219f5b76f2542"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04d4003ac05d9a07dfe94d67a6d6fa48"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Transcoder.html#a04d4003ac05d9a07dfe94d67a6d6fa48">add_subtitle_stream</a> (AVCodecID codec_id, <a class="el" href="classFFmpeg__Transcoder_1_1StreamRef.html">StreamRef</a> &amp;input_streamref, const std::optional&lt; std::string &gt; &amp;language=std::nullopt)</td></tr>
<tr class="memdesc:a04d4003ac05d9a07dfe94d67a6d6fa48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add new subtitle stream to output file.  <a href="classFFmpeg__Transcoder.html#a04d4003ac05d9a07dfe94d67a6d6fa48">More...</a><br /></td></tr>
<tr class="separator:a04d4003ac05d9a07dfe94d67a6d6fa48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e8ce09d8256cd2d6200b87ea84044dc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Transcoder.html#a2e8ce09d8256cd2d6200b87ea84044dc">add_stream_copy</a> (AVCodecID codec_id, AVMediaType codec_type)</td></tr>
<tr class="memdesc:a2e8ce09d8256cd2d6200b87ea84044dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add new stream copy to output file.  <a href="classFFmpeg__Transcoder.html#a2e8ce09d8256cd2d6200b87ea84044dc">More...</a><br /></td></tr>
<tr class="separator:a2e8ce09d8256cd2d6200b87ea84044dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f6903a86d5ed1ebee3258b981536f74"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Transcoder.html#a7f6903a86d5ed1ebee3258b981536f74">add_albumart_stream</a> (const AVCodecContext *input_codec_ctx)</td></tr>
<tr class="memdesc:a7f6903a86d5ed1ebee3258b981536f74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a stream for an album art.  <a href="classFFmpeg__Transcoder.html#a7f6903a86d5ed1ebee3258b981536f74">More...</a><br /></td></tr>
<tr class="separator:a7f6903a86d5ed1ebee3258b981536f74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ead4d48dfe32cb96e5495b4efadcf6a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Transcoder.html#a6ead4d48dfe32cb96e5495b4efadcf6a">add_albumart_frame</a> (AVStream *output_stream, AVPacket *pkt_in)</td></tr>
<tr class="memdesc:a6ead4d48dfe32cb96e5495b4efadcf6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add album art to stream.  <a href="classFFmpeg__Transcoder.html#a6ead4d48dfe32cb96e5495b4efadcf6a">More...</a><br /></td></tr>
<tr class="separator:a6ead4d48dfe32cb96e5495b4efadcf6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97298697701d9e28f8c29580a6951237"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Transcoder.html#a97298697701d9e28f8c29580a6951237">open_output_filestreams</a> (<a class="el" href="classBuffer.html">Buffer</a> *buffer)</td></tr>
<tr class="memdesc:a97298697701d9e28f8c29580a6951237"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open an output file and the required encoder. Also set some basic encoder parameters. Some of these parameters are based on the input file's parameters.  <a href="classFFmpeg__Transcoder.html#a97298697701d9e28f8c29580a6951237">More...</a><br /></td></tr>
<tr class="separator:a97298697701d9e28f8c29580a6951237"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac01386c453288f63a13c25cbea940c5b"><td class="memTemplParams" colspan="2">template&lt;size_t size&gt; </td></tr>
<tr class="memitem:ac01386c453288f63a13c25cbea940c5b"><td class="memTemplItemLeft" align="right" valign="top">const char *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFFmpeg__Transcoder.html#ac01386c453288f63a13c25cbea940c5b">tagcpy</a> (char(&amp;out)[size], const std::string &amp;in) const</td></tr>
<tr class="memdesc:ac01386c453288f63a13c25cbea940c5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Safely copy a tag to a target buffer. If the input buffer size is larger than output the data will be truncated to avoid overruns. The function never appends a /0 terminator.  <a href="classFFmpeg__Transcoder.html#ac01386c453288f63a13c25cbea940c5b">More...</a><br /></td></tr>
<tr class="separator:ac01386c453288f63a13c25cbea940c5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59c121eb236f4843a42c8b9bd8092089"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Transcoder.html#a59c121eb236f4843a42c8b9bd8092089">copy_metadata</a> (AVDictionary **metadata_out, const AVDictionary *metadata_in, bool contentstream=true)</td></tr>
<tr class="memdesc:a59c121eb236f4843a42c8b9bd8092089"><td class="mdescLeft">&#160;</td><td class="mdescRight">Process the metadata in the FFmpeg file. This should be called at the beginning, before reading audio data. The set_text_tag() and set_picture_tag() methods of the given Encoder will be used to set the metadata, with results going into the given <a class="el" href="classBuffer.html" title="The Buffer class.">Buffer</a>. This function will also read the actual PCM stream parameters.  <a href="classFFmpeg__Transcoder.html#a59c121eb236f4843a42c8b9bd8092089">More...</a><br /></td></tr>
<tr class="separator:a59c121eb236f4843a42c8b9bd8092089"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcb1a10b6a56f504f03bd06142e2da43"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Transcoder.html#abcb1a10b6a56f504f03bd06142e2da43">process_metadata</a> ()</td></tr>
<tr class="memdesc:abcb1a10b6a56f504f03bd06142e2da43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy metadata from source to target.  <a href="classFFmpeg__Transcoder.html#abcb1a10b6a56f504f03bd06142e2da43">More...</a><br /></td></tr>
<tr class="separator:abcb1a10b6a56f504f03bd06142e2da43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1313f014849b4990dbc7c9b1538c108"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Transcoder.html#ab1313f014849b4990dbc7c9b1538c108">process_albumarts</a> ()</td></tr>
<tr class="memdesc:ab1313f014849b4990dbc7c9b1538c108"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy all album arts from source to target.  <a href="classFFmpeg__Transcoder.html#ab1313f014849b4990dbc7c9b1538c108">More...</a><br /></td></tr>
<tr class="separator:ab1313f014849b4990dbc7c9b1538c108"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6573a50f95e464137ca200abb19dbf5e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Transcoder.html#a6573a50f95e464137ca200abb19dbf5e">init_resampler</a> ()</td></tr>
<tr class="memdesc:a6573a50f95e464137ca200abb19dbf5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the audio resampler based on the input and output codec settings. If the input and output sample formats differ, a conversion is required libswresample takes care of this, but requires initialization.  <a href="classFFmpeg__Transcoder.html#a6573a50f95e464137ca200abb19dbf5e">More...</a><br /></td></tr>
<tr class="separator:a6573a50f95e464137ca200abb19dbf5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd06225d230d8a6561e9febfd84d7e03"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Transcoder.html#acd06225d230d8a6561e9febfd84d7e03">init_audio_fifo</a> ()</td></tr>
<tr class="memdesc:acd06225d230d8a6561e9febfd84d7e03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialise a FIFO buffer for the audio samples to be encoded.  <a href="classFFmpeg__Transcoder.html#acd06225d230d8a6561e9febfd84d7e03">More...</a><br /></td></tr>
<tr class="separator:acd06225d230d8a6561e9febfd84d7e03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade3130afeae33293eac150d65a714c88"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Transcoder.html#ade3130afeae33293eac150d65a714c88">update_format</a> (AVDictionary **dict, const <a class="el" href="classFFmpeg__Profiles.html#a8c96ed075fd81ebc334ad2a0e89bc114">PROFILE_OPTION_VEC</a> &amp;option_vec) const</td></tr>
<tr class="memdesc:ade3130afeae33293eac150d65a714c88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update format options.  <a href="classFFmpeg__Transcoder.html#ade3130afeae33293eac150d65a714c88">More...</a><br /></td></tr>
<tr class="separator:ade3130afeae33293eac150d65a714c88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a446ae8092e28817c97c3fb74ad1acc19"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Transcoder.html#a446ae8092e28817c97c3fb74ad1acc19">prepare_format</a> (AVDictionary **dict, <a class="el" href="ffmpeg__utils_8h.html#adf12e2d9ad420681d96f755088d37237">FILETYPE</a> filetype) const</td></tr>
<tr class="memdesc:a446ae8092e28817c97c3fb74ad1acc19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepare format optimisations.  <a href="classFFmpeg__Transcoder.html#a446ae8092e28817c97c3fb74ad1acc19">More...</a><br /></td></tr>
<tr class="separator:a446ae8092e28817c97c3fb74ad1acc19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e8f3a668b66cec31e5b10042cf80c2a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Transcoder.html#a9e8f3a668b66cec31e5b10042cf80c2a">write_output_file_header</a> ()</td></tr>
<tr class="memdesc:a9e8f3a668b66cec31e5b10042cf80c2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the header of the output file container.  <a href="classFFmpeg__Transcoder.html#a9e8f3a668b66cec31e5b10042cf80c2a">More...</a><br /></td></tr>
<tr class="separator:a9e8f3a668b66cec31e5b10042cf80c2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a228b0dad4daf77a0313dad46f12186"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Transcoder.html#a2a228b0dad4daf77a0313dad46f12186">store_packet</a> (AVPacket *pkt, AVMediaType mediatype)</td></tr>
<tr class="memdesc:a2a228b0dad4daf77a0313dad46f12186"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store packet in output stream.  <a href="classFFmpeg__Transcoder.html#a2a228b0dad4daf77a0313dad46f12186">More...</a><br /></td></tr>
<tr class="separator:a2a228b0dad4daf77a0313dad46f12186"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab26699456ab881329e1ca9aebae74ba5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Transcoder.html#ab26699456ab881329e1ca9aebae74ba5">decode_audio_frame</a> (AVPacket *pkt, int *decoded)</td></tr>
<tr class="memdesc:ab26699456ab881329e1ca9aebae74ba5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode one audio frame.  <a href="classFFmpeg__Transcoder.html#ab26699456ab881329e1ca9aebae74ba5">More...</a><br /></td></tr>
<tr class="separator:ab26699456ab881329e1ca9aebae74ba5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45d6501228351ff6407f0af09596d09f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Transcoder.html#a45d6501228351ff6407f0af09596d09f">decode_video_frame</a> (AVPacket *pkt, int *decoded)</td></tr>
<tr class="memdesc:a45d6501228351ff6407f0af09596d09f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode one video frame.  <a href="classFFmpeg__Transcoder.html#a45d6501228351ff6407f0af09596d09f">More...</a><br /></td></tr>
<tr class="separator:a45d6501228351ff6407f0af09596d09f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a466c279d789c324cefa274f1a60e1033"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Transcoder.html#a466c279d789c324cefa274f1a60e1033">decode_subtitle</a> (AVPacket *pkt, int *decoded)</td></tr>
<tr class="memdesc:a466c279d789c324cefa274f1a60e1033"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode one subtitle.  <a href="classFFmpeg__Transcoder.html#a466c279d789c324cefa274f1a60e1033">More...</a><br /></td></tr>
<tr class="separator:a466c279d789c324cefa274f1a60e1033"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8ab9f0b9a15115445e4e10ac89be0d2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Transcoder.html#af8ab9f0b9a15115445e4e10ac89be0d2">decode_subtitle</a> (AVCodecContext *codec_ctx, AVPacket *pkt, int *decoded, int out_stream_idx)</td></tr>
<tr class="memdesc:af8ab9f0b9a15115445e4e10ac89be0d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode one subtitle.  <a href="classFFmpeg__Transcoder.html#af8ab9f0b9a15115445e4e10ac89be0d2">More...</a><br /></td></tr>
<tr class="separator:af8ab9f0b9a15115445e4e10ac89be0d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96c31a851e95a6fb714b2908c83ec696"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Transcoder.html#a96c31a851e95a6fb714b2908c83ec696">decode_frame</a> (AVPacket *pkt)</td></tr>
<tr class="memdesc:a96c31a851e95a6fb714b2908c83ec696"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode one frame.  <a href="classFFmpeg__Transcoder.html#a96c31a851e95a6fb714b2908c83ec696">More...</a><br /></td></tr>
<tr class="separator:a96c31a851e95a6fb714b2908c83ec696"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a509e0e8082e8f270388ebb6abad29907"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Transcoder.html#a509e0e8082e8f270388ebb6abad29907">init_converted_samples</a> (uint8_t ***converted_input_samples, int frame_size)</td></tr>
<tr class="memdesc:a509e0e8082e8f270388ebb6abad29907"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialise a temporary storage for the specified number of audio samples. The conversion requires temporary storage due to the different format. The number of audio samples to be allocated is specified in frame_size.  <a href="classFFmpeg__Transcoder.html#a509e0e8082e8f270388ebb6abad29907">More...</a><br /></td></tr>
<tr class="separator:a509e0e8082e8f270388ebb6abad29907"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada3ad7eef000399122463376320acb54"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Transcoder.html#ada3ad7eef000399122463376320acb54">convert_samples</a> (uint8_t **input_data, int in_samples, uint8_t **converted_data, int *out_samples)</td></tr>
<tr class="memdesc:ada3ad7eef000399122463376320acb54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert the input audio samples into the output sample format. The conversion happens on a per-frame basis, the size of which is specified by frame_size.  <a href="classFFmpeg__Transcoder.html#ada3ad7eef000399122463376320acb54">More...</a><br /></td></tr>
<tr class="separator:ada3ad7eef000399122463376320acb54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02a175b227e2975a3be0578787900c02"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Transcoder.html#a02a175b227e2975a3be0578787900c02">add_samples_to_fifo</a> (uint8_t **converted_input_samples, int frame_size)</td></tr>
<tr class="memdesc:a02a175b227e2975a3be0578787900c02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add converted input audio samples to the FIFO buffer for later processing.  <a href="classFFmpeg__Transcoder.html#a02a175b227e2975a3be0578787900c02">More...</a><br /></td></tr>
<tr class="separator:a02a175b227e2975a3be0578787900c02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f90d7ec4715b359d5b666f5ab4b23b7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Transcoder.html#a0f90d7ec4715b359d5b666f5ab4b23b7">flush_frames_all</a> (bool use_flush_packet)</td></tr>
<tr class="memdesc:a0f90d7ec4715b359d5b666f5ab4b23b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flush the remaining frames for all streams.  <a href="classFFmpeg__Transcoder.html#a0f90d7ec4715b359d5b666f5ab4b23b7">More...</a><br /></td></tr>
<tr class="separator:a0f90d7ec4715b359d5b666f5ab4b23b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8e11d701c658686dbb9209fbaddf245"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Transcoder.html#aa8e11d701c658686dbb9209fbaddf245">flush_frames_single</a> (int stream_idx, bool use_flush_packet)</td></tr>
<tr class="memdesc:aa8e11d701c658686dbb9209fbaddf245"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flush the remaining frames.  <a href="classFFmpeg__Transcoder.html#aa8e11d701c658686dbb9209fbaddf245">More...</a><br /></td></tr>
<tr class="separator:aa8e11d701c658686dbb9209fbaddf245"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6afa2189ecd068bcbaa1054835db27c4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Transcoder.html#a6afa2189ecd068bcbaa1054835db27c4">read_decode_convert_and_store</a> (int *finished)</td></tr>
<tr class="memdesc:a6afa2189ecd068bcbaa1054835db27c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read frame from source file, decode and store in FIFO.  <a href="classFFmpeg__Transcoder.html#a6afa2189ecd068bcbaa1054835db27c4">More...</a><br /></td></tr>
<tr class="separator:a6afa2189ecd068bcbaa1054835db27c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a868b41a725d6670538821f8deb62ac21"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Transcoder.html#a868b41a725d6670538821f8deb62ac21">init_audio_output_frame</a> (AVFrame *frame, int frame_size) const</td></tr>
<tr class="memdesc:a868b41a725d6670538821f8deb62ac21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialise one input frame for writing to the output file. The frame will be exactly frame_size samples large.  <a href="classFFmpeg__Transcoder.html#a868b41a725d6670538821f8deb62ac21">More...</a><br /></td></tr>
<tr class="separator:a868b41a725d6670538821f8deb62ac21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f11f9e84745323aab9860906f1f8df4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Transcoder.html#a8f11f9e84745323aab9860906f1f8df4">alloc_picture</a> (AVFrame *frame, AVPixelFormat pix_fmt, int width, int height) const</td></tr>
<tr class="memdesc:a8f11f9e84745323aab9860906f1f8df4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate memory for one picture.  <a href="classFFmpeg__Transcoder.html#a8f11f9e84745323aab9860906f1f8df4">More...</a><br /></td></tr>
<tr class="separator:a8f11f9e84745323aab9860906f1f8df4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9493510e3944742d2027f0d2b459f0c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Transcoder.html#ae9493510e3944742d2027f0d2b459f0c">produce_audio_dts</a> (AVPacket *pkt)</td></tr>
<tr class="memdesc:ae9493510e3944742d2027f0d2b459f0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Produce audio dts/pts. This is required because the target codec usually has a different frame size than the source, so the number of packets will not match 1:1.  <a href="classFFmpeg__Transcoder.html#ae9493510e3944742d2027f0d2b459f0c">More...</a><br /></td></tr>
<tr class="separator:ae9493510e3944742d2027f0d2b459f0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a845c52b18f172428a2ee79d6348a865e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Transcoder.html#a845c52b18f172428a2ee79d6348a865e">decode</a> (AVCodecContext *codec_ctx, AVFrame *frame, int *got_frame, const AVPacket *pkt) const</td></tr>
<tr class="separator:a845c52b18f172428a2ee79d6348a865e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e1b9748cf1e7d04dfebd847f6351ab0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Transcoder.html#a9e1b9748cf1e7d04dfebd847f6351ab0">create_audio_frame</a> (int frame_size)</td></tr>
<tr class="memdesc:a9e1b9748cf1e7d04dfebd847f6351ab0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load one audio frame from the FIFO buffer and store in frame buffer.  <a href="classFFmpeg__Transcoder.html#a9e1b9748cf1e7d04dfebd847f6351ab0">More...</a><br /></td></tr>
<tr class="separator:a9e1b9748cf1e7d04dfebd847f6351ab0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affc23e2d1591fa27090622c217a7e3fd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Transcoder.html#affc23e2d1591fa27090622c217a7e3fd">encode_audio_frame</a> (const AVFrame *frame, int *data_present)</td></tr>
<tr class="memdesc:affc23e2d1591fa27090622c217a7e3fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create one frame worth of audio to the output file.  <a href="classFFmpeg__Transcoder.html#affc23e2d1591fa27090622c217a7e3fd">More...</a><br /></td></tr>
<tr class="separator:affc23e2d1591fa27090622c217a7e3fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67f31ad62ffd89e4ea45a357bc8a746a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Transcoder.html#a67f31ad62ffd89e4ea45a357bc8a746a">encode_video_frame</a> (const AVFrame *frame, int *data_present)</td></tr>
<tr class="memdesc:a67f31ad62ffd89e4ea45a357bc8a746a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encode one frame worth of video to the output file.  <a href="classFFmpeg__Transcoder.html#a67f31ad62ffd89e4ea45a357bc8a746a">More...</a><br /></td></tr>
<tr class="separator:a67f31ad62ffd89e4ea45a357bc8a746a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe2f336556333467127884b153abc844"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Transcoder.html#afe2f336556333467127884b153abc844">encode_subtitle</a> (const AVSubtitle *sub, int out_stream_idx, int *data_present)</td></tr>
<tr class="memdesc:afe2f336556333467127884b153abc844"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encode one subtitle frame to the output file.  <a href="classFFmpeg__Transcoder.html#afe2f336556333467127884b153abc844">More...</a><br /></td></tr>
<tr class="separator:afe2f336556333467127884b153abc844"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a892362d764d2d5170da31069ac41aaca"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Transcoder.html#a892362d764d2d5170da31069ac41aaca">encode_image_frame</a> (const AVFrame *frame, int *data_present)</td></tr>
<tr class="memdesc:a892362d764d2d5170da31069ac41aaca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encode frame to image.  <a href="classFFmpeg__Transcoder.html#a892362d764d2d5170da31069ac41aaca">More...</a><br /></td></tr>
<tr class="separator:a892362d764d2d5170da31069ac41aaca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad58ed3d5a8dc2f608e94a696d4cc3ac"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Transcoder.html#aad58ed3d5a8dc2f608e94a696d4cc3ac">write_output_file_trailer</a> ()</td></tr>
<tr class="memdesc:aad58ed3d5a8dc2f608e94a696d4cc3ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the trailer of the output file container.  <a href="classFFmpeg__Transcoder.html#aad58ed3d5a8dc2f608e94a696d4cc3ac">More...</a><br /></td></tr>
<tr class="separator:aad58ed3d5a8dc2f608e94a696d4cc3ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a854e9576e697fb877c2e344c5c203947"><td class="memItemLeft" align="right" valign="top"><a id="a854e9576e697fb877c2e344c5c203947"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Transcoder.html#a854e9576e697fb877c2e344c5c203947">calculate_predicted_filesize</a> () const</td></tr>
<tr class="memdesc:a854e9576e697fb877c2e344c5c203947"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to predict final file size. <br /></td></tr>
<tr class="separator:a854e9576e697fb877c2e344c5c203947"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7c3726c0165e3061d1fc4ef66985e87"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Transcoder.html#af7c3726c0165e3061d1fc4ef66985e87">get_video_size</a> (int *output_width, int *output_height) const</td></tr>
<tr class="memdesc:af7c3726c0165e3061d1fc4ef66985e87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the size of the output video based on user selection and apsect ratio.  <a href="classFFmpeg__Transcoder.html#af7c3726c0165e3061d1fc4ef66985e87">More...</a><br /></td></tr>
<tr class="separator:af7c3726c0165e3061d1fc4ef66985e87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60e8d1769bf1ec0917d0cc55e9d50cc2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Transcoder.html#a60e8d1769bf1ec0917d0cc55e9d50cc2">get_aspect_ratio</a> (int width, int height, const AVRational &amp;sar, AVRational *ar) const</td></tr>
<tr class="memdesc:a60e8d1769bf1ec0917d0cc55e9d50cc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate aspect ratio for width/height and sample aspect ratio (sar).  <a href="classFFmpeg__Transcoder.html#a60e8d1769bf1ec0917d0cc55e9d50cc2">More...</a><br /></td></tr>
<tr class="separator:a60e8d1769bf1ec0917d0cc55e9d50cc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43f0931f679eebe77ccf75089308c623"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Transcoder.html#a43f0931f679eebe77ccf75089308c623">init_deinterlace_filters</a> (AVCodecContext *codec_ctx, AVPixelFormat pix_fmt, const AVRational &amp;avg_frame_rate, const AVRational &amp;time_base)</td></tr>
<tr class="memdesc:a43f0931f679eebe77ccf75089308c623"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialise video filters.  <a href="classFFmpeg__Transcoder.html#a43f0931f679eebe77ccf75089308c623">More...</a><br /></td></tr>
<tr class="separator:a43f0931f679eebe77ccf75089308c623"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cfebc7d896c2fc66d6832fd477edb63"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Transcoder.html#a4cfebc7d896c2fc66d6832fd477edb63">send_filters</a> (<a class="el" href="classFFmpeg__Frame.html">FFmpeg_Frame</a> *srcframe, int &amp;ret)</td></tr>
<tr class="memdesc:a4cfebc7d896c2fc66d6832fd477edb63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send video frame to the filters.  <a href="classFFmpeg__Transcoder.html#a4cfebc7d896c2fc66d6832fd477edb63">More...</a><br /></td></tr>
<tr class="separator:a4cfebc7d896c2fc66d6832fd477edb63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0feb18e287c35ad3ffa184f727bdd67"><td class="memItemLeft" align="right" valign="top"><a id="aa0feb18e287c35ad3ffa184f727bdd67"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Transcoder.html#aa0feb18e287c35ad3ffa184f727bdd67">free_filters</a> ()</td></tr>
<tr class="memdesc:aa0feb18e287c35ad3ffa184f727bdd67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free filter sinks. <br /></td></tr>
<tr class="separator:aa0feb18e287c35ad3ffa184f727bdd67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f1608f6c5c6d8efe099b8e9869cd259"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Transcoder.html#a1f1608f6c5c6d8efe099b8e9869cd259">can_copy_stream</a> (const AVStream *stream) const</td></tr>
<tr class="memdesc:a1f1608f6c5c6d8efe099b8e9869cd259"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if stream can be copied from input to output (AUTOCOPY option).  <a href="classFFmpeg__Transcoder.html#a1f1608f6c5c6d8efe099b8e9869cd259">More...</a><br /></td></tr>
<tr class="separator:a1f1608f6c5c6d8efe099b8e9869cd259"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf6945c2faeb27af1db8a75ef3d52efd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Transcoder.html#aaf6945c2faeb27af1db8a75ef3d52efd">close_resample</a> ()</td></tr>
<tr class="memdesc:aaf6945c2faeb27af1db8a75ef3d52efd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close and free the resampler context.  <a href="classFFmpeg__Transcoder.html#aaf6945c2faeb27af1db8a75ef3d52efd">More...</a><br /></td></tr>
<tr class="separator:aaf6945c2faeb27af1db8a75ef3d52efd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcb61c1ba5a92ec7d8c8797f57938228"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Transcoder.html#abcb61c1ba5a92ec7d8c8797f57938228">init_rescaler</a> (AVPixelFormat in_pix_fmt, int in_width, int in_height, AVPixelFormat out_pix_fmt, int out_width, int out_height)</td></tr>
<tr class="memdesc:abcb61c1ba5a92ec7d8c8797f57938228"><td class="mdescLeft">&#160;</td><td class="mdescRight">Init image size rescaler and pixel format converter.  <a href="classFFmpeg__Transcoder.html#abcb61c1ba5a92ec7d8c8797f57938228">More...</a><br /></td></tr>
<tr class="separator:abcb61c1ba5a92ec7d8c8797f57938228"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a118d031aacd8398c1696ea1fc3f25a71"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Transcoder.html#a118d031aacd8398c1696ea1fc3f25a71">purge_audio_fifo</a> ()</td></tr>
<tr class="memdesc:a118d031aacd8398c1696ea1fc3f25a71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Purge all samples in audio FIFO.  <a href="classFFmpeg__Transcoder.html#a118d031aacd8398c1696ea1fc3f25a71">More...</a><br /></td></tr>
<tr class="separator:a118d031aacd8398c1696ea1fc3f25a71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a269aac0e72c7132ab8ec33f4e715afe2"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Transcoder.html#a269aac0e72c7132ab8ec33f4e715afe2">purge_multiframe_map</a> ()</td></tr>
<tr class="memdesc:a269aac0e72c7132ab8ec33f4e715afe2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Purge all frames in buffer.  <a href="classFFmpeg__Transcoder.html#a269aac0e72c7132ab8ec33f4e715afe2">More...</a><br /></td></tr>
<tr class="separator:a269aac0e72c7132ab8ec33f4e715afe2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accfa0ea6196c1211b3aa4acce34597c6"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Transcoder.html#accfa0ea6196c1211b3aa4acce34597c6">purge_hls_fifo</a> ()</td></tr>
<tr class="memdesc:accfa0ea6196c1211b3aa4acce34597c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Purge all packets in HLS FIFO buffer.  <a href="classFFmpeg__Transcoder.html#accfa0ea6196c1211b3aa4acce34597c6">More...</a><br /></td></tr>
<tr class="separator:accfa0ea6196c1211b3aa4acce34597c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e56532fedbd4c95bf0db3da6ecfdc5a"><td class="memItemLeft" align="right" valign="top"><a id="a2e56532fedbd4c95bf0db3da6ecfdc5a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Transcoder.html#a2e56532fedbd4c95bf0db3da6ecfdc5a">purge</a> ()</td></tr>
<tr class="memdesc:a2e56532fedbd4c95bf0db3da6ecfdc5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Purge FIFO and map buffers and report lost packets/frames/samples. <br /></td></tr>
<tr class="separator:a2e56532fedbd4c95bf0db3da6ecfdc5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83770fa583f1d2efc214c4affdbf3687"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Transcoder.html#a83770fa583f1d2efc214c4affdbf3687">do_seek_frame</a> (uint32_t frame_no)</td></tr>
<tr class="memdesc:a83770fa583f1d2efc214c4affdbf3687"><td class="mdescLeft">&#160;</td><td class="mdescRight">Actually perform seek for frame. This function ensures that it is positioned at a key frame, so the resulting position may be different from the requested. If e.g. frame no. 24 is a key frame, and frame_no is set to 28, the actual position will be at frame 24.  <a href="classFFmpeg__Transcoder.html#a83770fa583f1d2efc214c4affdbf3687">More...</a><br /></td></tr>
<tr class="separator:a83770fa583f1d2efc214c4affdbf3687"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bf8d0e53fa97cd6d488c7d6ebf8df18"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Transcoder.html#a9bf8d0e53fa97cd6d488c7d6ebf8df18">skip_decoded_frames</a> (uint32_t frame_no, bool forced_seek)</td></tr>
<tr class="memdesc:a9bf8d0e53fa97cd6d488c7d6ebf8df18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Skip decoded frames or force seek to frame_no.  <a href="classFFmpeg__Transcoder.html#a9bf8d0e53fa97cd6d488c7d6ebf8df18">More...</a><br /></td></tr>
<tr class="separator:a9bf8d0e53fa97cd6d488c7d6ebf8df18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4fff93bbb68d997bdab241dee973628"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Transcoder.html#af4fff93bbb68d997bdab241dee973628">get_pix_formats</a> (AVPixelFormat *in_pix_fmt, AVPixelFormat *out_pix_fmt, AVCodecContext *output_codec_ctx=nullptr) const</td></tr>
<tr class="memdesc:af4fff93bbb68d997bdab241dee973628"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get correct input and output pixel format.  <a href="classFFmpeg__Transcoder.html#af4fff93bbb68d997bdab241dee973628">More...</a><br /></td></tr>
<tr class="separator:af4fff93bbb68d997bdab241dee973628"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a642fab7ffb7ed1822a71663df978a9e9"><td class="memItemLeft" align="right" valign="top">enum AVPixelFormat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Transcoder.html#a642fab7ffb7ed1822a71663df978a9e9">get_format</a> (AVCodecContext *input_codec_ctx, const enum AVPixelFormat *pix_fmts) const</td></tr>
<tr class="separator:a642fab7ffb7ed1822a71663df978a9e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa056b2ec3c7b93cc2522b61196d89e60"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Transcoder.html#aa056b2ec3c7b93cc2522b61196d89e60">hwdevice_ctx_create</a> (AVBufferRef **hwaccel_enc_device_ctx, AVHWDeviceType dev_type, const std::string &amp;device) const</td></tr>
<tr class="separator:aa056b2ec3c7b93cc2522b61196d89e60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adca40886322ae7af60bcb4356a4eb658"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Transcoder.html#adca40886322ae7af60bcb4356a4eb658">hwdevice_ctx_add_ref</a> (AVCodecContext *input_codec_ctx)</td></tr>
<tr class="memdesc:adca40886322ae7af60bcb4356a4eb658"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add reference to hardware device context.  <a href="classFFmpeg__Transcoder.html#adca40886322ae7af60bcb4356a4eb658">More...</a><br /></td></tr>
<tr class="separator:adca40886322ae7af60bcb4356a4eb658"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af76536b79c199e9f79fca1b658c852fc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Transcoder.html#af76536b79c199e9f79fca1b658c852fc">hwdevice_ctx_free</a> (AVBufferRef **hwaccel_device_ctx)</td></tr>
<tr class="memdesc:af76536b79c199e9f79fca1b658c852fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free (remove reference) to hardware device context.  <a href="classFFmpeg__Transcoder.html#af76536b79c199e9f79fca1b658c852fc">More...</a><br /></td></tr>
<tr class="separator:af76536b79c199e9f79fca1b658c852fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac14bb3611aadd9d86b6082a234c96004"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Transcoder.html#ac14bb3611aadd9d86b6082a234c96004">hwframe_ctx_set</a> (AVCodecContext *output_codec_ctx, AVCodecContext *input_codec_ctx, AVBufferRef *hw_device_ctx) const</td></tr>
<tr class="memdesc:ac14bb3611aadd9d86b6082a234c96004"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a reference to an existing decoder hardware frame context or allocates a new AVHWFramesContext tied to the given hardware device context if if the decoder runs in software.  <a href="classFFmpeg__Transcoder.html#ac14bb3611aadd9d86b6082a234c96004">More...</a><br /></td></tr>
<tr class="separator:ac14bb3611aadd9d86b6082a234c96004"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae99a72991154cca5a3be501cb377d248"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Transcoder.html#ae99a72991154cca5a3be501cb377d248">hwframe_copy_from_hw</a> (AVCodecContext *output_codec_ctx, <a class="el" href="classFFmpeg__Frame.html">FFmpeg_Frame</a> *sw_frame, const AVFrame *hw_frame) const</td></tr>
<tr class="separator:ae99a72991154cca5a3be501cb377d248"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac10aa97aa9f8bb5a427831c94d11c9a4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Transcoder.html#ac10aa97aa9f8bb5a427831c94d11c9a4">hwframe_copy_to_hw</a> (AVCodecContext *output_codec_ctx, <a class="el" href="classFFmpeg__Frame.html">FFmpeg_Frame</a> *hw_frame, const AVFrame *sw_frame) const</td></tr>
<tr class="separator:ac10aa97aa9f8bb5a427831c94d11c9a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1c5d95c822b31beee2815e1ef0d0aed"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Transcoder.html#ab1c5d95c822b31beee2815e1ef0d0aed">get_hw_decoder_name</a> (AVCodecID codec_id, std::string *codec_name=nullptr) const</td></tr>
<tr class="memdesc:ab1c5d95c822b31beee2815e1ef0d0aed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the hardware codec name as string. This is required, because e.g. the name for the software codec is libx264, but for hardware it is h264_vaapi under VAAPI.  <a href="classFFmpeg__Transcoder.html#ab1c5d95c822b31beee2815e1ef0d0aed">More...</a><br /></td></tr>
<tr class="separator:ab1c5d95c822b31beee2815e1ef0d0aed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a710f9fdb600a77a684f8f90ce6a37b05"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Transcoder.html#a710f9fdb600a77a684f8f90ce6a37b05">get_hw_encoder_name</a> (AVCodecID codec_id, std::string *codec_name=nullptr) const</td></tr>
<tr class="memdesc:a710f9fdb600a77a684f8f90ce6a37b05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the hardware codec name as string. This is required, because e.g. the name for the software codec is libx264, but for hardware it is h264_vaapi under VAAPI.  <a href="classFFmpeg__Transcoder.html#a710f9fdb600a77a684f8f90ce6a37b05">More...</a><br /></td></tr>
<tr class="separator:a710f9fdb600a77a684f8f90ce6a37b05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10d35e42fd531b0f96da0ad9eb5ead89"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Transcoder.html#a10d35e42fd531b0f96da0ad9eb5ead89">get_hw_vaapi_codec_name</a> (AVCodecID codec_id, std::string *codec_name) const</td></tr>
<tr class="memdesc:a10d35e42fd531b0f96da0ad9eb5ead89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine VAAPI codec name.  <a href="classFFmpeg__Transcoder.html#a10d35e42fd531b0f96da0ad9eb5ead89">More...</a><br /></td></tr>
<tr class="separator:a10d35e42fd531b0f96da0ad9eb5ead89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26f0c35e837afa3b58b39f4d0a165afe"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Transcoder.html#a26f0c35e837afa3b58b39f4d0a165afe">get_hw_mmal_decoder_name</a> (AVCodecID codec_id, std::string *codec_name) const</td></tr>
<tr class="memdesc:a26f0c35e837afa3b58b39f4d0a165afe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine MMAL decoder codec name.  <a href="classFFmpeg__Transcoder.html#a26f0c35e837afa3b58b39f4d0a165afe">More...</a><br /></td></tr>
<tr class="separator:a26f0c35e837afa3b58b39f4d0a165afe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15eb44b2f519bab0155ad1c261888827"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Transcoder.html#a15eb44b2f519bab0155ad1c261888827">get_hw_omx_encoder_name</a> (AVCodecID codec_id, std::string *codec_name) const</td></tr>
<tr class="memdesc:a15eb44b2f519bab0155ad1c261888827"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine OMX encoder codec name.  <a href="classFFmpeg__Transcoder.html#a15eb44b2f519bab0155ad1c261888827">More...</a><br /></td></tr>
<tr class="separator:a15eb44b2f519bab0155ad1c261888827"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b841205dd50e316c6506744dcca16ec"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Transcoder.html#a8b841205dd50e316c6506744dcca16ec">get_hw_v4l2m2m_encoder_name</a> (AVCodecID codec_id, std::string *codec_name) const</td></tr>
<tr class="memdesc:a8b841205dd50e316c6506744dcca16ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine video for linux encoder codec name.  <a href="classFFmpeg__Transcoder.html#a8b841205dd50e316c6506744dcca16ec">More...</a><br /></td></tr>
<tr class="separator:a8b841205dd50e316c6506744dcca16ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46ec75f8a6ce02cbd86d88e56e3b0033"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Transcoder.html#a46ec75f8a6ce02cbd86d88e56e3b0033">get_next_segment</a> (int64_t pos) const</td></tr>
<tr class="memdesc:a46ec75f8a6ce02cbd86d88e56e3b0033"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate next HLS segment from position.  <a href="classFFmpeg__Transcoder.html#a46ec75f8a6ce02cbd86d88e56e3b0033">More...</a><br /></td></tr>
<tr class="separator:a46ec75f8a6ce02cbd86d88e56e3b0033"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a794e22b656e5711f332b06b8ee5e2804"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Transcoder.html#a794e22b656e5711f332b06b8ee5e2804">goto_next_segment</a> (uint32_t next_segment) const</td></tr>
<tr class="memdesc:a794e22b656e5711f332b06b8ee5e2804"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if segment number is next designated segment.  <a href="classFFmpeg__Transcoder.html#a794e22b656e5711f332b06b8ee5e2804">More...</a><br /></td></tr>
<tr class="separator:a794e22b656e5711f332b06b8ee5e2804"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaeb89d7207eeb67eb0a6720e68544182"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Transcoder.html#aaeb89d7207eeb67eb0a6720e68544182">create_fake_wav_header</a> () const</td></tr>
<tr class="memdesc:aaeb89d7207eeb67eb0a6720e68544182"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a fake WAV header Create a fake WAV header. Inserts predicted file sizes to allow playback to start directly.  <a href="classFFmpeg__Transcoder.html#aaeb89d7207eeb67eb0a6720e68544182">More...</a><br /></td></tr>
<tr class="separator:aaeb89d7207eeb67eb0a6720e68544182"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76260344c9be1c9e617ca6aedb3e0926"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Transcoder.html#a76260344c9be1c9e617ca6aedb3e0926">create_fake_aiff_header</a> () const</td></tr>
<tr class="memdesc:a76260344c9be1c9e617ca6aedb3e0926"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a fake AIFF header Create a fake AIFF header. Inserts predicted file sizes to allow playback to start directly.  <a href="classFFmpeg__Transcoder.html#a76260344c9be1c9e617ca6aedb3e0926">More...</a><br /></td></tr>
<tr class="separator:a76260344c9be1c9e617ca6aedb3e0926"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7801f1c9b7542a8852d274af38be7256"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Transcoder.html#a7801f1c9b7542a8852d274af38be7256">read_aiff_chunk</a> (<a class="el" href="classBuffer.html">Buffer</a> *buffer, size_t *buffoffset, const char *ID, uint8_t *chunk, size_t *size) const</td></tr>
<tr class="memdesc:a7801f1c9b7542a8852d274af38be7256"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read AIFF chunk.  <a href="classFFmpeg__Transcoder.html#a7801f1c9b7542a8852d274af38be7256">More...</a><br /></td></tr>
<tr class="separator:a7801f1c9b7542a8852d274af38be7256"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78591e7d33aa33b2e748299272374d82"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Transcoder.html#a78591e7d33aa33b2e748299272374d82">is_audio_stream</a> (int stream_idx) const</td></tr>
<tr class="memdesc:a78591e7d33aa33b2e748299272374d82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check for audio stream.  <a href="classFFmpeg__Transcoder.html#a78591e7d33aa33b2e748299272374d82">More...</a><br /></td></tr>
<tr class="separator:a78591e7d33aa33b2e748299272374d82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bf4228e945ba438112c254354a0729d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Transcoder.html#a7bf4228e945ba438112c254354a0729d">is_video_stream</a> (int stream_idx) const</td></tr>
<tr class="memdesc:a7bf4228e945ba438112c254354a0729d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check for video stream.  <a href="classFFmpeg__Transcoder.html#a7bf4228e945ba438112c254354a0729d">More...</a><br /></td></tr>
<tr class="separator:a7bf4228e945ba438112c254354a0729d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f504b427d592b7f6f48e07cdc2f3924"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Transcoder.html#a7f504b427d592b7f6f48e07cdc2f3924">is_subtitle_stream</a> (int stream_idx) const</td></tr>
<tr class="memdesc:a7f504b427d592b7f6f48e07cdc2f3924"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check for subtitle stream.  <a href="classFFmpeg__Transcoder.html#a7f504b427d592b7f6f48e07cdc2f3924">More...</a><br /></td></tr>
<tr class="separator:a7f504b427d592b7f6f48e07cdc2f3924"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a457c2dd762d33080d1b70ae97a4ac5af"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classFFmpeg__Transcoder_1_1StreamRef.html">StreamRef</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Transcoder.html#a457c2dd762d33080d1b70ae97a4ac5af">get_out_subtitle_stream</a> (int stream_idx)</td></tr>
<tr class="memdesc:a457c2dd762d33080d1b70ae97a4ac5af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get subtitle stream for the stream index.  <a href="classFFmpeg__Transcoder.html#a457c2dd762d33080d1b70ae97a4ac5af">More...</a><br /></td></tr>
<tr class="separator:a457c2dd762d33080d1b70ae97a4ac5af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98bee7147e10770ac6e8b1955a7b5a43"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Transcoder.html#a98bee7147e10770ac6e8b1955a7b5a43">stream_exists</a> (int stream_idx) const</td></tr>
<tr class="memdesc:a98bee7147e10770ac6e8b1955a7b5a43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if stream exists.  <a href="classFFmpeg__Transcoder.html#a98bee7147e10770ac6e8b1955a7b5a43">More...</a><br /></td></tr>
<tr class="separator:a98bee7147e10770ac6e8b1955a7b5a43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a945a7951dae5144a56244ee1a4e427c9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Transcoder.html#a945a7951dae5144a56244ee1a4e427c9">add_stream_map</a> (int in_stream_idx, int out_stream_idx)</td></tr>
<tr class="memdesc:a945a7951dae5144a56244ee1a4e427c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add entry to input stream to output stream map.  <a href="classFFmpeg__Transcoder.html#a945a7951dae5144a56244ee1a4e427c9">More...</a><br /></td></tr>
<tr class="separator:a945a7951dae5144a56244ee1a4e427c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37e2d8c74a1111eed8951c8a7748c9fb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Transcoder.html#a37e2d8c74a1111eed8951c8a7748c9fb">map_in_to_out_stream</a> (int in_stream_idx) const</td></tr>
<tr class="memdesc:a37e2d8c74a1111eed8951c8a7748c9fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map input stream index to output stream index.  <a href="classFFmpeg__Transcoder.html#a37e2d8c74a1111eed8951c8a7748c9fb">More...</a><br /></td></tr>
<tr class="separator:a37e2d8c74a1111eed8951c8a7748c9fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96ed62701c42f8f76ce16d3c79b940cb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Transcoder.html#a96ed62701c42f8f76ce16d3c79b940cb">add_subtitle_streams</a> ()</td></tr>
<tr class="memdesc:a96ed62701c42f8f76ce16d3c79b940cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add all subtitle streams. Already existing streams are not added again.  <a href="classFFmpeg__Transcoder.html#a96ed62701c42f8f76ce16d3c79b940cb">More...</a><br /></td></tr>
<tr class="separator:a96ed62701c42f8f76ce16d3c79b940cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5fdd8b957b3f127d4b786b8a190b510"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Transcoder.html#af5fdd8b957b3f127d4b786b8a190b510">seek_frame</a> ()</td></tr>
<tr class="memdesc:af5fdd8b957b3f127d4b786b8a190b510"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frame sets only: perform seek to a certain frame.  <a href="classFFmpeg__Transcoder.html#af5fdd8b957b3f127d4b786b8a190b510">More...</a><br /></td></tr>
<tr class="separator:af5fdd8b957b3f127d4b786b8a190b510"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5fc4ed5d3550cf962f842bf4b8e3425"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Transcoder.html#ad5fc4ed5d3550cf962f842bf4b8e3425">start_new_segment</a> ()</td></tr>
<tr class="memdesc:ad5fc4ed5d3550cf962f842bf4b8e3425"><td class="mdescLeft">&#160;</td><td class="mdescRight">HLS only: start a new HLS segment.  <a href="classFFmpeg__Transcoder.html#ad5fc4ed5d3550cf962f842bf4b8e3425">More...</a><br /></td></tr>
<tr class="separator:ad5fc4ed5d3550cf962f842bf4b8e3425"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41de59102133d3c2aef9f37ccf3eb58f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Transcoder.html#a41de59102133d3c2aef9f37ccf3eb58f">add_external_subtitle_streams</a> ()</td></tr>
<tr class="memdesc:a41de59102133d3c2aef9f37ccf3eb58f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scan for external subtitle files.  <a href="classFFmpeg__Transcoder.html#a41de59102133d3c2aef9f37ccf3eb58f">More...</a><br /></td></tr>
<tr class="separator:a41de59102133d3c2aef9f37ccf3eb58f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b5c8873a0b5fe7d964de351c4b2b3fc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Transcoder.html#a5b5c8873a0b5fe7d964de351c4b2b3fc">add_external_subtitle_stream</a> (const std::string &amp;subtitle_file, const std::optional&lt; std::string &gt; &amp;language)</td></tr>
<tr class="memdesc:a5b5c8873a0b5fe7d964de351c4b2b3fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">add_external_subtitle_stream  <a href="classFFmpeg__Transcoder.html#a5b5c8873a0b5fe7d964de351c4b2b3fc">More...</a><br /></td></tr>
<tr class="separator:a5b5c8873a0b5fe7d964de351c4b2b3fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecfaf7a81d827e5bd18f5aa0cb949465"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Transcoder.html#aecfaf7a81d827e5bd18f5aa0cb949465">foreach_subtitle_file</a> (const std::string &amp;search_path, const std::regex &amp;regex, int depth, const std::function&lt; int(const std::string &amp;, const std::optional&lt; std::string &gt; &amp;)&gt; &amp;f)</td></tr>
<tr class="memdesc:aecfaf7a81d827e5bd18f5aa0cb949465"><td class="mdescLeft">&#160;</td><td class="mdescRight">foreach_subititle_file  <a href="classFFmpeg__Transcoder.html#aecfaf7a81d827e5bd18f5aa0cb949465">More...</a><br /></td></tr>
<tr class="separator:aecfaf7a81d827e5bd18f5aa0cb949465"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classFFmpeg__Base"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classFFmpeg__Base')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classFFmpeg__Base.html">FFmpeg_Base</a></td></tr>
<tr class="memitem:a7e41229fd1c6188abcb7e2e52aab95b9 inherit pro_methods_classFFmpeg__Base"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Base.html#a7e41229fd1c6188abcb7e2e52aab95b9">video_stream_setup</a> (AVCodecContext *output_codec_ctx, AVStream *output_stream, AVCodecContext *input_codec_ctx, AVRational framerate, AVPixelFormat enc_hw_pix_fmt) const</td></tr>
<tr class="memdesc:a7e41229fd1c6188abcb7e2e52aab95b9 inherit pro_methods_classFFmpeg__Base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set up a video stream.  <a href="classFFmpeg__Base.html#a7e41229fd1c6188abcb7e2e52aab95b9">More...</a><br /></td></tr>
<tr class="separator:a7e41229fd1c6188abcb7e2e52aab95b9 inherit pro_methods_classFFmpeg__Base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab32c680136647aa6f3a5ef8d5798f66 inherit pro_methods_classFFmpeg__Base"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Base.html#aab32c680136647aa6f3a5ef8d5798f66">dict_set_with_check</a> (AVDictionary **pm, const char *key, const char *value, int flags, const char *<a class="el" href="classFFmpeg__Base.html#ab286a55ddff32db33af199b60145751b">filename</a>=nullptr, bool nodelete=false) const</td></tr>
<tr class="memdesc:aab32c680136647aa6f3a5ef8d5798f66 inherit pro_methods_classFFmpeg__Base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call av_dict_set and check the result code. It displays an error message if appropriate.  <a href="classFFmpeg__Base.html#aab32c680136647aa6f3a5ef8d5798f66">More...</a><br /></td></tr>
<tr class="separator:aab32c680136647aa6f3a5ef8d5798f66 inherit pro_methods_classFFmpeg__Base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f0e69945f85bcd2a34b663c06e6bccb inherit pro_methods_classFFmpeg__Base"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Base.html#a5f0e69945f85bcd2a34b663c06e6bccb">dict_set_with_check</a> (AVDictionary **pm, const char *key, int64_t value, int flags, const char *<a class="el" href="classFFmpeg__Base.html#ab286a55ddff32db33af199b60145751b">filename</a>=nullptr, bool nodelete=false) const</td></tr>
<tr class="memdesc:a5f0e69945f85bcd2a34b663c06e6bccb inherit pro_methods_classFFmpeg__Base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call av_dict_set and check the result code. It displays an error message if appropriate.  <a href="classFFmpeg__Base.html#a5f0e69945f85bcd2a34b663c06e6bccb">More...</a><br /></td></tr>
<tr class="separator:a5f0e69945f85bcd2a34b663c06e6bccb inherit pro_methods_classFFmpeg__Base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c79e72e6c778bfc7ce3bc92d6c33cef inherit pro_methods_classFFmpeg__Base"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Base.html#a3c79e72e6c778bfc7ce3bc92d6c33cef">opt_set_with_check</a> (void *obj, const char *key, const char *value, int flags, const char *<a class="el" href="classFFmpeg__Base.html#ab286a55ddff32db33af199b60145751b">filename</a>=nullptr) const</td></tr>
<tr class="memdesc:a3c79e72e6c778bfc7ce3bc92d6c33cef inherit pro_methods_classFFmpeg__Base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call av_opt_set and check result code. Displays an error message if appropriate.  <a href="classFFmpeg__Base.html#a3c79e72e6c778bfc7ce3bc92d6c33cef">More...</a><br /></td></tr>
<tr class="separator:a3c79e72e6c778bfc7ce3bc92d6c33cef inherit pro_methods_classFFmpeg__Base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a555cacce9857bf9348b07ad8205e17 inherit pro_methods_classFFmpeg__Base"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Base.html#a6a555cacce9857bf9348b07ad8205e17">video_info</a> (bool out_file, const AVFormatContext *format_ctx, const AVStream *stream) const</td></tr>
<tr class="memdesc:a6a555cacce9857bf9348b07ad8205e17 inherit pro_methods_classFFmpeg__Base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print data from the video stream to a log.  <a href="classFFmpeg__Base.html#a6a555cacce9857bf9348b07ad8205e17">More...</a><br /></td></tr>
<tr class="separator:a6a555cacce9857bf9348b07ad8205e17 inherit pro_methods_classFFmpeg__Base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47da7eeb83c4a861c20e020846bc3dc3 inherit pro_methods_classFFmpeg__Base"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Base.html#a47da7eeb83c4a861c20e020846bc3dc3">audio_info</a> (bool out_file, const AVFormatContext *format_ctx, const AVStream *stream) const</td></tr>
<tr class="memdesc:a47da7eeb83c4a861c20e020846bc3dc3 inherit pro_methods_classFFmpeg__Base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print data from the audio stream to log.  <a href="classFFmpeg__Base.html#a47da7eeb83c4a861c20e020846bc3dc3">More...</a><br /></td></tr>
<tr class="separator:a47da7eeb83c4a861c20e020846bc3dc3 inherit pro_methods_classFFmpeg__Base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79cf025784a2cae4299177fa49244ef0 inherit pro_methods_classFFmpeg__Base"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Base.html#a79cf025784a2cae4299177fa49244ef0">subtitle_info</a> (bool out_file, const AVFormatContext *format_ctx, const AVStream *stream) const</td></tr>
<tr class="memdesc:a79cf025784a2cae4299177fa49244ef0 inherit pro_methods_classFFmpeg__Base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print data from the subtitle stream to log.  <a href="classFFmpeg__Base.html#a79cf025784a2cae4299177fa49244ef0">More...</a><br /></td></tr>
<tr class="separator:a79cf025784a2cae4299177fa49244ef0 inherit pro_methods_classFFmpeg__Base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52c3caccc7f4135b9d89e1b269b80d77 inherit pro_methods_classFFmpeg__Base"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Base.html#a52c3caccc7f4135b9d89e1b269b80d77">pts_to_frame</a> (AVStream *stream, int64_t pts) const</td></tr>
<tr class="memdesc:a52c3caccc7f4135b9d89e1b269b80d77 inherit pro_methods_classFFmpeg__Base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert PTS value to frame number.  <a href="classFFmpeg__Base.html#a52c3caccc7f4135b9d89e1b269b80d77">More...</a><br /></td></tr>
<tr class="separator:a52c3caccc7f4135b9d89e1b269b80d77 inherit pro_methods_classFFmpeg__Base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ec28fc43906be244bfd16b19202bcec inherit pro_methods_classFFmpeg__Base"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Base.html#a4ec28fc43906be244bfd16b19202bcec">frame_to_pts</a> (AVStream *stream, uint32_t frame_no) const</td></tr>
<tr class="memdesc:a4ec28fc43906be244bfd16b19202bcec inherit pro_methods_classFFmpeg__Base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert frame number to PTS value.  <a href="classFFmpeg__Base.html#a4ec28fc43906be244bfd16b19202bcec">More...</a><br /></td></tr>
<tr class="separator:a4ec28fc43906be244bfd16b19202bcec inherit pro_methods_classFFmpeg__Base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a317ac83ade3ddeed0130eadbf302afd6 inherit pro_methods_classFFmpeg__Base"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Base.html#a317ac83ade3ddeed0130eadbf302afd6">get_channels</a> (const AVCodecParameters *codecpar) const</td></tr>
<tr class="memdesc:a317ac83ade3ddeed0130eadbf302afd6 inherit pro_methods_classFFmpeg__Base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of channels from AVCodecParameters.  <a href="classFFmpeg__Base.html#a317ac83ade3ddeed0130eadbf302afd6">More...</a><br /></td></tr>
<tr class="separator:a317ac83ade3ddeed0130eadbf302afd6 inherit pro_methods_classFFmpeg__Base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf804580f723a75abbf4696f5da22126 inherit pro_methods_classFFmpeg__Base"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Base.html#aaf804580f723a75abbf4696f5da22126">set_channels</a> (AVCodecParameters *codecpar_out, const AVCodecParameters *codecpar_in) const</td></tr>
<tr class="memdesc:aaf804580f723a75abbf4696f5da22126 inherit pro_methods_classFFmpeg__Base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the number of channels from AVCodecParameters.  <a href="classFFmpeg__Base.html#aaf804580f723a75abbf4696f5da22126">More...</a><br /></td></tr>
<tr class="separator:aaf804580f723a75abbf4696f5da22126 inherit pro_methods_classFFmpeg__Base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb8069543f9809849eb6b3980e031a45 inherit pro_methods_classFFmpeg__Base"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Base.html#aeb8069543f9809849eb6b3980e031a45">get_channels</a> (const AVCodecContext *codec_ctx) const</td></tr>
<tr class="memdesc:aeb8069543f9809849eb6b3980e031a45 inherit pro_methods_classFFmpeg__Base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of channels from AVCodecContext.  <a href="classFFmpeg__Base.html#aeb8069543f9809849eb6b3980e031a45">More...</a><br /></td></tr>
<tr class="separator:aeb8069543f9809849eb6b3980e031a45 inherit pro_methods_classFFmpeg__Base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a8e88c3a5af797ca5702e3cb1f006f3 inherit pro_methods_classFFmpeg__Base"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Base.html#a9a8e88c3a5af797ca5702e3cb1f006f3">set_channels</a> (AVCodecContext *codec_ctx_out, const AVCodecContext *codec_ctx_in) const</td></tr>
<tr class="memdesc:a9a8e88c3a5af797ca5702e3cb1f006f3 inherit pro_methods_classFFmpeg__Base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the number of channels from AVCodecContext.  <a href="classFFmpeg__Base.html#a9a8e88c3a5af797ca5702e3cb1f006f3">More...</a><br /></td></tr>
<tr class="separator:a9a8e88c3a5af797ca5702e3cb1f006f3 inherit pro_methods_classFFmpeg__Base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3ff00e8fecbd060531ed064ab149cee inherit pro_methods_classFFmpeg__Base"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Base.html#ab3ff00e8fecbd060531ed064ab149cee">set_channels</a> (AVCodecContext *codec_ctx_out, int channels) const</td></tr>
<tr class="memdesc:ab3ff00e8fecbd060531ed064ab149cee inherit pro_methods_classFFmpeg__Base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the number of channels from AVCodecContext.  <a href="classFFmpeg__Base.html#ab3ff00e8fecbd060531ed064ab149cee">More...</a><br /></td></tr>
<tr class="separator:ab3ff00e8fecbd060531ed064ab149cee inherit pro_methods_classFFmpeg__Base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4514f4abab7003d7f33f37874d35fada inherit pro_methods_classFFmpeg__Base"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Base.html#a4514f4abab7003d7f33f37874d35fada">get_script_info</a> (AVCodecContext *codec_ctx, int play_res_x, int play_res_y, const char *font, int font_size, int primary_color, int secondary_color, int outline_color, int back_color, int bold, int italic, int underline, int border_style, int alignment) const</td></tr>
<tr class="memdesc:a4514f4abab7003d7f33f37874d35fada inherit pro_methods_classFFmpeg__Base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a suitable AVCodecContext.subtitle_header for SUBTITLE_ASS. Nicked from the FFmpeg API function ff_ass_subtitle_header_full(). :)  <a href="classFFmpeg__Base.html#a4514f4abab7003d7f33f37874d35fada">More...</a><br /></td></tr>
<tr class="separator:a4514f4abab7003d7f33f37874d35fada inherit pro_methods_classFFmpeg__Base"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-static-methods"></a>
Static Protected Member Functions</h2></td></tr>
<tr class="memitem:a203942f9d2bb0d8dbcb547624fe6c728"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Transcoder.html#a203942f9d2bb0d8dbcb547624fe6c728">input_read</a> (void *opaque, unsigned char *data, int size)</td></tr>
<tr class="memdesc:a203942f9d2bb0d8dbcb547624fe6c728"><td class="mdescLeft">&#160;</td><td class="mdescRight">Custom read function for FFmpeg.  <a href="classFFmpeg__Transcoder.html#a203942f9d2bb0d8dbcb547624fe6c728">More...</a><br /></td></tr>
<tr class="separator:a203942f9d2bb0d8dbcb547624fe6c728"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3110f05414808742ea6d579191982bf5"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Transcoder.html#a3110f05414808742ea6d579191982bf5">output_write</a> (void *opaque, unsigned char *data, int size)</td></tr>
<tr class="memdesc:a3110f05414808742ea6d579191982bf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Custom write function for FFmpeg.  <a href="classFFmpeg__Transcoder.html#a3110f05414808742ea6d579191982bf5">More...</a><br /></td></tr>
<tr class="separator:a3110f05414808742ea6d579191982bf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b6c0aabe9bdc1b75aacb60f180c55fa"><td class="memItemLeft" align="right" valign="top">static int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Transcoder.html#a8b6c0aabe9bdc1b75aacb60f180c55fa">seek</a> (void *opaque, int64_t offset, int whence)</td></tr>
<tr class="memdesc:a8b6c0aabe9bdc1b75aacb60f180c55fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Custom seek function for FFmpeg.  <a href="classFFmpeg__Transcoder.html#a8b6c0aabe9bdc1b75aacb60f180c55fa">More...</a><br /></td></tr>
<tr class="separator:a8b6c0aabe9bdc1b75aacb60f180c55fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad80dbd5504903dcb81db2e617929601a"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="ffmpeg__utils_8h.html#a17468d10f0c67a4ee7b38aab09d9e096">BITRATE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Transcoder.html#ad80dbd5504903dcb81db2e617929601a">get_prores_bitrate</a> (int width, int height, const AVRational &amp;framerate, bool interleaved, int profile)</td></tr>
<tr class="memdesc:ad80dbd5504903dcb81db2e617929601a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the appropriate bitrate for a ProRes file given several parameters.  <a href="classFFmpeg__Transcoder.html#ad80dbd5504903dcb81db2e617929601a">More...</a><br /></td></tr>
<tr class="separator:ad80dbd5504903dcb81db2e617929601a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54554e2e1177c1c1fc185c7c2e7f9d78"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Transcoder.html#a54554e2e1177c1c1fc185c7c2e7f9d78">get_output_sample_rate</a> (int input_sample_rate, int max_sample_rate, int *output_sample_rate=nullptr)</td></tr>
<tr class="memdesc:a54554e2e1177c1c1fc185c7c2e7f9d78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate output sample rate based on user option.  <a href="classFFmpeg__Transcoder.html#a54554e2e1177c1c1fc185c7c2e7f9d78">More...</a><br /></td></tr>
<tr class="separator:a54554e2e1177c1c1fc185c7c2e7f9d78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af26399e6b5c677b4d8eb0072dafcd05b"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Transcoder.html#af26399e6b5c677b4d8eb0072dafcd05b">get_output_bit_rate</a> (<a class="el" href="ffmpeg__utils_8h.html#a17468d10f0c67a4ee7b38aab09d9e096">BITRATE</a> input_bit_rate, <a class="el" href="ffmpeg__utils_8h.html#a17468d10f0c67a4ee7b38aab09d9e096">BITRATE</a> max_bit_rate, <a class="el" href="ffmpeg__utils_8h.html#a17468d10f0c67a4ee7b38aab09d9e096">BITRATE</a> *output_bit_rate=nullptr)</td></tr>
<tr class="memdesc:af26399e6b5c677b4d8eb0072dafcd05b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate output bit rate based on user option.  <a href="classFFmpeg__Transcoder.html#af26399e6b5c677b4d8eb0072dafcd05b">More...</a><br /></td></tr>
<tr class="separator:af26399e6b5c677b4d8eb0072dafcd05b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9b79354a3f5124f478e1310ea77bfdc"><td class="memItemLeft" align="right" valign="top">static enum AVPixelFormat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Transcoder.html#ac9b79354a3f5124f478e1310ea77bfdc">get_format_static</a> (AVCodecContext *input_codec_ctx, const enum AVPixelFormat *pix_fmts)</td></tr>
<tr class="separator:ac9b79354a3f5124f478e1310ea77bfdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cdfa54663debd74d4195d4d3dac431f"><td class="memItemLeft" align="right" valign="top">static AVPixelFormat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Transcoder.html#a4cdfa54663debd74d4195d4d3dac431f">find_sw_fmt_by_hw_type</a> (AVHWDeviceType type)</td></tr>
<tr class="memdesc:a4cdfa54663debd74d4195d4d3dac431f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the software pixel format for the given hardware acceleration.  <a href="classFFmpeg__Transcoder.html#a4cdfa54663debd74d4195d4d3dac431f">More...</a><br /></td></tr>
<tr class="separator:a4cdfa54663debd74d4195d4d3dac431f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4515e5c135b1ca3fd7fab1d8bc0d943"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Transcoder.html#aa4515e5c135b1ca3fd7fab1d8bc0d943">read_packet</a> (void *opaque, uint8_t *buf, int buf_size)</td></tr>
<tr class="memdesc:aa4515e5c135b1ca3fd7fab1d8bc0d943"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classFFmpeg__Transcoder.html#aa4515e5c135b1ca3fd7fab1d8bc0d943" title="FFmpeg_Transcoder::read_packet.">FFmpeg_Transcoder::read_packet</a>.  <a href="classFFmpeg__Transcoder.html#aa4515e5c135b1ca3fd7fab1d8bc0d943">More...</a><br /></td></tr>
<tr class="separator:aa4515e5c135b1ca3fd7fab1d8bc0d943"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_static_methods_classFFmpeg__Base"><td colspan="2" onclick="javascript:toggleInherit('pro_static_methods_classFFmpeg__Base')"><img src="closed.png" alt="-"/>&#160;Static Protected Member Functions inherited from <a class="el" href="classFFmpeg__Base.html">FFmpeg_Base</a></td></tr>
<tr class="memitem:aa4d307fd751373bc36ac17c68e7809a3 inherit pro_static_methods_classFFmpeg__Base"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Base.html#aa4d307fd751373bc36ac17c68e7809a3">get_pix_fmt_name</a> (AVPixelFormat pix_fmt)</td></tr>
<tr class="memdesc:aa4d307fd751373bc36ac17c68e7809a3 inherit pro_static_methods_classFFmpeg__Base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls av_get_pix_fmt_name and returns a std::string with the pix format name.  <a href="classFFmpeg__Base.html#aa4d307fd751373bc36ac17c68e7809a3">More...</a><br /></td></tr>
<tr class="separator:aa4d307fd751373bc36ac17c68e7809a3 inherit pro_static_methods_classFFmpeg__Base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00c209210bb481426ccbd8708a3274df inherit pro_static_methods_classFFmpeg__Base"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Base.html#a00c209210bb481426ccbd8708a3274df">get_sample_fmt_name</a> (AVSampleFormat sample_fmt)</td></tr>
<tr class="memdesc:a00c209210bb481426ccbd8708a3274df inherit pro_static_methods_classFFmpeg__Base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls av_get_sample_fmt_name and returns a std::string with the format name.  <a href="classFFmpeg__Base.html#a00c209210bb481426ccbd8708a3274df">More...</a><br /></td></tr>
<tr class="separator:a00c209210bb481426ccbd8708a3274df inherit pro_static_methods_classFFmpeg__Base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e78a503003ed40e04295068029b0757 inherit pro_static_methods_classFFmpeg__Base"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Base.html#a8e78a503003ed40e04295068029b0757">get_channel_layout_name</a> (const AVChannelLayout *ch_layout)</td></tr>
<tr class="memdesc:a8e78a503003ed40e04295068029b0757 inherit pro_static_methods_classFFmpeg__Base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls av_channel_layout_describe and returns a std::string with the channel layout.  <a href="classFFmpeg__Base.html#a8e78a503003ed40e04295068029b0757">More...</a><br /></td></tr>
<tr class="separator:a8e78a503003ed40e04295068029b0757 inherit pro_static_methods_classFFmpeg__Base"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a7c0fb69e623347e2747f585e3c4a78be"><td class="memItemLeft" align="right" valign="top"><a id="a7c0fb69e623347e2747f585e3c4a78be"></a>
<a class="el" href="classFileIO.html">FileIO</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Transcoder.html#a7c0fb69e623347e2747f585e3c4a78be">m_fileio</a></td></tr>
<tr class="memdesc:a7c0fb69e623347e2747f585e3c4a78be"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classFileIO.html" title="Base class for I/O.">FileIO</a> object of input file. <br /></td></tr>
<tr class="separator:a7c0fb69e623347e2747f585e3c4a78be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4720d3089b1d0c94963af4efeb207221"><td class="memItemLeft" align="right" valign="top"><a id="a4720d3089b1d0c94963af4efeb207221"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Transcoder.html#a4720d3089b1d0c94963af4efeb207221">m_close_fileio</a></td></tr>
<tr class="memdesc:a4720d3089b1d0c94963af4efeb207221"><td class="mdescLeft">&#160;</td><td class="mdescRight">If we own the <a class="el" href="classFileIO.html" title="Base class for I/O.">FileIO</a> object, we may close it in the end. <br /></td></tr>
<tr class="separator:a4720d3089b1d0c94963af4efeb207221"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae54684db6371686bcac4d4da95b8966f"><td class="memItemLeft" align="right" valign="top"><a id="ae54684db6371686bcac4d4da95b8966f"></a>
time_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Transcoder.html#ae54684db6371686bcac4d4da95b8966f">m_mtime</a></td></tr>
<tr class="memdesc:ae54684db6371686bcac4d4da95b8966f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modified time of input file. <br /></td></tr>
<tr class="separator:ae54684db6371686bcac4d4da95b8966f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc5ddeede97b604daccc02bcb73d81c4"><td class="memItemLeft" align="right" valign="top"><a id="adc5ddeede97b604daccc02bcb73d81c4"></a>
std::recursive_mutex&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Transcoder.html#adc5ddeede97b604daccc02bcb73d81c4">m_seek_to_fifo_mutex</a></td></tr>
<tr class="memdesc:adc5ddeede97b604daccc02bcb73d81c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access mutex for seek FIFO. <br /></td></tr>
<tr class="separator:adc5ddeede97b604daccc02bcb73d81c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46ae4d683654565e87c402f0785f176c"><td class="memItemLeft" align="right" valign="top"><a id="a46ae4d683654565e87c402f0785f176c"></a>
std::queue&lt; uint32_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Transcoder.html#a46ae4d683654565e87c402f0785f176c">m_seek_to_fifo</a></td></tr>
<tr class="memdesc:a46ae4d683654565e87c402f0785f176c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stack of seek requests. Will be processed FIFO. <br /></td></tr>
<tr class="separator:a46ae4d683654565e87c402f0785f176c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab394718b9aa5e42e3526aea45a84abc0"><td class="memItemLeft" align="right" valign="top"><a id="ab394718b9aa5e42e3526aea45a84abc0"></a>
volatile uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Transcoder.html#ab394718b9aa5e42e3526aea45a84abc0">m_last_seek_frame_no</a></td></tr>
<tr class="memdesc:ab394718b9aa5e42e3526aea45a84abc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">If not 0, this is the last frame that we seeked to. Video sources only. <br /></td></tr>
<tr class="separator:ab394718b9aa5e42e3526aea45a84abc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a806eeb17768ba75d8bb1257d18ec0ae7"><td class="memItemLeft" align="right" valign="top"><a id="a806eeb17768ba75d8bb1257d18ec0ae7"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Transcoder.html#a806eeb17768ba75d8bb1257d18ec0ae7">m_have_seeked</a></td></tr>
<tr class="memdesc:a806eeb17768ba75d8bb1257d18ec0ae7"><td class="mdescLeft">&#160;</td><td class="mdescRight">After seek operations this is set to make sure the trancoding result is marked RESULTCODE_INCOMPLETE to start transcoding over next access to fill the gaps. <br /></td></tr>
<tr class="separator:a806eeb17768ba75d8bb1257d18ec0ae7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69872e85cf506c638825d0d8f72be4e7"><td class="memItemLeft" align="right" valign="top"><a id="a69872e85cf506c638825d0d8f72be4e7"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Transcoder.html#a69872e85cf506c638825d0d8f72be4e7">m_skip_next_frame</a></td></tr>
<tr class="memdesc:a69872e85cf506c638825d0d8f72be4e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">After seek, skip next video frame. <br /></td></tr>
<tr class="separator:a69872e85cf506c638825d0d8f72be4e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c65603ded0869762b160722fb700b4e"><td class="memItemLeft" align="right" valign="top"><a id="a8c65603ded0869762b160722fb700b4e"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Transcoder.html#a8c65603ded0869762b160722fb700b4e">m_is_video</a></td></tr>
<tr class="memdesc:a8c65603ded0869762b160722fb700b4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">true if input is a video file <br /></td></tr>
<tr class="separator:a8c65603ded0869762b160722fb700b4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a790c0096a65de79d85029d24949cad01"><td class="memItemLeft" align="right" valign="top"><a id="a790c0096a65de79d85029d24949cad01"></a>
<a class="el" href="classFFmpeg__Transcoder.html#a2465e20c57b92f3fc045031a94707544">MULTIFRAME_MAP</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Transcoder.html#a790c0096a65de79d85029d24949cad01">m_frame_map</a></td></tr>
<tr class="memdesc:a790c0096a65de79d85029d24949cad01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Audio/video/subtitle frame map. <br /></td></tr>
<tr class="separator:a790c0096a65de79d85029d24949cad01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2954691fc1bc984651358f7982e9e13a"><td class="memItemLeft" align="right" valign="top"><a id="a2954691fc1bc984651358f7982e9e13a"></a>
AVSampleFormat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Transcoder.html#a2954691fc1bc984651358f7982e9e13a">m_cur_sample_fmt</a></td></tr>
<tr class="memdesc:a2954691fc1bc984651358f7982e9e13a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Currently selected audio sample format. <br /></td></tr>
<tr class="separator:a2954691fc1bc984651358f7982e9e13a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addad8b340419854388f2d6d7916473b3"><td class="memItemLeft" align="right" valign="top"><a id="addad8b340419854388f2d6d7916473b3"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Transcoder.html#addad8b340419854388f2d6d7916473b3">m_cur_sample_rate</a></td></tr>
<tr class="memdesc:addad8b340419854388f2d6d7916473b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Currently selected audio sample rate. <br /></td></tr>
<tr class="separator:addad8b340419854388f2d6d7916473b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbd43e9b100d97acadbe96aeeb77c829"><td class="memItemLeft" align="right" valign="top"><a id="abbd43e9b100d97acadbe96aeeb77c829"></a>
AVChannelLayout&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Transcoder.html#abbd43e9b100d97acadbe96aeeb77c829">m_cur_ch_layout</a></td></tr>
<tr class="memdesc:abbd43e9b100d97acadbe96aeeb77c829"><td class="mdescLeft">&#160;</td><td class="mdescRight">Currently selected audio channel layout. <br /></td></tr>
<tr class="separator:abbd43e9b100d97acadbe96aeeb77c829"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf06c80e0a45c275e6a64484a431d287"><td class="memItemLeft" align="right" valign="top"><a id="adf06c80e0a45c275e6a64484a431d287"></a>
SwrContext *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Transcoder.html#adf06c80e0a45c275e6a64484a431d287">m_audio_resample_ctx</a></td></tr>
<tr class="memdesc:adf06c80e0a45c275e6a64484a431d287"><td class="mdescLeft">&#160;</td><td class="mdescRight">SwResample context for audio resampling. <br /></td></tr>
<tr class="separator:adf06c80e0a45c275e6a64484a431d287"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cdaccd3dc3b2e51a2115b1a47974545"><td class="memItemLeft" align="right" valign="top"><a id="a1cdaccd3dc3b2e51a2115b1a47974545"></a>
AVAudioFifo *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Transcoder.html#a1cdaccd3dc3b2e51a2115b1a47974545">m_audio_fifo</a></td></tr>
<tr class="memdesc:a1cdaccd3dc3b2e51a2115b1a47974545"><td class="mdescLeft">&#160;</td><td class="mdescRight">Audio sample FIFO. <br /></td></tr>
<tr class="separator:a1cdaccd3dc3b2e51a2115b1a47974545"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae513d78484ad947b861335523ef24b77"><td class="memItemLeft" align="right" valign="top"><a id="ae513d78484ad947b861335523ef24b77"></a>
SwsContext *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Transcoder.html#ae513d78484ad947b861335523ef24b77">m_sws_ctx</a></td></tr>
<tr class="memdesc:ae513d78484ad947b861335523ef24b77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Context for video filtering. <br /></td></tr>
<tr class="separator:ae513d78484ad947b861335523ef24b77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9143e21037cb6fcf5b1eca176adbcf0"><td class="memItemLeft" align="right" valign="top"><a id="aa9143e21037cb6fcf5b1eca176adbcf0"></a>
AVFilterContext *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Transcoder.html#aa9143e21037cb6fcf5b1eca176adbcf0">m_buffer_sink_context</a></td></tr>
<tr class="memdesc:aa9143e21037cb6fcf5b1eca176adbcf0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Video filter sink context. <br /></td></tr>
<tr class="separator:aa9143e21037cb6fcf5b1eca176adbcf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6017b220711e0e56a994cbcbb538eb0"><td class="memItemLeft" align="right" valign="top"><a id="ad6017b220711e0e56a994cbcbb538eb0"></a>
AVFilterContext *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Transcoder.html#ad6017b220711e0e56a994cbcbb538eb0">m_buffer_source_context</a></td></tr>
<tr class="memdesc:ad6017b220711e0e56a994cbcbb538eb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Video filter source context. <br /></td></tr>
<tr class="separator:ad6017b220711e0e56a994cbcbb538eb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6064b62f8cf785372fe5dfe8aff20de7"><td class="memItemLeft" align="right" valign="top"><a id="a6064b62f8cf785372fe5dfe8aff20de7"></a>
AVFilterGraph *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Transcoder.html#a6064b62f8cf785372fe5dfe8aff20de7">m_filter_graph</a></td></tr>
<tr class="memdesc:a6064b62f8cf785372fe5dfe8aff20de7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Video filter graph. <br /></td></tr>
<tr class="separator:a6064b62f8cf785372fe5dfe8aff20de7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab22152562557b61458cca53e1943c2cd"><td class="memItemLeft" align="right" valign="top"><a id="ab22152562557b61458cca53e1943c2cd"></a>
int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Transcoder.html#ab22152562557b61458cca53e1943c2cd">m_pts</a></td></tr>
<tr class="memdesc:ab22152562557b61458cca53e1943c2cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generated PTS. <br /></td></tr>
<tr class="separator:ab22152562557b61458cca53e1943c2cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fe14d57480ad26cb8901d342e87fbd8"><td class="memItemLeft" align="right" valign="top"><a id="a7fe14d57480ad26cb8901d342e87fbd8"></a>
int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Transcoder.html#a7fe14d57480ad26cb8901d342e87fbd8">m_pos</a></td></tr>
<tr class="memdesc:a7fe14d57480ad26cb8901d342e87fbd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generated position. <br /></td></tr>
<tr class="separator:a7fe14d57480ad26cb8901d342e87fbd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45971be90f733500bcabfe4161ad2ce1"><td class="memItemLeft" align="right" valign="top"><a id="a45971be90f733500bcabfe4161ad2ce1"></a>
<a class="el" href="structFFmpeg__Transcoder_1_1INPUTFILE.html">INPUTFILE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Transcoder.html#a45971be90f733500bcabfe4161ad2ce1">m_in</a></td></tr>
<tr class="memdesc:a45971be90f733500bcabfe4161ad2ce1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Input file information. <br /></td></tr>
<tr class="separator:a45971be90f733500bcabfe4161ad2ce1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3a56a7a3917f977644d52c9adac75a4"><td class="memItemLeft" align="right" valign="top"><a id="ab3a56a7a3917f977644d52c9adac75a4"></a>
<a class="el" href="structFFmpeg__Transcoder_1_1OUTPUTFILE.html">OUTPUTFILE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Transcoder.html#ab3a56a7a3917f977644d52c9adac75a4">m_out</a></td></tr>
<tr class="memdesc:ab3a56a7a3917f977644d52c9adac75a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output file information. <br /></td></tr>
<tr class="separator:ab3a56a7a3917f977644d52c9adac75a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c09c98e8f55ca898f7e1ceed7f2eaf3"><td class="memItemLeft" align="right" valign="top"><a id="a9c09c98e8f55ca898f7e1ceed7f2eaf3"></a>
<a class="el" href="classFFmpeg__Transcoder.html#a5845955828e107d3e3e36b6de8354adb">STREAM_MAP</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Transcoder.html#a9c09c98e8f55ca898f7e1ceed7f2eaf3">m_stream_map</a></td></tr>
<tr class="memdesc:a9c09c98e8f55ca898f7e1ceed7f2eaf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Input stream to output stream map. <br /></td></tr>
<tr class="separator:a9c09c98e8f55ca898f7e1ceed7f2eaf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02d667bab3503452ff3f57ed556a6a18"><td class="memItemLeft" align="right" valign="top"><a id="a02d667bab3503452ff3f57ed556a6a18"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Transcoder.html#a02d667bab3503452ff3f57ed556a6a18">m_current_segment</a></td></tr>
<tr class="memdesc:a02d667bab3503452ff3f57ed556a6a18"><td class="mdescLeft">&#160;</td><td class="mdescRight">HLS only: Segment file number currently being encoded. <br /></td></tr>
<tr class="separator:a02d667bab3503452ff3f57ed556a6a18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f6282b366c672de0fb9799da87872e8"><td class="memItemLeft" align="right" valign="top"><a id="a4f6282b366c672de0fb9799da87872e8"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Transcoder.html#a4f6282b366c672de0fb9799da87872e8">m_insert_keyframe</a></td></tr>
<tr class="memdesc:a4f6282b366c672de0fb9799da87872e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">HLS only: Allow insertion of 1 keyframe. <br /></td></tr>
<tr class="separator:a4f6282b366c672de0fb9799da87872e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0303945dd6ff9ef43b60a9d29b23d63"><td class="memItemLeft" align="right" valign="top"><a id="ae0303945dd6ff9ef43b60a9d29b23d63"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Transcoder.html#ae0303945dd6ff9ef43b60a9d29b23d63">m_copy_audio</a></td></tr>
<tr class="memdesc:ae0303945dd6ff9ef43b60a9d29b23d63"><td class="mdescLeft">&#160;</td><td class="mdescRight">If true, copy audio stream from source to target (just remux, no recode). <br /></td></tr>
<tr class="separator:ae0303945dd6ff9ef43b60a9d29b23d63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a469b451230d3946853a68d12a77d8e53"><td class="memItemLeft" align="right" valign="top"><a id="a469b451230d3946853a68d12a77d8e53"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Transcoder.html#a469b451230d3946853a68d12a77d8e53">m_copy_video</a></td></tr>
<tr class="memdesc:a469b451230d3946853a68d12a77d8e53"><td class="mdescLeft">&#160;</td><td class="mdescRight">If true, copy video stream from source to target (just remux, no recode). <br /></td></tr>
<tr class="separator:a469b451230d3946853a68d12a77d8e53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a335cf32f758dbcdca62e05140640c464"><td class="memItemLeft" align="right" valign="top"><a id="a335cf32f758dbcdca62e05140640c464"></a>
const <a class="el" href="classFFmpegfs__Format.html">FFmpegfs_Format</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Transcoder.html#a335cf32f758dbcdca62e05140640c464">m_current_format</a></td></tr>
<tr class="memdesc:a335cf32f758dbcdca62e05140640c464"><td class="mdescLeft">&#160;</td><td class="mdescRight">Currently used output format(s) <br /></td></tr>
<tr class="separator:a335cf32f758dbcdca62e05140640c464"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6637e9393b6b64345759f98859501b56"><td class="memItemLeft" align="right" valign="top"><a id="a6637e9393b6b64345759f98859501b56"></a>
<a class="el" href="classBuffer.html">Buffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Transcoder.html#a6637e9393b6b64345759f98859501b56">m_buffer</a></td></tr>
<tr class="memdesc:a6637e9393b6b64345759f98859501b56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to cache buffer object. <br /></td></tr>
<tr class="separator:a6637e9393b6b64345759f98859501b56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a643f19a1eeefb6f2f19e8f1a1ffa8cdb"><td class="memItemLeft" align="right" valign="top"><a id="a643f19a1eeefb6f2f19e8f1a1ffa8cdb"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Transcoder.html#a643f19a1eeefb6f2f19e8f1a1ffa8cdb">m_reset_pts</a></td></tr>
<tr class="memdesc:a643f19a1eeefb6f2f19e8f1a1ffa8cdb"><td class="mdescLeft">&#160;</td><td class="mdescRight">We have to reset audio/video pts to the new position. <br /></td></tr>
<tr class="separator:a643f19a1eeefb6f2f19e8f1a1ffa8cdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3c4d9cff7c70914b9d2ec7e21d9387c"><td class="memItemLeft" align="right" valign="top"><a id="aa3c4d9cff7c70914b9d2ec7e21d9387c"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Transcoder.html#aa3c4d9cff7c70914b9d2ec7e21d9387c">m_fake_frame_no</a></td></tr>
<tr class="memdesc:aa3c4d9cff7c70914b9d2ec7e21d9387c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The MJEPG codec requires monotonically growing PTS values so we fake some to avoid them going backwards after seeks. <br /></td></tr>
<tr class="separator:aa3c4d9cff7c70914b9d2ec7e21d9387c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7115edb77371737162dcfc823f37d90"><td class="memItemLeft" align="right" valign="top"><a id="af7115edb77371737162dcfc823f37d90"></a>
<a class="el" href="classFFmpeg__Transcoder.html#a069bfc8760dc23399d2f9a044aeacf51">HWACCELMODE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Transcoder.html#af7115edb77371737162dcfc823f37d90">m_hwaccel_enc_mode</a></td></tr>
<tr class="memdesc:af7115edb77371737162dcfc823f37d90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Current hardware acceleration mode for encoder. <br /></td></tr>
<tr class="separator:af7115edb77371737162dcfc823f37d90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bdfb83da0bbffa72b87361f1562001e"><td class="memItemLeft" align="right" valign="top"><a id="a9bdfb83da0bbffa72b87361f1562001e"></a>
<a class="el" href="classFFmpeg__Transcoder.html#a069bfc8760dc23399d2f9a044aeacf51">HWACCELMODE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Transcoder.html#a9bdfb83da0bbffa72b87361f1562001e">m_hwaccel_dec_mode</a></td></tr>
<tr class="memdesc:a9bdfb83da0bbffa72b87361f1562001e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Current hardware acceleration mode for decoder. <br /></td></tr>
<tr class="separator:a9bdfb83da0bbffa72b87361f1562001e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a8836b640ed92f7d04195f89f9e87da"><td class="memItemLeft" align="right" valign="top"><a id="a0a8836b640ed92f7d04195f89f9e87da"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Transcoder.html#a0a8836b640ed92f7d04195f89f9e87da">m_hwaccel_enable_enc_buffering</a></td></tr>
<tr class="memdesc:a0a8836b640ed92f7d04195f89f9e87da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable hardware acceleration frame buffers for encoder. <br /></td></tr>
<tr class="separator:a0a8836b640ed92f7d04195f89f9e87da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a289a7bd37eb00630df77327041cbd16b"><td class="memItemLeft" align="right" valign="top"><a id="a289a7bd37eb00630df77327041cbd16b"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Transcoder.html#a289a7bd37eb00630df77327041cbd16b">m_hwaccel_enable_dec_buffering</a></td></tr>
<tr class="memdesc:a289a7bd37eb00630df77327041cbd16b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable hardware acceleration frame buffers for decoder. <br /></td></tr>
<tr class="separator:a289a7bd37eb00630df77327041cbd16b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90234492c1cc97bbc9ad1af4e48cf23f"><td class="memItemLeft" align="right" valign="top"><a id="a90234492c1cc97bbc9ad1af4e48cf23f"></a>
AVBufferRef *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Transcoder.html#a90234492c1cc97bbc9ad1af4e48cf23f">m_hwaccel_enc_device_ctx</a></td></tr>
<tr class="memdesc:a90234492c1cc97bbc9ad1af4e48cf23f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hardware acceleration device context for encoder. <br /></td></tr>
<tr class="separator:a90234492c1cc97bbc9ad1af4e48cf23f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6569fa4324fed806fd48d85f0226ac50"><td class="memItemLeft" align="right" valign="top"><a id="a6569fa4324fed806fd48d85f0226ac50"></a>
AVBufferRef *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Transcoder.html#a6569fa4324fed806fd48d85f0226ac50">m_hwaccel_dec_device_ctx</a></td></tr>
<tr class="memdesc:a6569fa4324fed806fd48d85f0226ac50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hardware acceleration device context for decoder. <br /></td></tr>
<tr class="separator:a6569fa4324fed806fd48d85f0226ac50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2f4ca0a01e676765025116432910ae6"><td class="memItemLeft" align="right" valign="top"><a id="ab2f4ca0a01e676765025116432910ae6"></a>
AVPixelFormat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Transcoder.html#ab2f4ca0a01e676765025116432910ae6">m_enc_hw_pix_fmt</a></td></tr>
<tr class="memdesc:ab2f4ca0a01e676765025116432910ae6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Requested encoder hardware pixel format. <br /></td></tr>
<tr class="separator:ab2f4ca0a01e676765025116432910ae6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab684ddc91f36d5ab375b029bf8395178"><td class="memItemLeft" align="right" valign="top"><a id="ab684ddc91f36d5ab375b029bf8395178"></a>
AVPixelFormat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Transcoder.html#ab684ddc91f36d5ab375b029bf8395178">m_dec_hw_pix_fmt</a></td></tr>
<tr class="memdesc:ab684ddc91f36d5ab375b029bf8395178"><td class="mdescLeft">&#160;</td><td class="mdescRight">Requested decoder hardware pixel format. <br /></td></tr>
<tr class="separator:ab684ddc91f36d5ab375b029bf8395178"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af14161741a8e012b883cf5ef9f453ec5"><td class="memItemLeft" align="right" valign="top"><a id="af14161741a8e012b883cf5ef9f453ec5"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Transcoder.html#af14161741a8e012b883cf5ef9f453ec5">m_active_stream_msk</a></td></tr>
<tr class="memdesc:af14161741a8e012b883cf5ef9f453ec5"><td class="mdescLeft">&#160;</td><td class="mdescRight">HLS: Currently active streams bit mask. Set FFMPEGFS_AUDIO and/or FFMPEGFS_VIDEO. <br /></td></tr>
<tr class="separator:af14161741a8e012b883cf5ef9f453ec5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a469fa7c7952d828feec4ed337cd2babf"><td class="memItemLeft" align="right" valign="top"><a id="a469fa7c7952d828feec4ed337cd2babf"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Transcoder.html#a469fa7c7952d828feec4ed337cd2babf">m_inhibit_stream_msk</a></td></tr>
<tr class="memdesc:a469fa7c7952d828feec4ed337cd2babf"><td class="mdescLeft">&#160;</td><td class="mdescRight">HLS: Currently inhibited streams bit mask. Packets temporarly go to m_hls_packet_fifo and will be prepended to next segment. Set FFMPEGFS_AUDIO and/or FFMPEGFS_VIDEO. <br /></td></tr>
<tr class="separator:a469fa7c7952d828feec4ed337cd2babf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b39ca2c75cd848dce0674a20fdcdd86"><td class="memItemLeft" align="right" valign="top"><a id="a4b39ca2c75cd848dce0674a20fdcdd86"></a>
std::queue&lt; AVPacket * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Transcoder.html#a4b39ca2c75cd848dce0674a20fdcdd86">m_hls_packet_fifo</a></td></tr>
<tr class="memdesc:a4b39ca2c75cd848dce0674a20fdcdd86"><td class="mdescLeft">&#160;</td><td class="mdescRight">HLS packet FIFO. <br /></td></tr>
<tr class="separator:a4b39ca2c75cd848dce0674a20fdcdd86"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-static-attribs"></a>
Static Private Attributes</h2></td></tr>
<tr class="memitem:a93e691714fda31d09eade2b304d79b0b"><td class="memItemLeft" align="right" valign="top"><a id="a93e691714fda31d09eade2b304d79b0b"></a>
static const std::vector&lt; <a class="el" href="structFFmpeg__Transcoder_1_1PRORES__BITRATE.html">PRORES_BITRATE</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Transcoder.html#a93e691714fda31d09eade2b304d79b0b">m_prores_bitrate</a></td></tr>
<tr class="memdesc:a93e691714fda31d09eade2b304d79b0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">ProRes bitrate table. Used for file size prediction. <br /></td></tr>
<tr class="separator:a93e691714fda31d09eade2b304d79b0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d4ff70078b4316d665aaadf566aad11"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classFFmpeg__Transcoder.html#ac9f065a7a574e400abac168cec2a556f">DEVICETYPE_MAP</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Transcoder.html#a0d4ff70078b4316d665aaadf566aad11">m_devicetype_map</a></td></tr>
<tr class="memdesc:a0d4ff70078b4316d665aaadf566aad11"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of AVPixelFormats mapped to hardware acceleration types.  <a href="classFFmpeg__Transcoder.html#a0d4ff70078b4316d665aaadf566aad11">More...</a><br /></td></tr>
<tr class="separator:a0d4ff70078b4316d665aaadf566aad11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_attribs_classFFmpeg__Profiles"><td colspan="2" onclick="javascript:toggleInherit('pub_static_attribs_classFFmpeg__Profiles')"><img src="closed.png" alt="-"/>&#160;Static Private Attributes inherited from <a class="el" href="classFFmpeg__Profiles.html">FFmpeg_Profiles</a></td></tr>
<tr class="memitem:a68eb2f1bbf72bad333158246539d2b8f inherit pub_static_attribs_classFFmpeg__Profiles"><td class="memItemLeft" align="right" valign="top"><a id="a68eb2f1bbf72bad333158246539d2b8f"></a>
static const <a class="el" href="classFFmpeg__Profiles.html#ae8ad43ac884f0e3fae960f01876f2993">PROFILE_LIST_VEC</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Profiles.html#a68eb2f1bbf72bad333158246539d2b8f">m_profile</a></td></tr>
<tr class="memdesc:a68eb2f1bbf72bad333158246539d2b8f inherit pub_static_attribs_classFFmpeg__Profiles"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of profile options. <br /></td></tr>
<tr class="separator:a68eb2f1bbf72bad333158246539d2b8f inherit pub_static_attribs_classFFmpeg__Profiles"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_attribs_classFFmpeg__Base"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classFFmpeg__Base')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classFFmpeg__Base.html">FFmpeg_Base</a></td></tr>
<tr class="memitem:a79f2cb50858ef7380255875619feb682 inherit pro_attribs_classFFmpeg__Base"><td class="memItemLeft" align="right" valign="top"><a id="a79f2cb50858ef7380255875619feb682"></a>
<a class="el" href="structVIRTUALFILE.html">VIRTUALFILE</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Base.html#a79f2cb50858ef7380255875619feb682">m_virtualfile</a></td></tr>
<tr class="memdesc:a79f2cb50858ef7380255875619feb682 inherit pro_attribs_classFFmpeg__Base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Underlying virtual file object. <br /></td></tr>
<tr class="separator:a79f2cb50858ef7380255875619feb682 inherit pro_attribs_classFFmpeg__Base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_classFFmpeg__Profiles"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classFFmpeg__Profiles')"><img src="closed.png" alt="-"/>&#160;Private Types inherited from <a class="el" href="classFFmpeg__Profiles.html">FFmpeg_Profiles</a></td></tr>
<tr class="memitem:aabf1b6437adb1d6ac7ae2a5631ce02b5 inherit pub_types_classFFmpeg__Profiles"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structFFmpeg__Profiles_1_1PROFILE__OPTION.html">FFmpeg_Profiles::PROFILE_OPTION</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Profiles.html#aabf1b6437adb1d6ac7ae2a5631ce02b5">PROFILE_OPTION</a></td></tr>
<tr class="memdesc:aabf1b6437adb1d6ac7ae2a5631ce02b5 inherit pub_types_classFFmpeg__Profiles"><td class="mdescLeft">&#160;</td><td class="mdescRight">Profiles options.  <a href="classFFmpeg__Profiles.html#aabf1b6437adb1d6ac7ae2a5631ce02b5">More...</a><br /></td></tr>
<tr class="separator:aabf1b6437adb1d6ac7ae2a5631ce02b5 inherit pub_types_classFFmpeg__Profiles"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae051d3a7231797155370b032e32abaa6 inherit pub_types_classFFmpeg__Profiles"><td class="memItemLeft" align="right" valign="top"><a id="ae051d3a7231797155370b032e32abaa6"></a>
typedef <a class="el" href="structFFmpeg__Profiles_1_1PROFILE__OPTION.html">PROFILE_OPTION</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Profiles.html#ae051d3a7231797155370b032e32abaa6">LPPROFILE_OPTION</a></td></tr>
<tr class="memdesc:ae051d3a7231797155370b032e32abaa6 inherit pub_types_classFFmpeg__Profiles"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer version of <a class="el" href="structFFmpeg__Profiles_1_1PROFILE__OPTION.html" title="Profiles options.">PROFILE_OPTION</a>. <br /></td></tr>
<tr class="separator:ae051d3a7231797155370b032e32abaa6 inherit pub_types_classFFmpeg__Profiles"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cfb233e140c53383918469a3352d422 inherit pub_types_classFFmpeg__Profiles"><td class="memItemLeft" align="right" valign="top"><a id="a6cfb233e140c53383918469a3352d422"></a>
typedef <a class="el" href="structFFmpeg__Profiles_1_1PROFILE__OPTION.html">PROFILE_OPTION</a> const  *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Profiles.html#a6cfb233e140c53383918469a3352d422">LPCPROFILE_OPTION</a></td></tr>
<tr class="memdesc:a6cfb233e140c53383918469a3352d422 inherit pub_types_classFFmpeg__Profiles"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to const version of <a class="el" href="structFFmpeg__Profiles_1_1PROFILE__OPTION.html" title="Profiles options.">PROFILE_OPTION</a>. <br /></td></tr>
<tr class="separator:a6cfb233e140c53383918469a3352d422 inherit pub_types_classFFmpeg__Profiles"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c96ed075fd81ebc334ad2a0e89bc114 inherit pub_types_classFFmpeg__Profiles"><td class="memItemLeft" align="right" valign="top"><a id="a8c96ed075fd81ebc334ad2a0e89bc114"></a>
typedef std::vector&lt; <a class="el" href="structFFmpeg__Profiles_1_1PROFILE__OPTION.html">PROFILE_OPTION</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Profiles.html#a8c96ed075fd81ebc334ad2a0e89bc114">PROFILE_OPTION_VEC</a></td></tr>
<tr class="memdesc:a8c96ed075fd81ebc334ad2a0e89bc114 inherit pub_types_classFFmpeg__Profiles"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structFFmpeg__Profiles_1_1PROFILE__OPTION.html" title="Profiles options.">PROFILE_OPTION</a> array. <br /></td></tr>
<tr class="separator:a8c96ed075fd81ebc334ad2a0e89bc114 inherit pub_types_classFFmpeg__Profiles"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a2ef652afd91c83b2b49e061c3bd758 inherit pub_types_classFFmpeg__Profiles"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structFFmpeg__Profiles_1_1PROFILE__LIST.html">FFmpeg_Profiles::PROFILE_LIST</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Profiles.html#a3a2ef652afd91c83b2b49e061c3bd758">PROFILE_LIST</a></td></tr>
<tr class="memdesc:a3a2ef652afd91c83b2b49e061c3bd758 inherit pub_types_classFFmpeg__Profiles"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of profiles.  <a href="classFFmpeg__Profiles.html#a3a2ef652afd91c83b2b49e061c3bd758">More...</a><br /></td></tr>
<tr class="separator:a3a2ef652afd91c83b2b49e061c3bd758 inherit pub_types_classFFmpeg__Profiles"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35e01797535b08eba77376c96891b998 inherit pub_types_classFFmpeg__Profiles"><td class="memItemLeft" align="right" valign="top"><a id="a35e01797535b08eba77376c96891b998"></a>
typedef <a class="el" href="structFFmpeg__Profiles_1_1PROFILE__LIST.html">PROFILE_LIST</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Profiles.html#a35e01797535b08eba77376c96891b998">LPPROFILE_LIST</a></td></tr>
<tr class="memdesc:a35e01797535b08eba77376c96891b998 inherit pub_types_classFFmpeg__Profiles"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer version of <a class="el" href="structFFmpeg__Profiles_1_1PROFILE__LIST.html" title="List of profiles.">PROFILE_LIST</a>. <br /></td></tr>
<tr class="separator:a35e01797535b08eba77376c96891b998 inherit pub_types_classFFmpeg__Profiles"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0ed84799f2ed3c0a660187d8d802fce inherit pub_types_classFFmpeg__Profiles"><td class="memItemLeft" align="right" valign="top"><a id="af0ed84799f2ed3c0a660187d8d802fce"></a>
typedef <a class="el" href="structFFmpeg__Profiles_1_1PROFILE__LIST.html">PROFILE_LIST</a> const  *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Profiles.html#af0ed84799f2ed3c0a660187d8d802fce">LPCPROFILE_LIST</a></td></tr>
<tr class="memdesc:af0ed84799f2ed3c0a660187d8d802fce inherit pub_types_classFFmpeg__Profiles"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to const version of <a class="el" href="structFFmpeg__Profiles_1_1PROFILE__LIST.html" title="List of profiles.">PROFILE_LIST</a>. <br /></td></tr>
<tr class="separator:af0ed84799f2ed3c0a660187d8d802fce inherit pub_types_classFFmpeg__Profiles"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8ad43ac884f0e3fae960f01876f2993 inherit pub_types_classFFmpeg__Profiles"><td class="memItemLeft" align="right" valign="top"><a id="ae8ad43ac884f0e3fae960f01876f2993"></a>
typedef std::vector&lt; <a class="el" href="structFFmpeg__Profiles_1_1PROFILE__LIST.html">PROFILE_LIST</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Profiles.html#ae8ad43ac884f0e3fae960f01876f2993">PROFILE_LIST_VEC</a></td></tr>
<tr class="memdesc:ae8ad43ac884f0e3fae960f01876f2993 inherit pub_types_classFFmpeg__Profiles"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structFFmpeg__Profiles_1_1PROFILE__LIST.html" title="List of profiles.">PROFILE_LIST</a> array. <br /></td></tr>
<tr class="separator:ae8ad43ac884f0e3fae960f01876f2993 inherit pub_types_classFFmpeg__Profiles"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classFFmpeg__Profiles"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classFFmpeg__Profiles')"><img src="closed.png" alt="-"/>&#160;Private Member Functions inherited from <a class="el" href="classFFmpeg__Profiles.html">FFmpeg_Profiles</a></td></tr>
<tr class="memitem:a30b90c7ff56ccd6a163722fc863eeb72 inherit pub_methods_classFFmpeg__Profiles"><td class="memItemLeft" align="right" valign="top"><a id="a30b90c7ff56ccd6a163722fc863eeb72"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Profiles.html#a30b90c7ff56ccd6a163722fc863eeb72">FFmpeg_Profiles</a> ()=default</td></tr>
<tr class="memdesc:a30b90c7ff56ccd6a163722fc863eeb72 inherit pub_methods_classFFmpeg__Profiles"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a <a class="el" href="classFFmpeg__Profiles.html" title="The FFmpeg_Profiles class.">FFmpeg_Profiles</a> object. <br /></td></tr>
<tr class="separator:a30b90c7ff56ccd6a163722fc863eeb72 inherit pub_methods_classFFmpeg__Profiles"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6ac01be367c9344f6f4f182784665ce inherit pub_methods_classFFmpeg__Profiles"><td class="memItemLeft" align="right" valign="top"><a id="ae6ac01be367c9344f6f4f182784665ce"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFFmpeg__Profiles.html#ae6ac01be367c9344f6f4f182784665ce">~FFmpeg_Profiles</a> ()=default</td></tr>
<tr class="memdesc:ae6ac01be367c9344f6f4f182784665ce inherit pub_methods_classFFmpeg__Profiles"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destruct a <a class="el" href="classFFmpeg__Profiles.html" title="The FFmpeg_Profiles class.">FFmpeg_Profiles</a> object. <br /></td></tr>
<tr class="separator:ae6ac01be367c9344f6f4f182784665ce inherit pub_methods_classFFmpeg__Profiles"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The <a class="el" href="classFFmpeg__Transcoder.html" title="The FFmpeg_Transcoder class.">FFmpeg_Transcoder</a> class. </p>

<p class="definition">Definition at line <a class="el" href="ffmpeg__transcoder_8h_source.html#l00063">63</a> of file <a class="el" href="ffmpeg__transcoder_8h_source.html">ffmpeg_transcoder.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="ac0963a5147f86b572c97255540219d43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0963a5147f86b572c97255540219d43">&#9670;&nbsp;</a></span>HWACCELMODE</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typedef enum <a class="el" href="classFFmpeg__Transcoder.html#a069bfc8760dc23399d2f9a044aeacf51">FFmpeg_Transcoder::HWACCELMODE</a> <a class="el" href="classFFmpeg__Transcoder.html#a069bfc8760dc23399d2f9a044aeacf51">FFmpeg_Transcoder::HWACCELMODE</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Currently active hardware acceleration mode. </p>
<p>&lt; </p>

</div>
</div>
<a id="aa1db28dbe32ef55964ad61349a2058a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1db28dbe32ef55964ad61349a2058a5">&#9670;&nbsp;</a></span>PRORES_BITRATE</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structFFmpeg__Transcoder_1_1PRORES__BITRATE.html">FFmpeg_Transcoder::PRORES_BITRATE</a> <a class="el" href="structFFmpeg__Transcoder_1_1PRORES__BITRATE.html">FFmpeg_Transcoder::PRORES_BITRATE</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Predicted bitrates for Apple Prores, see <a href="https://www.apple.com/final-cut-pro/docs/Apple_ProRes_White_Paper.pdf">https://www.apple.com/final-cut-pro/docs/Apple_ProRes_White_Paper.pdf</a>. </p>
<p>&lt; List of ProRes bit rates </p>

</div>
</div>
<h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="a069bfc8760dc23399d2f9a044aeacf51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a069bfc8760dc23399d2f9a044aeacf51">&#9670;&nbsp;</a></span>HWACCELMODE</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classFFmpeg__Transcoder.html#a069bfc8760dc23399d2f9a044aeacf51">FFmpeg_Transcoder::HWACCELMODE</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Currently active hardware acceleration mode. </p>
<p>&lt; </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a069bfc8760dc23399d2f9a044aeacf51a5f6ad8669ced8c0309664f29cafd8c91"></a>HWACCELMODE_NONE&#160;</td><td class="fielddoc"><p>Hardware acceleration not active. </p>
</td></tr>
<tr><td class="fieldname"><a id="a069bfc8760dc23399d2f9a044aeacf51a58cdc8554f2784ac92074a2d36057d14"></a>HWACCELMODE_ENABLED&#160;</td><td class="fielddoc"><p>Hardware acceleration is active. </p>
</td></tr>
<tr><td class="fieldname"><a id="a069bfc8760dc23399d2f9a044aeacf51afc06420ac0aaa932f8f4b02a1836f4ff"></a>HWACCELMODE_FALLBACK&#160;</td><td class="fielddoc"><p>Hardware acceleration selected, but fell back to software. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="ffmpeg__transcoder_8h_source.html#l00168">168</a> of file <a class="el" href="ffmpeg__transcoder_8h_source.html">ffmpeg_transcoder.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a65d1570366ac1d759e197a754840ae27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65d1570366ac1d759e197a754840ae27">&#9670;&nbsp;</a></span>FFmpeg_Transcoder()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FFmpeg_Transcoder::FFmpeg_Transcoder </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Construct <a class="el" href="classFFmpeg__Transcoder.html" title="The FFmpeg_Transcoder class.">FFmpeg_Transcoder</a> object </p>

<p class="definition">Definition at line <a class="el" href="ffmpeg__transcoder_8cc_source.html#l00230">230</a> of file <a class="el" href="ffmpeg__transcoder_8cc_source.html">ffmpeg_transcoder.cc</a>.</p>

<p class="reference">References <a class="el" href="ffmpeg__utils_8cc_source.html#l01481">init_id3v1()</a>, <a class="el" href="ffmpegfs_8h_source.html#l00200">FFMPEGFS_PARAMS::m_audiochannels</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l01201">m_cur_ch_layout</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l00163">FFmpeg_Transcoder::OUTPUTFILE::m_id3v1</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l01187">m_mtime</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l01218">m_out</a>, <a class="el" href="ffmpegfs_8cc_source.html#l00072">params</a>, and <a class="el" href="logging_8h_source.html#l00161">Logging::trace()</a>.</p>

</div>
</div>
<a id="af20ff945bd865539207ea927cb5f7ec8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af20ff945bd865539207ea927cb5f7ec8">&#9670;&nbsp;</a></span>~FFmpeg_Transcoder()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FFmpeg_Transcoder::~FFmpeg_Transcoder </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Destroy FFMPEG_Transcoder object Close and free all internal structures. </p>

<p class="definition">Definition at line <a class="el" href="ffmpeg__transcoder_8cc_source.html#l00281">281</a> of file <a class="el" href="ffmpeg__transcoder_8cc_source.html">ffmpeg_transcoder.cc</a>.</p>

<p class="reference">References <a class="el" href="ffmpeg__transcoder_8cc_source.html#l06427">close()</a>, and <a class="el" href="logging_8h_source.html#l00161">Logging::trace()</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a6ead4d48dfe32cb96e5495b4efadcf6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ead4d48dfe32cb96e5495b4efadcf6a">&#9670;&nbsp;</a></span>add_albumart_frame()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int FFmpeg_Transcoder::add_albumart_frame </td>
          <td>(</td>
          <td class="paramtype">AVStream *&#160;</td>
          <td class="paramname"><em>output_stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AVPacket *&#160;</td>
          <td class="paramname"><em>pkt_in</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add album art to stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">output_stream</td><td>- Output stream. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pkt_in</td><td>- Packet with album art. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, returns 0; on error, a negative AVERROR value. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ffmpeg__transcoder_8cc_source.html#l02565">2565</a> of file <a class="el" href="ffmpeg__transcoder_8cc_source.html">ffmpeg_transcoder.cc</a>.</p>

<p class="reference">References <a class="el" href="logging_8h_source.html#l00237">Logging::error()</a>, <a class="el" href="ffmpeg__utils_8cc_source.html#l01139">ffmpeg_geterror()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l03634">store_packet()</a>, <a class="el" href="logging_8h_source.html#l00161">Logging::trace()</a>, and <a class="el" href="ffmpeg__transcoder_8cc_source.html#l06458">virtname()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ffmpeg__transcoder_8cc_source.html#l03740">decode_frame()</a>, and <a class="el" href="ffmpeg__transcoder_8cc_source.html#l04971">process_albumarts()</a>.</p>

</div>
</div>
<a id="a7f6903a86d5ed1ebee3258b981536f74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f6903a86d5ed1ebee3258b981536f74">&#9670;&nbsp;</a></span>add_albumart_stream()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int FFmpeg_Transcoder::add_albumart_stream </td>
          <td>(</td>
          <td class="paramtype">const AVCodecContext *&#160;</td>
          <td class="paramname"><em>input_codec_ctx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a stream for an album art. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input_codec_ctx</td><td>- Input codec context. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, returns 0; on error, a negative AVERROR value. </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000010">Todo:</a></b></dt><dd>Add support for album arts </dd></dl>

<p class="definition">Definition at line <a class="el" href="ffmpeg__transcoder_8cc_source.html#l02457">2457</a> of file <a class="el" href="ffmpeg__transcoder_8cc_source.html">ffmpeg_transcoder.cc</a>.</p>

<p class="reference">References <a class="el" href="ffmpeg__utils_8h_source.html#l00132">AV_CODEC_FLAG_GLOBAL_HEADER</a>, <a class="el" href="logging_8h_source.html#l00180">Logging::debug()</a>, <a class="el" href="logging_8h_source.html#l00237">Logging::error()</a>, <a class="el" href="ffmpeg__utils_8cc_source.html#l01139">ffmpeg_geterror()</a>, <a class="el" href="ffmpeg__utils_8cc_source.html#l01153">ffmpeg_rescale_q()</a>, <a class="el" href="ffmpeg__utils_8cc_source.html#l01354">get_codec_name()</a>, <a class="el" href="ffmpeg__utils_8cc_source.html#l01184">get_media_type_string()</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l00145">FFmpeg_Transcoder::INPUTFILE::m_album_art</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l00140">FFmpeg_Transcoder::INPUTFILE::m_audio</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l00138">FFmpeg_Transcoder::INPUTFILE::m_format_ctx</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l01217">m_in</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l01218">m_out</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l00121">FFmpeg_Transcoder::StreamRef::m_stream</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l00122">FFmpeg_Transcoder::StreamRef::m_stream_idx</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l00209">FFmpeg_Transcoder::StreamRef::set_codec_ctx()</a>, and <a class="el" href="ffmpeg__transcoder_8cc_source.html#l06458">virtname()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ffmpeg__transcoder_8cc_source.html#l02592">open_output_filestreams()</a>.</p>

</div>
</div>
<a id="a5b5c8873a0b5fe7d964de351c4b2b3fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b5c8873a0b5fe7d964de351c4b2b3fc">&#9670;&nbsp;</a></span>add_external_subtitle_stream()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int FFmpeg_Transcoder::add_external_subtitle_stream </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>subtitle_file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::optional&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>language</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>add_external_subtitle_stream </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">subtitle_file</td><td>- Name of subtitle fule </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">language</td><td>- Language or subtitle file, or std::nullopt if unknown. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, a negative AVERROR code on failure. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ffmpeg__transcoder_8cc_source.html#l07590">7590</a> of file <a class="el" href="ffmpeg__transcoder_8cc_source.html">ffmpeg_transcoder.cc</a>.</p>

<p class="reference">References <a class="el" href="ffmpeg__transcoder_8cc_source.html#l02238">add_subtitle_stream()</a>, <a class="el" href="logging_8h_source.html#l00180">Logging::debug()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l03564">decode_subtitle()</a>, <a class="el" href="logging_8h_source.html#l00237">Logging::error()</a>, <a class="el" href="ffmpeg__utils_8cc_source.html#l01139">ffmpeg_geterror()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l06448">filename()</a>, <a class="el" href="ffmpeg__utils_8h_source.html#l00074">INVALID_STREAM</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l01228">m_current_format</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l00121">FFmpeg_Transcoder::StreamRef::m_stream</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l00122">FFmpeg_Transcoder::StreamRef::m_stream_idx</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l00873">open_bestmatch_decoder()</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l00071">FFmpeg_Transcoder::BUFFER_DATA::ptr</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l07572">read_packet()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l00209">FFmpeg_Transcoder::StreamRef::set_codec_ctx()</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l00072">FFmpeg_Transcoder::BUFFER_DATA::size</a>, and <a class="el" href="ffmpeg__utils_8cc_source.html#l00977">FFmpegfs_Format::subtitle_codec()</a>.</p>

</div>
</div>
<a id="a41de59102133d3c2aef9f37ccf3eb58f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41de59102133d3c2aef9f37ccf3eb58f">&#9670;&nbsp;</a></span>add_external_subtitle_streams()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int FFmpeg_Transcoder::add_external_subtitle_streams </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scan for external subtitle files. </p>
<dl class="section return"><dt>Returns</dt><dd>0 on success, a negative AVERROR code on failure. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ffmpeg__transcoder_8cc_source.html#l07732">7732</a> of file <a class="el" href="ffmpeg__transcoder_8cc_source.html">ffmpeg_transcoder.cc</a>.</p>

<p class="reference">References <a class="el" href="logging_8h_source.html#l00237">Logging::error()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l06448">filename()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l07524">foreach_subtitle_file()</a>, and <a class="el" href="ffmpeg__utils_8cc_source.html#l02479">regex_escape()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ffmpeg__transcoder_8cc_source.html#l02592">open_output_filestreams()</a>.</p>

</div>
</div>
<a id="a02a175b227e2975a3be0578787900c02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02a175b227e2975a3be0578787900c02">&#9670;&nbsp;</a></span>add_samples_to_fifo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int FFmpeg_Transcoder::add_samples_to_fifo </td>
          <td>(</td>
          <td class="paramtype">uint8_t **&#160;</td>
          <td class="paramname"><em>converted_input_samples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>frame_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add converted input audio samples to the FIFO buffer for later processing. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">converted_input_samples</td><td>- Samples to add. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">frame_size</td><td>- Frame size </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, returns 0; on error, a negative AVERROR value. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ffmpeg__transcoder_8cc_source.html#l03980">3980</a> of file <a class="el" href="ffmpeg__transcoder_8cc_source.html">ffmpeg_transcoder.cc</a>.</p>

<p class="reference">References <a class="el" href="logging_8h_source.html#l00237">Logging::error()</a>, <a class="el" href="ffmpeg__utils_8cc_source.html#l01139">ffmpeg_geterror()</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l01206">m_audio_fifo</a>, and <a class="el" href="ffmpeg__transcoder_8cc_source.html#l06458">virtname()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ffmpeg__transcoder_8cc_source.html#l03251">decode_audio_frame()</a>.</p>

</div>
</div>
<a id="afe22b3a4c7ad7fa2ca8219f5b76f2542"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe22b3a4c7ad7fa2ca8219f5b76f2542">&#9670;&nbsp;</a></span>add_stream()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int FFmpeg_Transcoder::add_stream </td>
          <td>(</td>
          <td class="paramtype">AVCodecID&#160;</td>
          <td class="paramname"><em>codec_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add new stream to output file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">codec_id</td><td>- Codec for this stream. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, returns index of new stream [0...n]; On error, negative AVERROR value. </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000009">Todo:</a></b></dt><dd>FFmpeg actually <em>can</em> transcode while presevering the SAR. FFmpegfs rescales to fix that problem. Need to find out what I am doing wrong here... </dd></dl>

<p class="definition">Definition at line <a class="el" href="ffmpeg__transcoder_8cc_source.html#l01631">1631</a> of file <a class="el" href="ffmpeg__transcoder_8cc_source.html">ffmpeg_transcoder.cc</a>.</p>

<p class="reference">References <a class="el" href="ffmpeg__transcoder_8cc_source.html#l07504">add_stream_map()</a>, <a class="el" href="ffmpeg__utils_8h_source.html#l00146">BITRATE</a>, <a class="el" href="logging_8h_source.html#l00180">Logging::debug()</a>, <a class="el" href="ffmpeg__base_8cc_source.html#l00173">FFmpeg_Base::dict_set_with_check()</a>, <a class="el" href="logging_8h_source.html#l00237">Logging::error()</a>, <a class="el" href="ffmpeg__utils_8cc_source.html#l01153">ffmpeg_rescale_q()</a>, <a class="el" href="ffmpeg__utils_8cc_source.html#l01507">format_bitrate()</a>, <a class="el" href="ffmpeg__utils_8cc_source.html#l01531">format_samplerate()</a>, <a class="el" href="ffmpeg__base_8cc_source.html#l00332">FFmpeg_Base::get_channels()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l07059">get_hw_encoder_name()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l00901">get_hw_pix_fmt()</a>, <a class="el" href="ffmpegfs_8cc_source.html#l01590">get_hwaccel_API_text()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l01437">get_output_bit_rate()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l01417">get_output_sample_rate()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l01501">get_video_size()</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l00171">HWACCELMODE_ENABLED</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l00172">HWACCELMODE_FALLBACK</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l06842">hwframe_ctx_set()</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l00140">FFmpeg_Transcoder::INPUTFILE::m_audio</a>, <a class="el" href="ffmpegfs_8h_source.html#l00198">FFMPEGFS_PARAMS::m_audiobitrate</a>, <a class="el" href="ffmpegfs_8h_source.html#l00200">FFMPEGFS_PARAMS::m_audiochannels</a>, <a class="el" href="ffmpegfs_8h_source.html#l00199">FFMPEGFS_PARAMS::m_audiosamplerate</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l00120">FFmpeg_Transcoder::StreamRef::m_codec_ctx</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l01228">m_current_format</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l01245">m_enc_hw_pix_fmt</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l00136">FFmpeg_Transcoder::INPUTFILE::m_filetype</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l00138">FFmpeg_Transcoder::INPUTFILE::m_format_ctx</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l01241">m_hwaccel_enable_enc_buffering</a>, <a class="el" href="ffmpegfs_8h_source.html#l00211">FFMPEGFS_PARAMS::m_hwaccel_enc_API</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l01243">m_hwaccel_enc_device_ctx</a>, <a class="el" href="ffmpegfs_8h_source.html#l00212">FFMPEGFS_PARAMS::m_hwaccel_enc_device_type</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l01239">m_hwaccel_enc_mode</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l01217">m_in</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l01218">m_out</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l00121">FFmpeg_Transcoder::StreamRef::m_stream</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l00122">FFmpeg_Transcoder::StreamRef::m_stream_idx</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l00141">FFmpeg_Transcoder::INPUTFILE::m_video</a>, <a class="el" href="ffmpegfs_8h_source.html#l00203">FFMPEGFS_PARAMS::m_videobitrate</a>, <a class="el" href="ffmpegfs_8cc_source.html#l00072">params</a>, <a class="el" href="ffmpeg__utils_8cc_source.html#l00962">FFmpegfs_Format::sample_format()</a>, <a class="el" href="ffmpeg__base_8cc_source.html#l00341">FFmpeg_Base::set_channels()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l00209">FFmpeg_Transcoder::StreamRef::set_codec_ctx()</a>, <a class="el" href="logging_8h_source.html#l00161">Logging::trace()</a>, <a class="el" href="ffmpeg__base_8cc_source.html#l00069">FFmpeg_Base::video_stream_setup()</a>, and <a class="el" href="ffmpeg__transcoder_8cc_source.html#l06458">virtname()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ffmpeg__transcoder_8cc_source.html#l02592">open_output_filestreams()</a>.</p>

</div>
</div>
<a id="a2e8ce09d8256cd2d6200b87ea84044dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e8ce09d8256cd2d6200b87ea84044dc">&#9670;&nbsp;</a></span>add_stream_copy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int FFmpeg_Transcoder::add_stream_copy </td>
          <td>(</td>
          <td class="paramtype">AVCodecID&#160;</td>
          <td class="paramname"><em>codec_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AVMediaType&#160;</td>
          <td class="paramname"><em>codec_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add new stream copy to output file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">codec_id</td><td>- Codec for this stream. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">codec_type</td><td>- Codec type: audio or video. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, returns 0; on error, a negative AVERROR value. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ffmpeg__transcoder_8cc_source.html#l02378">2378</a> of file <a class="el" href="ffmpeg__transcoder_8cc_source.html">ffmpeg_transcoder.cc</a>.</p>

<p class="reference">References <a class="el" href="ffmpeg__transcoder_8cc_source.html#l07504">add_stream_map()</a>, <a class="el" href="logging_8h_source.html#l00237">Logging::error()</a>, <a class="el" href="ffmpeg__utils_8cc_source.html#l01139">ffmpeg_geterror()</a>, <a class="el" href="ffmpeg__utils_8cc_source.html#l01153">ffmpeg_rescale_q()</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l00140">FFmpeg_Transcoder::INPUTFILE::m_audio</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l00138">FFmpeg_Transcoder::INPUTFILE::m_format_ctx</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l01217">m_in</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l01218">m_out</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l00121">FFmpeg_Transcoder::StreamRef::m_stream</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l00122">FFmpeg_Transcoder::StreamRef::m_stream_idx</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l00141">FFmpeg_Transcoder::INPUTFILE::m_video</a>, <a class="el" href="ffmpeg__utils_8cc_source.html#l01734">print_stream_info()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l00209">FFmpeg_Transcoder::StreamRef::set_codec_ctx()</a>, and <a class="el" href="ffmpeg__transcoder_8cc_source.html#l06458">virtname()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ffmpeg__transcoder_8cc_source.html#l02592">open_output_filestreams()</a>.</p>

</div>
</div>
<a id="a945a7951dae5144a56244ee1a4e427c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a945a7951dae5144a56244ee1a4e427c9">&#9670;&nbsp;</a></span>add_stream_map()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void FFmpeg_Transcoder::add_stream_map </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>in_stream_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>out_stream_idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add entry to input stream to output stream map. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">in_stream_idx</td><td>- Index of input stream </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">out_stream_idx</td><td>- Index of output stream </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="ffmpeg__transcoder_8cc_source.html#l07504">7504</a> of file <a class="el" href="ffmpeg__transcoder_8cc_source.html">ffmpeg_transcoder.cc</a>.</p>

<p class="reference">References <a class="el" href="ffmpeg__utils_8h_source.html#l00074">INVALID_STREAM</a>, and <a class="el" href="ffmpeg__transcoder_8h_source.html#l01219">m_stream_map</a>.</p>

<p class="reference">Referenced by <a class="el" href="ffmpeg__transcoder_8cc_source.html#l01631">add_stream()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l02378">add_stream_copy()</a>, and <a class="el" href="ffmpeg__transcoder_8cc_source.html#l02238">add_subtitle_stream()</a>.</p>

</div>
</div>
<a id="a04d4003ac05d9a07dfe94d67a6d6fa48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04d4003ac05d9a07dfe94d67a6d6fa48">&#9670;&nbsp;</a></span>add_subtitle_stream()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int FFmpeg_Transcoder::add_subtitle_stream </td>
          <td>(</td>
          <td class="paramtype">AVCodecID&#160;</td>
          <td class="paramname"><em>codec_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classFFmpeg__Transcoder_1_1StreamRef.html">StreamRef</a> &amp;&#160;</td>
          <td class="paramname"><em>input_streamref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::optional&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>language</em> = <code>std::nullopt</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add new subtitle stream to output file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">codec_id</td><td>- Codec for this stream. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">input_streamref</td><td>- Streamref of input stream. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">language</td><td>- (Optional) Language or subtitle file, or std::nullopt if unknown. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, returns index of new stream [0...n]; On error, negative AVERROR value. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ffmpeg__transcoder_8cc_source.html#l02238">2238</a> of file <a class="el" href="ffmpeg__transcoder_8cc_source.html">ffmpeg_transcoder.cc</a>.</p>

<p class="reference">References <a class="el" href="ffmpeg__transcoder_8cc_source.html#l07504">add_stream_map()</a>, <a class="el" href="ffmpeg__base_8h_source.html#l00250">ASS_DEFAULT_ALIGNMENT</a>, <a class="el" href="ffmpeg__base_8h_source.html#l00231">ASS_DEFAULT_BACK_COLOUR</a>, <a class="el" href="ffmpeg__base_8h_source.html#l00232">ASS_DEFAULT_BOLD</a>, <a class="el" href="ffmpeg__base_8h_source.html#l00256">ASS_DEFAULT_BORDERSTYLE</a>, <a class="el" href="ffmpeg__base_8h_source.html#l00230">ASS_DEFAULT_COLOUR</a>, <a class="el" href="ffmpeg__base_8h_source.html#l00218">ASS_DEFAULT_FONT</a>, <a class="el" href="ffmpeg__base_8h_source.html#l00219">ASS_DEFAULT_FONT_SIZE</a>, <a class="el" href="ffmpeg__base_8h_source.html#l00233">ASS_DEFAULT_ITALIC</a>, <a class="el" href="ffmpeg__base_8h_source.html#l00216">ASS_DEFAULT_PLAYRESX</a>, <a class="el" href="ffmpeg__base_8h_source.html#l00217">ASS_DEFAULT_PLAYRESY</a>, <a class="el" href="ffmpeg__base_8h_source.html#l00234">ASS_DEFAULT_UNDERLINE</a>, <a class="el" href="logging_8h_source.html#l00180">Logging::debug()</a>, <a class="el" href="ffmpeg__base_8cc_source.html#l00173">FFmpeg_Base::dict_set_with_check()</a>, <a class="el" href="logging_8h_source.html#l00237">Logging::error()</a>, <a class="el" href="ffmpeg__utils_8cc_source.html#l01139">ffmpeg_geterror()</a>, <a class="el" href="ffmpeg__utils_8cc_source.html#l01153">ffmpeg_rescale_q()</a>, <a class="el" href="ffmpeg__utils_8cc_source.html#l01354">get_codec_name()</a>, <a class="el" href="ffmpeg__utils_8cc_source.html#l01184">get_media_type_string()</a>, <a class="el" href="ffmpeg__base_8cc_source.html#l00383">FFmpeg_Base::get_script_info()</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l00140">FFmpeg_Transcoder::INPUTFILE::m_audio</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l00120">FFmpeg_Transcoder::StreamRef::m_codec_ctx</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l00138">FFmpeg_Transcoder::INPUTFILE::m_format_ctx</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l01217">m_in</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l01218">m_out</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l00121">FFmpeg_Transcoder::StreamRef::m_stream</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l00122">FFmpeg_Transcoder::StreamRef::m_stream_idx</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l00143">FFmpeg_Transcoder::INPUTFILE::m_subtitle</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l00141">FFmpeg_Transcoder::INPUTFILE::m_video</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l00209">FFmpeg_Transcoder::StreamRef::set_codec_ctx()</a>, and <a class="el" href="ffmpeg__transcoder_8cc_source.html#l06458">virtname()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ffmpeg__transcoder_8cc_source.html#l07590">add_external_subtitle_stream()</a>, and <a class="el" href="ffmpeg__transcoder_8cc_source.html#l02762">add_subtitle_streams()</a>.</p>

</div>
</div>
<a id="a96ed62701c42f8f76ce16d3c79b940cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96ed62701c42f8f76ce16d3c79b940cb">&#9670;&nbsp;</a></span>add_subtitle_streams()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int FFmpeg_Transcoder::add_subtitle_streams </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add all subtitle streams. Already existing streams are not added again. </p>
<dl class="section return"><dt>Returns</dt><dd>0 on success, a negative AVERROR code on failure. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ffmpeg__transcoder_8cc_source.html#l02762">2762</a> of file <a class="el" href="ffmpeg__transcoder_8cc_source.html">ffmpeg_transcoder.cc</a>.</p>

<p class="reference">References <a class="el" href="ffmpeg__transcoder_8cc_source.html#l02238">add_subtitle_stream()</a>, <a class="el" href="ffmpeg__utils_8h_source.html#l00074">INVALID_STREAM</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l01228">m_current_format</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l01217">m_in</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l00143">FFmpeg_Transcoder::INPUTFILE::m_subtitle</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l07512">map_in_to_out_stream()</a>, and <a class="el" href="ffmpeg__utils_8cc_source.html#l00977">FFmpegfs_Format::subtitle_codec()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ffmpeg__transcoder_8cc_source.html#l02592">open_output_filestreams()</a>.</p>

</div>
</div>
<a id="a8f11f9e84745323aab9860906f1f8df4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f11f9e84745323aab9860906f1f8df4">&#9670;&nbsp;</a></span>alloc_picture()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int FFmpeg_Transcoder::alloc_picture </td>
          <td>(</td>
          <td class="paramtype">AVFrame *&#160;</td>
          <td class="paramname"><em>frame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AVPixelFormat&#160;</td>
          <td class="paramname"><em>pix_fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>height</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocate memory for one picture. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">frame</td><td>- Frame to prepare </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pix_fmt</td><td>- Pixel format </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">width</td><td>- Picture width </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">height</td><td>- Picture height </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, returns 0; on error, a negative AVERROR value. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ffmpeg__transcoder_8cc_source.html#l03178">3178</a> of file <a class="el" href="ffmpeg__transcoder_8cc_source.html">ffmpeg_transcoder.cc</a>.</p>

<p class="reference">References <a class="el" href="logging_8h_source.html#l00237">Logging::error()</a>, <a class="el" href="ffmpeg__utils_8cc_source.html#l01139">ffmpeg_geterror()</a>, and <a class="el" href="ffmpeg__transcoder_8cc_source.html#l06458">virtname()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ffmpeg__transcoder_8cc_source.html#l03354">decode_video_frame()</a>.</p>

</div>
</div>
<a id="a37eefe55ee19037bb7c230b6d1498ba9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37eefe55ee19037bb7c230b6d1498ba9">&#9670;&nbsp;</a></span>audio_size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool FFmpeg_Transcoder::audio_size </td>
          <td>(</td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>filesize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AVCodecID&#160;</td>
          <td class="paramname"><em>codec_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ffmpeg__utils_8h.html#a17468d10f0c67a4ee7b38aab09d9e096">BITRATE</a>&#160;</td>
          <td class="paramname"><em>bit_rate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>duration</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>channels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sample_rate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AVSampleFormat&#160;</td>
          <td class="paramname"><em>sample_format</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Predict audio file size. This may (better will surely) be inaccurate. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">filesize</td><td>- Predicted file size in bytes, including audio stream size. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">codec_id</td><td>- Target codec ID. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bit_rate</td><td>- Target bit rate. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">duration</td><td>- File duration. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">channels</td><td>- Number of channels in target file. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sample_rate</td><td>- Sample rate of target file. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sample_format</td><td>- Selected sample format </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, returns true; on failure, returns false. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ffmpeg__transcoder_8cc_source.html#l05695">5695</a> of file <a class="el" href="ffmpeg__transcoder_8cc_source.html">ffmpeg_transcoder.cc</a>.</p>

<p class="reference">References <a class="el" href="ffmpeg__utils_8h_source.html#l00146">BITRATE</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l06118">duration()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l01437">get_output_bit_rate()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l01417">get_output_sample_rate()</a>, <a class="el" href="id3v1tag_8h_source.html#l00054">ID3V1_TAG_LENGTH</a>, <a class="el" href="ffmpegfs_8h_source.html#l00198">FFMPEGFS_PARAMS::m_audiobitrate</a>, <a class="el" href="ffmpegfs_8h_source.html#l00199">FFMPEGFS_PARAMS::m_audiosamplerate</a>, and <a class="el" href="ffmpegfs_8cc_source.html#l00072">params</a>.</p>

<p class="reference">Referenced by <a class="el" href="ffmpeg__transcoder_8cc_source.html#l06046">calculate_predicted_filesize()</a>, and <a class="el" href="transcode_8cc_source.html#l00289">transcoder_set_filesize()</a>.</p>

</div>
</div>
<a id="a1f1608f6c5c6d8efe099b8e9869cd259"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f1608f6c5c6d8efe099b8e9869cd259">&#9670;&nbsp;</a></span>can_copy_stream()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool FFmpeg_Transcoder::can_copy_stream </td>
          <td>(</td>
          <td class="paramtype">const AVStream *&#160;</td>
          <td class="paramname"><em>stream</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if stream can be copied from input to output (AUTOCOPY option). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">stream</td><td>- Input stream to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true if stream can be copied; false if not. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ffmpeg__transcoder_8cc_source.html#l00796">796</a> of file <a class="el" href="ffmpeg__transcoder_8cc_source.html">ffmpeg_transcoder.cc</a>.</p>

<p class="reference">References <a class="el" href="ffmpeg__utils_8cc_source.html#l00947">FFmpegfs_Format::audio_codec()</a>, <a class="el" href="ffmpeg__utils_8h_source.html#l00229">AUTOCOPY_MATCH</a>, <a class="el" href="ffmpeg__utils_8h_source.html#l00230">AUTOCOPY_MATCHLIMIT</a>, <a class="el" href="ffmpeg__utils_8h_source.html#l00228">AUTOCOPY_OFF</a>, <a class="el" href="ffmpeg__utils_8h_source.html#l00231">AUTOCOPY_STRICT</a>, <a class="el" href="ffmpeg__utils_8h_source.html#l00232">AUTOCOPY_STRICTLIMIT</a>, <a class="el" href="ffmpeg__utils_8h_source.html#l00146">BITRATE</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l01437">get_output_bit_rate()</a>, <a class="el" href="logging_8h_source.html#l00199">Logging::info()</a>, <a class="el" href="ffmpegfs_8h_source.html#l00198">FFMPEGFS_PARAMS::m_audiobitrate</a>, <a class="el" href="ffmpegfs_8h_source.html#l00193">FFMPEGFS_PARAMS::m_autocopy</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l01228">m_current_format</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l00138">FFmpeg_Transcoder::INPUTFILE::m_format_ctx</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l01217">m_in</a>, <a class="el" href="ffmpegfs_8cc_source.html#l00072">params</a>, and <a class="el" href="ffmpeg__transcoder_8cc_source.html#l06458">virtname()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ffmpeg__transcoder_8cc_source.html#l02592">open_output_filestreams()</a>.</p>

</div>
</div>
<a id="a55add6e3975e57bfe1e73f017a74c584"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55add6e3975e57bfe1e73f017a74c584">&#9670;&nbsp;</a></span>close_input_file()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool FFmpeg_Transcoder::close_input_file </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Closes the input file if open. Can safely be called again after the file was already closed or if the file was never open. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns true if anything has been closed; false if not. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ffmpeg__transcoder_8cc_source.html#l06386">6386</a> of file <a class="el" href="ffmpeg__transcoder_8cc_source.html">ffmpeg_transcoder.cc</a>.</p>

<p class="reference">References <a class="el" href="ffmpeg__transcoder_8cc_source.html#l00223">FFmpeg_Transcoder::StreamRef::close()</a>, <a class="el" href="classFileIO.html#ab30a83fd482d8702dd2ad532458ffa74">FileIO::close()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l06666">free_filters()</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l00145">FFmpeg_Transcoder::INPUTFILE::m_album_art</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l00140">FFmpeg_Transcoder::INPUTFILE::m_audio</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l01186">m_close_fileio</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l01185">m_fileio</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l00138">FFmpeg_Transcoder::INPUTFILE::m_format_ctx</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l01217">m_in</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l00143">FFmpeg_Transcoder::INPUTFILE::m_subtitle</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l00141">FFmpeg_Transcoder::INPUTFILE::m_video</a>, and <a class="el" href="ffmpeg__utils_8h_source.html#l01090">save_delete()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ffmpeg__transcoder_8cc_source.html#l06427">close()</a>.</p>

</div>
</div>
<a id="ac3da80243660c43fca519725321d3907"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3da80243660c43fca519725321d3907">&#9670;&nbsp;</a></span>close_output_file()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool FFmpeg_Transcoder::close_output_file </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Closes the output file if open and reports lost packets. Can safely be called again after the file was already closed or if the file was never open. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns true if anything has been closed; false if not. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ffmpeg__transcoder_8cc_source.html#l06343">6343</a> of file <a class="el" href="ffmpeg__transcoder_8cc_source.html">ffmpeg_transcoder.cc</a>.</p>

<p class="reference">References <a class="el" href="ffmpeg__transcoder_8cc_source.html#l00223">FFmpeg_Transcoder::StreamRef::close()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l06260">close_resample()</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l00145">FFmpeg_Transcoder::INPUTFILE::m_album_art</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l00140">FFmpeg_Transcoder::INPUTFILE::m_audio</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l00138">FFmpeg_Transcoder::INPUTFILE::m_format_ctx</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l01218">m_out</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l00143">FFmpeg_Transcoder::INPUTFILE::m_subtitle</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l01209">m_sws_ctx</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l00141">FFmpeg_Transcoder::INPUTFILE::m_video</a>, and <a class="el" href="ffmpeg__transcoder_8cc_source.html#l06310">purge()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ffmpeg__transcoder_8cc_source.html#l06427">close()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l01255">open_output()</a>, and <a class="el" href="ffmpeg__transcoder_8cc_source.html#l05490">start_new_segment()</a>.</p>

</div>
</div>
<a id="aaf6945c2faeb27af1db8a75ef3d52efd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf6945c2faeb27af1db8a75ef3d52efd">&#9670;&nbsp;</a></span>close_resample()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool FFmpeg_Transcoder::close_resample </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Close and free the resampler context. </p>
<dl class="section return"><dt>Returns</dt><dd>If an open context was closed, returns true; if nothing had been done returns false. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ffmpeg__transcoder_8cc_source.html#l06260">6260</a> of file <a class="el" href="ffmpeg__transcoder_8cc_source.html">ffmpeg_transcoder.cc</a>.</p>

<p class="reference">References <a class="el" href="ffmpeg__transcoder_8h_source.html#l01205">m_audio_resample_ctx</a>.</p>

<p class="reference">Referenced by <a class="el" href="ffmpeg__transcoder_8cc_source.html#l06343">close_output_file()</a>, and <a class="el" href="ffmpeg__transcoder_8cc_source.html#l02793">init_resampler()</a>.</p>

</div>
</div>
<a id="ada3ad7eef000399122463376320acb54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada3ad7eef000399122463376320acb54">&#9670;&nbsp;</a></span>convert_samples()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int FFmpeg_Transcoder::convert_samples </td>
          <td>(</td>
          <td class="paramtype">uint8_t **&#160;</td>
          <td class="paramname"><em>input_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>in_samples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t **&#160;</td>
          <td class="paramname"><em>converted_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>out_samples</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert the input audio samples into the output sample format. The conversion happens on a per-frame basis, the size of which is specified by frame_size. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input_data</td><td>- Input data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">in_samples</td><td>- Number of input samples. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">converted_data</td><td>- Converted data. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out_samples</td><td>- Number of output samples </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, returns 0; on error, a negative AVERROR value. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ffmpeg__transcoder_8cc_source.html#l03940">3940</a> of file <a class="el" href="ffmpeg__transcoder_8cc_source.html">ffmpeg_transcoder.cc</a>.</p>

<p class="reference">References <a class="el" href="logging_8h_source.html#l00237">Logging::error()</a>, <a class="el" href="ffmpeg__utils_8cc_source.html#l01139">ffmpeg_geterror()</a>, <a class="el" href="ffmpeg__base_8cc_source.html#l00332">FFmpeg_Base::get_channels()</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l00140">FFmpeg_Transcoder::INPUTFILE::m_audio</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l01205">m_audio_resample_ctx</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l00120">FFmpeg_Transcoder::StreamRef::m_codec_ctx</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l01217">m_in</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l01218">m_out</a>, and <a class="el" href="ffmpeg__transcoder_8cc_source.html#l06458">virtname()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ffmpeg__transcoder_8cc_source.html#l03251">decode_audio_frame()</a>.</p>

</div>
</div>
<a id="a737ed97af13b2c5324aadb8f4ffa3ca3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a737ed97af13b2c5324aadb8f4ffa3ca3">&#9670;&nbsp;</a></span>copy_audio_to_frame_buffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int FFmpeg_Transcoder::copy_audio_to_frame_buffer </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>finished</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy data from audio FIFO to frame buffer. Divides WAV data into proper chunks to be fed into the encoder. </p>
<dl class="section return"><dt>Returns</dt><dd>On success, returns 0; on error, a negative AVERROR value. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ffmpeg__transcoder_8cc_source.html#l05146">5146</a> of file <a class="el" href="ffmpeg__transcoder_8cc_source.html">ffmpeg_transcoder.cc</a>.</p>

<p class="reference">References <a class="el" href="ffmpeg__utils_8h_source.html#l00140">AV_CODEC_CAP_VARIABLE_FRAME_SIZE</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l04758">create_audio_frame()</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l00140">FFmpeg_Transcoder::INPUTFILE::m_audio</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l01206">m_audio_fifo</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l00120">FFmpeg_Transcoder::StreamRef::m_codec_ctx</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l01218">m_out</a>, and <a class="el" href="ffmpeg__transcoder_8cc_source.html#l04095">read_decode_convert_and_store()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ffmpeg__transcoder_8cc_source.html#l05210">process_single_fr()</a>.</p>

</div>
</div>
<a id="a59c121eb236f4843a42c8b9bd8092089"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59c121eb236f4843a42c8b9bd8092089">&#9670;&nbsp;</a></span>copy_metadata()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void FFmpeg_Transcoder::copy_metadata </td>
          <td>(</td>
          <td class="paramtype">AVDictionary **&#160;</td>
          <td class="paramname"><em>metadata_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AVDictionary *&#160;</td>
          <td class="paramname"><em>metadata_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>contentstream</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Process the metadata in the FFmpeg file. This should be called at the beginning, before reading audio data. The set_text_tag() and set_picture_tag() methods of the given Encoder will be used to set the metadata, with results going into the given <a class="el" href="classBuffer.html" title="The Buffer class.">Buffer</a>. This function will also read the actual PCM stream parameters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">metadata_out</td><td>- Dictionary of output file. Metadata will be copied into it. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">metadata_in</td><td>- Dictionary of input file. Metadata will be copied out of it. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">contentstream</td><td>- True if this is a content stream, i.e, audio or video. False for album arts or sub titles. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="ffmpeg__transcoder_8cc_source.html#l04861">4861</a> of file <a class="el" href="ffmpeg__transcoder_8cc_source.html">ffmpeg_transcoder.cc</a>.</p>

<p class="reference">References <a class="el" href="ffmpeg__base_8cc_source.html#l00173">FFmpeg_Base::dict_set_with_check()</a>, <a class="el" href="fileio_8h_source.html#l00228">VIRTUALFILE::CUESHEET_TRACK::m_artist</a>, <a class="el" href="structVIRTUALFILE.html#ac05832e00e22fb501023551962d2879c">VIRTUALFILE::m_cuesheet_track</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l00136">FFmpeg_Transcoder::INPUTFILE::m_filetype</a>, <a class="el" href="fileio_8h_source.html#l00143">VIRTUALFILE::m_flags</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l01218">m_out</a>, <a class="el" href="fileio_8h_source.html#l00229">VIRTUALFILE::CUESHEET_TRACK::m_title</a>, <a class="el" href="fileio_8h_source.html#l00227">VIRTUALFILE::CUESHEET_TRACK::m_trackno</a>, <a class="el" href="ffmpeg__base_8h_source.html#l00280">FFmpeg_Base::m_virtualfile</a>, <a class="el" href="ffmpeg__utils_8cc_source.html#l01850">strcasecmp()</a>, <a class="el" href="ffmpeg__utils_8h_source.html#l00738">strsprintf()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l06458">virtname()</a>, and <a class="el" href="fileio_8h_source.html#l00113">VIRTUALFLAG_CUESHEET</a>.</p>

<p class="reference">Referenced by <a class="el" href="ffmpeg__transcoder_8cc_source.html#l04919">process_metadata()</a>.</p>

</div>
</div>
<a id="a9e1b9748cf1e7d04dfebd847f6351ab0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e1b9748cf1e7d04dfebd847f6351ab0">&#9670;&nbsp;</a></span>create_audio_frame()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int FFmpeg_Transcoder::create_audio_frame </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>frame_size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Load one audio frame from the FIFO buffer and store in frame buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">frame_size</td><td>- Size of frame. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, returns 0. On error, returns a negative AVERROR value. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ffmpeg__transcoder_8cc_source.html#l04758">4758</a> of file <a class="el" href="ffmpeg__transcoder_8cc_source.html">ffmpeg_transcoder.cc</a>.</p>

<p class="reference">References <a class="el" href="ffmpeg__transcoder_8cc_source.html#l06118">duration()</a>, <a class="el" href="logging_8h_source.html#l00237">Logging::error()</a>, <a class="el" href="ffmpeg__utils_8cc_source.html#l01139">ffmpeg_geterror()</a>, <a class="el" href="ffmpeg__utils_8cc_source.html#l01153">ffmpeg_rescale_q()</a>, <a class="el" href="ffmpeg__utils_8cc_source.html#l01168">ffmpeg_rescale_q_rnd()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l04166">init_audio_output_frame()</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l00140">FFmpeg_Transcoder::INPUTFILE::m_audio</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l01206">m_audio_fifo</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l00159">FFmpeg_Transcoder::OUTPUTFILE::m_audio_pts</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l01195">m_frame_map</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l01217">m_in</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l01218">m_out</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l00123">FFmpeg_Transcoder::StreamRef::m_start_time</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l00121">FFmpeg_Transcoder::StreamRef::m_stream</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l00122">FFmpeg_Transcoder::StreamRef::m_stream_idx</a>, <a class="el" href="ffmpeg__frame_8cc_source.html#l00117">FFmpeg_Frame::res()</a>, and <a class="el" href="ffmpeg__transcoder_8cc_source.html#l06458">virtname()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ffmpeg__transcoder_8cc_source.html#l05146">copy_audio_to_frame_buffer()</a>.</p>

</div>
</div>
<a id="a76260344c9be1c9e617ca6aedb3e0926"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76260344c9be1c9e617ca6aedb3e0926">&#9670;&nbsp;</a></span>create_fake_aiff_header()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int FFmpeg_Transcoder::create_fake_aiff_header </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a fake AIFF header Create a fake AIFF header. Inserts predicted file sizes to allow playback to start directly. </p>
<dl class="section return"><dt>Returns</dt><dd>0 on success, a negative AVERROR code on failure. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ffmpeg__transcoder_8cc_source.html#l03080">3080</a> of file <a class="el" href="ffmpeg__transcoder_8cc_source.html">ffmpeg_transcoder.cc</a>.</p>

<p class="reference">References <a class="el" href="aiff_8h_source.html#l00066">AIFF_COMMONID</a>, <a class="el" href="aiff_8h_source.html#l00044">AIFF_FORMID</a>, <a class="el" href="aiff_8h_source.html#l00080">AIFF_SOUNDATAID</a>, <a class="el" href="aiff_8h_source.html#l00051">AIFF_FORMCHUNK::m_ckSize</a>, <a class="el" href="aiff_8h_source.html#l00087">AIFF_SOUNDDATACHUNK::m_ckSize</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l00138">FFmpeg_Transcoder::INPUTFILE::m_format_ctx</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l01218">m_out</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l06123">predicted_filesize()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l03035">read_aiff_chunk()</a>, <a class="el" href="buffer_8cc_source.html#l00742">Buffer::seek()</a>, <a class="el" href="buffer_8cc_source.html#l00799">Buffer::tell()</a>, and <a class="el" href="buffer_8cc_source.html#l00642">Buffer::write()</a>.</p>

</div>
</div>
<a id="aaeb89d7207eeb67eb0a6720e68544182"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaeb89d7207eeb67eb0a6720e68544182">&#9670;&nbsp;</a></span>create_fake_wav_header()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int FFmpeg_Transcoder::create_fake_wav_header </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a fake WAV header Create a fake WAV header. Inserts predicted file sizes to allow playback to start directly. </p>
<dl class="section return"><dt>Returns</dt><dd>0 on success, a negative AVERROR code on failure. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ffmpeg__transcoder_8cc_source.html#l02977">2977</a> of file <a class="el" href="ffmpeg__transcoder_8cc_source.html">ffmpeg_transcoder.cc</a>.</p>

<p class="reference">References <a class="el" href="buffer_8cc_source.html#l00853">Buffer::copy()</a>, <a class="el" href="wave_8h_source.html#l00068">WAV_HEADER::m_audio_format</a>, <a class="el" href="wave_8h_source.html#l00097">WAV_FACT::m_chunk_id</a>, <a class="el" href="wave_8h_source.html#l00110">WAV_LIST_HEADER::m_data_bytes</a>, <a class="el" href="wave_8h_source.html#l00121">WAV_DATA_HEADER::m_data_bytes</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l00138">FFmpeg_Transcoder::INPUTFILE::m_format_ctx</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l01218">m_out</a>, <a class="el" href="wave_8h_source.html#l00061">WAV_HEADER::m_wav_size</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l06123">predicted_filesize()</a>, <a class="el" href="buffer_8cc_source.html#l00742">Buffer::seek()</a>, <a class="el" href="buffer_8cc_source.html#l00799">Buffer::tell()</a>, and <a class="el" href="buffer_8cc_source.html#l00642">Buffer::write()</a>.</p>

</div>
</div>
<a id="a845c52b18f172428a2ee79d6348a865e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a845c52b18f172428a2ee79d6348a865e">&#9670;&nbsp;</a></span>decode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int FFmpeg_Transcoder::decode </td>
          <td>(</td>
          <td class="paramtype">AVCodecContext *&#160;</td>
          <td class="paramname"><em>codec_ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AVFrame *&#160;</td>
          <td class="paramname"><em>frame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>got_frame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AVPacket *&#160;</td>
          <td class="paramname"><em>pkt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This does not quite work like avcodec_decode_audio4/avcodec_decode_video2. There is the following difference: if you got a frame, you must call it again with pkt=nullptr. pkt==nullptr is treated differently from pkt-&gt;size==0 (pkt==nullptr means get more output, pkt-&gt;size==0 is a flush/drain packet) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">codec_ctx</td><td>- AVCodecContext of input stream. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">frame</td><td>- Decoded frame </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">got_frame</td><td>- 1 if a frame was decoded, 0 if not </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pkt</td><td>- Packet to decode </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, returns 0. On error, returns a negative AVERROR value. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Only after the first hardware decoded video packet arrived we have a </dd>
<dd>
hardware frame context. </dd>
<dd>
We should create the output stream now, open a codec etc. and call </dd>
<dd>
hwframe_ctx_set.</dd></dl>

<p class="definition">Definition at line <a class="el" href="ffmpeg__transcoder_8cc_source.html#l03197">3197</a> of file <a class="el" href="ffmpeg__transcoder_8cc_source.html">ffmpeg_transcoder.cc</a>.</p>

<p class="reference">References <a class="el" href="logging_8h_source.html#l00237">Logging::error()</a>, <a class="el" href="ffmpeg__utils_8cc_source.html#l01139">ffmpeg_geterror()</a>, <a class="el" href="ffmpeg__utils_8cc_source.html#l01153">ffmpeg_rescale_q()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l06448">filename()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l07470">is_audio_stream()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l07475">is_video_stream()</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l00140">FFmpeg_Transcoder::INPUTFILE::m_audio</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l01217">m_in</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l01218">m_out</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l00121">FFmpeg_Transcoder::StreamRef::m_stream</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l00122">FFmpeg_Transcoder::StreamRef::m_stream_idx</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l00141">FFmpeg_Transcoder::INPUTFILE::m_video</a>, and <a class="el" href="ffmpeg__transcoder_8cc_source.html#l07499">stream_exists()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ffmpeg__transcoder_8cc_source.html#l03251">decode_audio_frame()</a>, and <a class="el" href="ffmpeg__transcoder_8cc_source.html#l03354">decode_video_frame()</a>.</p>

</div>
</div>
<a id="ab26699456ab881329e1ca9aebae74ba5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab26699456ab881329e1ca9aebae74ba5">&#9670;&nbsp;</a></span>decode_audio_frame()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int FFmpeg_Transcoder::decode_audio_frame </td>
          <td>(</td>
          <td class="paramtype">AVPacket *&#160;</td>
          <td class="paramname"><em>pkt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>decoded</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decode one audio frame. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pkt</td><td>- Packet to decode. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">decoded</td><td>- 1 if packet was decoded, 0 if it did not contain data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, returns 0; on error, a negative AVERROR value. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ffmpeg__transcoder_8cc_source.html#l03251">3251</a> of file <a class="el" href="ffmpeg__transcoder_8cc_source.html">ffmpeg_transcoder.cc</a>.</p>

<p class="reference">References <a class="el" href="ffmpeg__transcoder_8cc_source.html#l03980">add_samples_to_fifo()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l03940">convert_samples()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l03197">decode()</a>, <a class="el" href="logging_8h_source.html#l00237">Logging::error()</a>, <a class="el" href="ffmpeg__utils_8cc_source.html#l01139">ffmpeg_geterror()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l06448">filename()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l03908">init_converted_samples()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l02793">init_resampler()</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l00140">FFmpeg_Transcoder::INPUTFILE::m_audio</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l01205">m_audio_resample_ctx</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l00120">FFmpeg_Transcoder::StreamRef::m_codec_ctx</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l01217">m_in</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l01218">m_out</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l00122">FFmpeg_Transcoder::StreamRef::m_stream_idx</a>, and <a class="el" href="ffmpeg__frame_8cc_source.html#l00117">FFmpeg_Frame::res()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ffmpeg__transcoder_8cc_source.html#l03740">decode_frame()</a>, and <a class="el" href="ffmpeg__transcoder_8cc_source.html#l04037">flush_frames_single()</a>.</p>

</div>
</div>
<a id="a96c31a851e95a6fb714b2908c83ec696"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96c31a851e95a6fb714b2908c83ec696">&#9670;&nbsp;</a></span>decode_frame()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int FFmpeg_Transcoder::decode_frame </td>
          <td>(</td>
          <td class="paramtype">AVPacket *&#160;</td>
          <td class="paramname"><em>pkt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decode one frame. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pkt</td><td>- Packet to decode. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, returns 0; on error, a negative AVERROR value. </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000011">Todo:</a></b></dt><dd>Calling decode_video_frame until all data has been used, but for DVDs only. Can someone tell me why this seems required??? If this is not done some videos become garbled. But only for DVDs... <br  />
<br  />
With fix: all DVDs OK, some Blurays (e.g. Phil Collins) not... <br  />
With fix: all DVDs shitty, but Blurays OK. <br  />
<br  />
Applying fix for DVDs only. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ffmpeg__transcoder_8cc_source.html#l03740">3740</a> of file <a class="el" href="ffmpeg__transcoder_8cc_source.html">ffmpeg_transcoder.cc</a>.</p>

<p class="reference">References <a class="el" href="ffmpeg__transcoder_8cc_source.html#l02565">add_albumart_frame()</a>, <a class="el" href="logging_8h_source.html#l00180">Logging::debug()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l03251">decode_audio_frame()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l03564">decode_subtitle()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l03354">decode_video_frame()</a>, <a class="el" href="logging_8h_source.html#l00237">Logging::error()</a>, <a class="el" href="ffmpeg__utils_8cc_source.html#l01139">ffmpeg_geterror()</a>, <a class="el" href="ffmpeg__utils_8cc_source.html#l01153">ffmpeg_rescale_q()</a>, <a class="el" href="ffmpeg__utils_8cc_source.html#l01168">ffmpeg_rescale_q_rnd()</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l01248">FFMPEGFS_AUDIO</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l01249">FFMPEGFS_VIDEO</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l06448">filename()</a>, <a class="el" href="ffmpeg__utils_8cc_source.html#l01553">format_duration()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l07470">is_audio_stream()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l06732">is_frameset()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l07480">is_subtitle_stream()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l07475">is_video_stream()</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l00145">FFmpeg_Transcoder::INPUTFILE::m_album_art</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l00140">FFmpeg_Transcoder::INPUTFILE::m_audio</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l00159">FFmpeg_Transcoder::OUTPUTFILE::m_audio_pts</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l01225">m_copy_audio</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l01226">m_copy_video</a>, <a class="el" href="ffmpegfs_8h_source.html#l00246">FFMPEGFS_PARAMS::m_decoding_errors</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l00138">FFmpeg_Transcoder::INPUTFILE::m_format_ctx</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l01217">m_in</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l01218">m_out</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l01232">m_reset_pts</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l00121">FFmpeg_Transcoder::StreamRef::m_stream</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l00122">FFmpeg_Transcoder::StreamRef::m_stream_idx</a>, <a class="el" href="fileio_8h_source.html#l00142">VIRTUALFILE::m_type</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l00141">FFmpeg_Transcoder::INPUTFILE::m_video</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l00160">FFmpeg_Transcoder::OUTPUTFILE::m_video_pts</a>, <a class="el" href="ffmpeg__base_8h_source.html#l00280">FFmpeg_Base::m_virtualfile</a>, <a class="el" href="ffmpegfs_8cc_source.html#l00072">params</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l03634">store_packet()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l07499">stream_exists()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l06458">virtname()</a>, and <a class="el" href="fileio_8h_source.html#l00096">VIRTUALTYPE_DVD</a>.</p>

<p class="reference">Referenced by <a class="el" href="ffmpeg__transcoder_8cc_source.html#l04095">read_decode_convert_and_store()</a>.</p>

</div>
</div>
<a id="af8ab9f0b9a15115445e4e10ac89be0d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8ab9f0b9a15115445e4e10ac89be0d2">&#9670;&nbsp;</a></span>decode_subtitle() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int FFmpeg_Transcoder::decode_subtitle </td>
          <td>(</td>
          <td class="paramtype">AVCodecContext *&#160;</td>
          <td class="paramname"><em>codec_ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AVPacket *&#160;</td>
          <td class="paramname"><em>pkt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>decoded</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>out_stream_idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decode one subtitle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">codec_ctx</td><td>- AVCodecContext object of output codec context. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pkt</td><td>- Packet to decode. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">decoded</td><td>- 1 if packet was decoded, 0 if it did not contain data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">out_stream_idx</td><td>- Output stream index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, returns 0; on error, a negative AVERROR value. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ffmpeg__transcoder_8cc_source.html#l03596">3596</a> of file <a class="el" href="ffmpeg__transcoder_8cc_source.html">ffmpeg_transcoder.cc</a>.</p>

<p class="reference">References <a class="el" href="logging_8h_source.html#l00237">Logging::error()</a>, <a class="el" href="ffmpeg__utils_8cc_source.html#l01139">ffmpeg_geterror()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l06448">filename()</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l01195">m_frame_map</a>, and <a class="el" href="ffmpeg__subtitle_8cc_source.html#l00061">FFmpeg_Subtitle::res()</a>.</p>

</div>
</div>
<a id="a466c279d789c324cefa274f1a60e1033"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a466c279d789c324cefa274f1a60e1033">&#9670;&nbsp;</a></span>decode_subtitle() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int FFmpeg_Transcoder::decode_subtitle </td>
          <td>(</td>
          <td class="paramtype">AVPacket *&#160;</td>
          <td class="paramname"><em>pkt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>decoded</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decode one subtitle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pkt</td><td>- Packet to decode. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">decoded</td><td>- 1 if packet was decoded, 0 if it did not contain data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, returns 0; on error, a negative AVERROR value. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ffmpeg__transcoder_8cc_source.html#l03564">3564</a> of file <a class="el" href="ffmpeg__transcoder_8cc_source.html">ffmpeg_transcoder.cc</a>.</p>

<p class="reference">References <a class="el" href="logging_8h_source.html#l00237">Logging::error()</a>, <a class="el" href="ffmpeg__utils_8cc_source.html#l01139">ffmpeg_geterror()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l06448">filename()</a>, <a class="el" href="ffmpeg__utils_8h_source.html#l00074">INVALID_STREAM</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l01217">m_in</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l00143">FFmpeg_Transcoder::INPUTFILE::m_subtitle</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l07512">map_in_to_out_stream()</a>, and <a class="el" href="ffmpeg__transcoder_8cc_source.html#l06458">virtname()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ffmpeg__transcoder_8cc_source.html#l07590">add_external_subtitle_stream()</a>, and <a class="el" href="ffmpeg__transcoder_8cc_source.html#l03740">decode_frame()</a>.</p>

</div>
</div>
<a id="a45d6501228351ff6407f0af09596d09f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45d6501228351ff6407f0af09596d09f">&#9670;&nbsp;</a></span>decode_video_frame()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int FFmpeg_Transcoder::decode_video_frame </td>
          <td>(</td>
          <td class="paramtype">AVPacket *&#160;</td>
          <td class="paramname"><em>pkt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>decoded</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decode one video frame. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pkt</td><td>- Packet to decode. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">decoded</td><td>- 1 if packet was decoded, 0 if it did not contain data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, returns 0; on error, a negative AVERROR value. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ffmpeg__transcoder_8cc_source.html#l03354">3354</a> of file <a class="el" href="ffmpeg__transcoder_8cc_source.html">ffmpeg_transcoder.cc</a>.</p>

<p class="reference">References <a class="el" href="ffmpeg__transcoder_8cc_source.html#l03178">alloc_picture()</a>, <a class="el" href="logging_8h_source.html#l00180">Logging::debug()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l03197">decode()</a>, <a class="el" href="logging_8h_source.html#l00237">Logging::error()</a>, <a class="el" href="ffmpeg__utils_8cc_source.html#l01139">ffmpeg_geterror()</a>, <a class="el" href="ffmpeg__utils_8cc_source.html#l01168">ffmpeg_rescale_q_rnd()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l06448">filename()</a>, <a class="el" href="ffmpeg__utils_8cc_source.html#l01553">format_duration()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l07460">get_next_segment()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l07465">goto_next_segment()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l06744">is_hls()</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l00120">FFmpeg_Transcoder::StreamRef::m_codec_ctx</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l01195">m_frame_map</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l01242">m_hwaccel_enable_dec_buffering</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l01217">m_in</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l01222">m_insert_keyframe</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l01218">m_out</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l00142">FFmpeg_Transcoder::INPUTFILE::m_pix_fmt</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l01214">m_pos</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l01213">m_pts</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l00123">FFmpeg_Transcoder::StreamRef::m_start_time</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l00121">FFmpeg_Transcoder::StreamRef::m_stream</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l00122">FFmpeg_Transcoder::StreamRef::m_stream_idx</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l01209">m_sws_ctx</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l00141">FFmpeg_Transcoder::INPUTFILE::m_video</a>, <a class="el" href="ffmpeg__frame_8cc_source.html#l00117">FFmpeg_Frame::res()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l06609">send_filters()</a>, and <a class="el" href="ffmpeg__transcoder_8cc_source.html#l06458">virtname()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ffmpeg__transcoder_8cc_source.html#l03740">decode_frame()</a>, and <a class="el" href="ffmpeg__transcoder_8cc_source.html#l04037">flush_frames_single()</a>.</p>

</div>
</div>
<a id="aa21bee00bb4def2325d179dc1198beba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa21bee00bb4def2325d179dc1198beba">&#9670;&nbsp;</a></span>destname()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char * FFmpeg_Transcoder::destname </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return destination filename. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns filename. </dd></dl>

<p>Implements <a class="el" href="classFFmpeg__Base.html#a9f4f1cccd0202b75972f925cc63913bf">FFmpeg_Base</a>.</p>

<p class="definition">Definition at line <a class="el" href="ffmpeg__transcoder_8cc_source.html#l06453">6453</a> of file <a class="el" href="ffmpeg__transcoder_8cc_source.html">ffmpeg_transcoder.cc</a>.</p>

<p class="reference">References <a class="el" href="fileio_8h_source.html#l00146">VIRTUALFILE::m_destfile</a>, and <a class="el" href="ffmpeg__base_8h_source.html#l00280">FFmpeg_Base::m_virtualfile</a>.</p>

</div>
</div>
<a id="a83770fa583f1d2efc214c4affdbf3687"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83770fa583f1d2efc214c4affdbf3687">&#9670;&nbsp;</a></span>do_seek_frame()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int FFmpeg_Transcoder::do_seek_frame </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>frame_no</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Actually perform seek for frame. This function ensures that it is positioned at a key frame, so the resulting position may be different from the requested. If e.g. frame no. 24 is a key frame, and frame_no is set to 28, the actual position will be at frame 24. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">frame_no</td><td>- Frame number 1...n to seek to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 if OK, or negative AVERROR value. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ffmpeg__transcoder_8cc_source.html#l05006">5006</a> of file <a class="el" href="ffmpeg__transcoder_8cc_source.html">ffmpeg_transcoder.cc</a>.</p>

<p class="reference">References <a class="el" href="ffmpeg__base_8cc_source.html#l00325">FFmpeg_Base::frame_to_pts()</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l00138">FFmpeg_Transcoder::INPUTFILE::m_format_ctx</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l01191">m_have_seeked</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l01217">m_in</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l01192">m_skip_next_frame</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l00121">FFmpeg_Transcoder::StreamRef::m_stream</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l00122">FFmpeg_Transcoder::StreamRef::m_stream_idx</a>, and <a class="el" href="ffmpeg__transcoder_8h_source.html#l00141">FFmpeg_Transcoder::INPUTFILE::m_video</a>.</p>

<p class="reference">Referenced by <a class="el" href="ffmpeg__transcoder_8cc_source.html#l05027">skip_decoded_frames()</a>.</p>

</div>
</div>
<a id="acbb7051543ede55afe8eae8c8ab345dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbb7051543ede55afe8eae8c8ab345dd">&#9670;&nbsp;</a></span>duration()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t FFmpeg_Transcoder::duration </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the file duration. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the file in AV_TIME_BASE units. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ffmpeg__transcoder_8cc_source.html#l06118">6118</a> of file <a class="el" href="ffmpeg__transcoder_8cc_source.html">ffmpeg_transcoder.cc</a>.</p>

<p class="reference">References <a class="el" href="ffmpeg__base_8h_source.html#l00280">FFmpeg_Base::m_virtualfile</a>, and <a class="el" href="ffmpeg__utils_8h_source.html#l00152">SAFE_VALUE</a>.</p>

<p class="reference">Referenced by <a class="el" href="ffmpeg__transcoder_8cc_source.html#l05695">audio_size()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l06046">calculate_predicted_filesize()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l04758">create_audio_frame()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l04205">produce_audio_dts()</a>, <a class="el" href="transcode_8cc_source.html#l00155">transcode_finish()</a>, <a class="el" href="transcode_8cc_source.html#l00329">transcoder_predict_filesize()</a>, <a class="el" href="transcode_8cc_source.html#l00770">transcoder_thread()</a>, and <a class="el" href="ffmpeg__transcoder_8cc_source.html#l05887">video_size()</a>.</p>

</div>
</div>
<a id="affc23e2d1591fa27090622c217a7e3fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affc23e2d1591fa27090622c217a7e3fd">&#9670;&nbsp;</a></span>encode_audio_frame()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int FFmpeg_Transcoder::encode_audio_frame </td>
          <td>(</td>
          <td class="paramtype">const AVFrame *&#160;</td>
          <td class="paramname"><em>frame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>data_present</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create one frame worth of audio to the output file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">frame</td><td>- Audio frame to encode </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data_present</td><td>- 1 if frame contained data that could be encoded, 0 if not. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, returns 0. On error, returns a negative AVERROR value. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ffmpeg__transcoder_8cc_source.html#l04245">4245</a> of file <a class="el" href="ffmpeg__transcoder_8cc_source.html">ffmpeg_transcoder.cc</a>.</p>

<p class="reference">References <a class="el" href="logging_8h_source.html#l00237">Logging::error()</a>, <a class="el" href="ffmpeg__utils_8cc_source.html#l01139">ffmpeg_geterror()</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l00140">FFmpeg_Transcoder::INPUTFILE::m_audio</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l00120">FFmpeg_Transcoder::StreamRef::m_codec_ctx</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l01218">m_out</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l00122">FFmpeg_Transcoder::StreamRef::m_stream_idx</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l04205">produce_audio_dts()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l03634">store_packet()</a>, and <a class="el" href="ffmpeg__transcoder_8cc_source.html#l06458">virtname()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ffmpeg__transcoder_8cc_source.html#l05073">flush_delayed_audio()</a>, and <a class="el" href="ffmpeg__transcoder_8cc_source.html#l05210">process_single_fr()</a>.</p>

</div>
</div>
<a id="a521bb83e1e6862028fc272e1667355f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a521bb83e1e6862028fc272e1667355f7">&#9670;&nbsp;</a></span>encode_finish()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int FFmpeg_Transcoder::encode_finish </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Encode any remaining PCM data to the given buffer. This should be called after all input data has already been passed to encode_pcm_data(). </p><dl class="section return"><dt>Returns</dt><dd>On success, returns 0; on error, a negative AVERROR value. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ffmpeg__transcoder_8cc_source.html#l06138">6138</a> of file <a class="el" href="ffmpeg__transcoder_8cc_source.html">ffmpeg_transcoder.cc</a>.</p>

<p class="reference">References <a class="el" href="buffer_8cc_source.html#l00840">Buffer::buffer_watermark()</a>, <a class="el" href="ffmpegfs_8cc_source.html#l00233">FFMPEGFS_PARAMS::current_format()</a>, <a class="el" href="ffmpeg__utils_8cc_source.html#l00902">FFmpegfs_Format::fileext()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l06448">filename()</a>, <a class="el" href="fuseops_8cc_source.html#l01762">find_file()</a>, <a class="el" href="buffer_8cc_source.html#l01049">Buffer::finished_segment()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l06732">is_frameset()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l06744">is_hls()</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l01230">m_buffer</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l01221">m_current_segment</a>, <a class="el" href="fileio_8h_source.html#l00146">VIRTUALFILE::m_destfile</a>, <a class="el" href="fileio_8h_source.html#l00153">VIRTUALFILE::m_predicted_size</a>, <a class="el" href="fileio_8h_source.html#l00149">VIRTUALFILE::m_st</a>, <a class="el" href="ffmpeg__base_8h_source.html#l00280">FFmpeg_Base::m_virtualfile</a>, <a class="el" href="ffmpeg__utils_8cc_source.html#l02087">make_filename()</a>, <a class="el" href="ffmpegfs_8cc_source.html#l00072">params</a>, <a class="el" href="ffmpeg__utils_8cc_source.html#l02402">stat_set_size()</a>, <a class="el" href="fileio_8cc_source.html#l00116">FileIO::virtualfile()</a>, and <a class="el" href="ffmpeg__transcoder_8cc_source.html#l04834">write_output_file_trailer()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ffmpeg__transcoder_8cc_source.html#l05490">start_new_segment()</a>, and <a class="el" href="transcode_8cc_source.html#l00155">transcode_finish()</a>.</p>

</div>
</div>
<a id="a892362d764d2d5170da31069ac41aaca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a892362d764d2d5170da31069ac41aaca">&#9670;&nbsp;</a></span>encode_image_frame()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int FFmpeg_Transcoder::encode_image_frame </td>
          <td>(</td>
          <td class="paramtype">const AVFrame *&#160;</td>
          <td class="paramname"><em>frame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>data_present</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Encode frame to image. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">frame</td><td>- Video frame to encode </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">data_present</td><td>- Set to 1 if data was encoded. 0 if not. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, returns 0. On error, returns a negative AVERROR value. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ffmpeg__transcoder_8cc_source.html#l04323">4323</a> of file <a class="el" href="ffmpeg__transcoder_8cc_source.html">ffmpeg_transcoder.cc</a>.</p>

<p class="reference">References <a class="el" href="logging_8h_source.html#l00237">Logging::error()</a>, <a class="el" href="ffmpeg__utils_8cc_source.html#l01139">ffmpeg_geterror()</a>, <a class="el" href="ffmpeg__base_8cc_source.html#l00325">FFmpeg_Base::frame_to_pts()</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l01230">m_buffer</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l00120">FFmpeg_Transcoder::StreamRef::m_codec_ctx</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l01228">m_current_format</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l01233">m_fake_frame_no</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l01217">m_in</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l01190">m_last_seek_frame_no</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l01218">m_out</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l01192">m_skip_next_frame</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l00121">FFmpeg_Transcoder::StreamRef::m_stream</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l00141">FFmpeg_Transcoder::INPUTFILE::m_video</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l00160">FFmpeg_Transcoder::OUTPUTFILE::m_video_pts</a>, <a class="el" href="ffmpeg__base_8cc_source.html#l00314">FFmpeg_Base::pts_to_frame()</a>, <a class="el" href="ffmpeg__frame_8cc_source.html#l00117">FFmpeg_Frame::res()</a>, <a class="el" href="ffmpeg__utils_8cc_source.html#l00932">FFmpegfs_Format::video_codec()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l06458">virtname()</a>, and <a class="el" href="buffer_8cc_source.html#l00666">Buffer::write_frame()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ffmpeg__transcoder_8cc_source.html#l05103">flush_delayed_video()</a>, and <a class="el" href="ffmpeg__transcoder_8cc_source.html#l05210">process_single_fr()</a>.</p>

</div>
</div>
<a id="afe2f336556333467127884b153abc844"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe2f336556333467127884b153abc844">&#9670;&nbsp;</a></span>encode_subtitle()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int FFmpeg_Transcoder::encode_subtitle </td>
          <td>(</td>
          <td class="paramtype">const AVSubtitle *&#160;</td>
          <td class="paramname"><em>sub</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>out_stream_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>data_present</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Encode one subtitle frame to the output file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sub</td><td>- Subtitle frame to encode </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">out_stream_idx</td><td>- Index of stream to encode to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data_present</td><td>- 1 if frame contained data that could be encoded, 0 if not. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, returns 0. On error, returns a negative AVERROR value. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ffmpeg__transcoder_8cc_source.html#l04620">4620</a> of file <a class="el" href="ffmpeg__transcoder_8cc_source.html">ffmpeg_transcoder.cc</a>.</p>

<p class="reference">References <a class="el" href="logging_8h_source.html#l00237">Logging::error()</a>, <a class="el" href="ffmpeg__utils_8cc_source.html#l01139">ffmpeg_geterror()</a>, <a class="el" href="ffmpeg__utils_8cc_source.html#l01153">ffmpeg_rescale_q()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l07487">get_out_subtitle_stream()</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l00120">FFmpeg_Transcoder::StreamRef::m_codec_ctx</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l00121">FFmpeg_Transcoder::StreamRef::m_stream</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l00122">FFmpeg_Transcoder::StreamRef::m_stream_idx</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l03634">store_packet()</a>, and <a class="el" href="ffmpeg__transcoder_8cc_source.html#l06458">virtname()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ffmpeg__transcoder_8cc_source.html#l05210">process_single_fr()</a>.</p>

</div>
</div>
<a id="a67f31ad62ffd89e4ea45a357bc8a746a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67f31ad62ffd89e4ea45a357bc8a746a">&#9670;&nbsp;</a></span>encode_video_frame()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int FFmpeg_Transcoder::encode_video_frame </td>
          <td>(</td>
          <td class="paramtype">const AVFrame *&#160;</td>
          <td class="paramname"><em>frame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>data_present</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Encode one frame worth of video to the output file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">frame</td><td>- Video frame to encode </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data_present</td><td>- 1 if frame contained data that could be encoded, 0 if not. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, returns 0. On error, returns a negative AVERROR value. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ffmpeg__transcoder_8cc_source.html#l04440">4440</a> of file <a class="el" href="ffmpeg__transcoder_8cc_source.html">ffmpeg_transcoder.cc</a>.</p>

<p class="reference">References <a class="el" href="logging_8h_source.html#l00237">Logging::error()</a>, <a class="el" href="ffmpeg__utils_8cc_source.html#l01139">ffmpeg_geterror()</a>, <a class="el" href="ffmpeg__utils_8cc_source.html#l01153">ffmpeg_rescale_q()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l06968">hwframe_copy_to_hw()</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l00120">FFmpeg_Transcoder::StreamRef::m_codec_ctx</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l00138">FFmpeg_Transcoder::INPUTFILE::m_format_ctx</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l01241">m_hwaccel_enable_enc_buffering</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l01217">m_in</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l00161">FFmpeg_Transcoder::OUTPUTFILE::m_last_mux_dts</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l01218">m_out</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l00121">FFmpeg_Transcoder::StreamRef::m_stream</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l00122">FFmpeg_Transcoder::StreamRef::m_stream_idx</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l00141">FFmpeg_Transcoder::INPUTFILE::m_video</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l00160">FFmpeg_Transcoder::OUTPUTFILE::m_video_pts</a>, <a class="el" href="ffmpeg__frame_8cc_source.html#l00117">FFmpeg_Frame::res()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l03634">store_packet()</a>, <a class="el" href="logging_8h_source.html#l00161">Logging::trace()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l06458">virtname()</a>, and <a class="el" href="logging_8h_source.html#l00218">Logging::warning()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ffmpeg__transcoder_8cc_source.html#l05103">flush_delayed_video()</a>, and <a class="el" href="ffmpeg__transcoder_8cc_source.html#l05210">process_single_fr()</a>.</p>

</div>
</div>
<a id="a14a05b2b9cd40816da547e71e619c833"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14a05b2b9cd40816da547e71e619c833">&#9670;&nbsp;</a></span>filename()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char * FFmpeg_Transcoder::filename </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return source filename. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns filename. </dd></dl>

<p>Implements <a class="el" href="classFFmpeg__Base.html#ab286a55ddff32db33af199b60145751b">FFmpeg_Base</a>.</p>

<p class="definition">Definition at line <a class="el" href="ffmpeg__transcoder_8cc_source.html#l06448">6448</a> of file <a class="el" href="ffmpeg__transcoder_8cc_source.html">ffmpeg_transcoder.cc</a>.</p>

<p class="reference">References <a class="el" href="fileio_8h_source.html#l00148">VIRTUALFILE::m_origfile</a>, and <a class="el" href="ffmpeg__base_8h_source.html#l00280">FFmpeg_Base::m_virtualfile</a>.</p>

<p class="reference">Referenced by <a class="el" href="ffmpeg__transcoder_8cc_source.html#l07590">add_external_subtitle_stream()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l07732">add_external_subtitle_streams()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l06046">calculate_predicted_filesize()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l03197">decode()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l03251">decode_audio_frame()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l03740">decode_frame()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l03564">decode_subtitle()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l03354">decode_video_frame()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l06138">encode_finish()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l07524">foreach_subtitle_file()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l06947">hwframe_copy_from_hw()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l00761">open_albumarts()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l00678">open_bestmatch_audio()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l00873">open_bestmatch_decoder()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l00592">open_bestmatch_video()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l00306">open_input_file()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l01255">open_output()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l00717">open_subtitles()</a>, and <a class="el" href="transcode_8cc_source.html#l00329">transcoder_predict_filesize()</a>.</p>

</div>
</div>
<a id="a4cdfa54663debd74d4195d4d3dac431f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cdfa54663debd74d4195d4d3dac431f">&#9670;&nbsp;</a></span>find_sw_fmt_by_hw_type()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">AVPixelFormat FFmpeg_Transcoder::find_sw_fmt_by_hw_type </td>
          <td>(</td>
          <td class="paramtype">AVHWDeviceType&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the software pixel format for the given hardware acceleration. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>- Selected hardware acceleration. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, a negative AVERROR code on failure. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ffmpeg__transcoder_8cc_source.html#l07413">7413</a> of file <a class="el" href="ffmpeg__transcoder_8cc_source.html">ffmpeg_transcoder.cc</a>.</p>

<p class="reference">References <a class="el" href="ffmpeg__transcoder_8h_source.html#l01238">m_devicetype_map</a>.</p>

<p class="reference">Referenced by <a class="el" href="ffmpeg__transcoder_8cc_source.html#l07425">get_pix_formats()</a>, and <a class="el" href="ffmpeg__transcoder_8cc_source.html#l06842">hwframe_ctx_set()</a>.</p>

</div>
</div>
<a id="ab7fc3ccbcad63d267dcc99a688348115"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7fc3ccbcad63d267dcc99a688348115">&#9670;&nbsp;</a></span>flush_delayed_subtitles()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int FFmpeg_Transcoder::flush_delayed_subtitles </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flush delayed subtitle packets, if there are any. </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000014">Todo:</a></b></dt><dd>Implement <a class="el" href="classFFmpeg__Transcoder.html#ab7fc3ccbcad63d267dcc99a688348115" title="Flush delayed subtitle packets, if there are any.">flush_delayed_subtitles()</a> if required </dd></dl>

<p class="definition">Definition at line <a class="el" href="ffmpeg__transcoder_8cc_source.html#l05141">5141</a> of file <a class="el" href="ffmpeg__transcoder_8cc_source.html">ffmpeg_transcoder.cc</a>.</p>

<p class="reference">Referenced by <a class="el" href="ffmpeg__transcoder_8cc_source.html#l05210">process_single_fr()</a>.</p>

</div>
</div>
<a id="a0f90d7ec4715b359d5b666f5ab4b23b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f90d7ec4715b359d5b666f5ab4b23b7">&#9670;&nbsp;</a></span>flush_frames_all()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int FFmpeg_Transcoder::flush_frames_all </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>use_flush_packet</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Flush the remaining frames for all streams. </p>
<dl class="section return"><dt>Returns</dt><dd>On success, returns 0; on error, a negative AVERROR value. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ffmpeg__transcoder_8cc_source.html#l04012">4012</a> of file <a class="el" href="ffmpeg__transcoder_8cc_source.html">ffmpeg_transcoder.cc</a>.</p>

<p class="reference">References <a class="el" href="ffmpeg__transcoder_8cc_source.html#l04037">flush_frames_single()</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l00140">FFmpeg_Transcoder::INPUTFILE::m_audio</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l00120">FFmpeg_Transcoder::StreamRef::m_codec_ctx</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l01217">m_in</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l00122">FFmpeg_Transcoder::StreamRef::m_stream_idx</a>, and <a class="el" href="ffmpeg__transcoder_8h_source.html#l00141">FFmpeg_Transcoder::INPUTFILE::m_video</a>.</p>

<p class="reference">Referenced by <a class="el" href="ffmpeg__transcoder_8cc_source.html#l04095">read_decode_convert_and_store()</a>.</p>

</div>
</div>
<a id="aa8e11d701c658686dbb9209fbaddf245"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8e11d701c658686dbb9209fbaddf245">&#9670;&nbsp;</a></span>flush_frames_single()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int FFmpeg_Transcoder::flush_frames_single </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>stream_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>use_flush_packet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Flush the remaining frames. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">stream_idx</td><td>- Stream index to flush. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">use_flush_packet</td><td>- If true, use flush packet. Otherwise pass nullptr to avcodec_receive_frame. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, returns 0; on error, a negative AVERROR value. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ffmpeg__transcoder_8cc_source.html#l04037">4037</a> of file <a class="el" href="ffmpeg__transcoder_8cc_source.html">ffmpeg_transcoder.cc</a>.</p>

<p class="reference">References <a class="el" href="ffmpeg__transcoder_8cc_source.html#l03251">decode_audio_frame()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l03354">decode_video_frame()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l07470">is_audio_stream()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l06732">is_frameset()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l07475">is_video_stream()</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l00140">FFmpeg_Transcoder::INPUTFILE::m_audio</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l01225">m_copy_audio</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l01226">m_copy_video</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l01218">m_out</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l00122">FFmpeg_Transcoder::StreamRef::m_stream_idx</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l00141">FFmpeg_Transcoder::INPUTFILE::m_video</a>, and <a class="el" href="ffmpeg__transcoder_8cc_source.html#l07499">stream_exists()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ffmpeg__transcoder_8cc_source.html#l04012">flush_frames_all()</a>.</p>

</div>
</div>
<a id="aecfaf7a81d827e5bd18f5aa0cb949465"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecfaf7a81d827e5bd18f5aa0cb949465">&#9670;&nbsp;</a></span>foreach_subtitle_file()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int FFmpeg_Transcoder::foreach_subtitle_file </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>search_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::regex &amp;&#160;</td>
          <td class="paramname"><em>regex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>depth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; int(const std::string &amp;, const std::optional&lt; std::string &gt; &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>foreach_subititle_file </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">search_path</td><td>- Directory with subtitle files </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">regex</td><td>- Regular expression to select subtitle files </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">depth</td><td>- Recursively scan for subtitles, should be 0. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>- Funtion to be called for each file found </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, a negative AVERROR code on failure. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ffmpeg__transcoder_8cc_source.html#l07524">7524</a> of file <a class="el" href="ffmpeg__transcoder_8cc_source.html">ffmpeg_transcoder.cc</a>.</p>

<p class="reference">References <a class="el" href="logging_8h_source.html#l00237">Logging::error()</a>, <a class="el" href="ffmpeg__utils_8cc_source.html#l01139">ffmpeg_geterror()</a>, and <a class="el" href="ffmpeg__transcoder_8cc_source.html#l06448">filename()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ffmpeg__transcoder_8cc_source.html#l07732">add_external_subtitle_streams()</a>.</p>

</div>
</div>
<a id="a60e8d1769bf1ec0917d0cc55e9d50cc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60e8d1769bf1ec0917d0cc55e9d50cc2">&#9670;&nbsp;</a></span>get_aspect_ratio()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool FFmpeg_Transcoder::get_aspect_ratio </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AVRational &amp;&#160;</td>
          <td class="paramname"><em>sar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AVRational *&#160;</td>
          <td class="paramname"><em>ar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate aspect ratio for width/height and sample aspect ratio (sar). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">width</td><td>- Video width in pixels. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">height</td><td>- Video height in pixels. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sar</td><td>- Aspect ratio of input video. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ar</td><td>- Calulcated aspect ratio, if computeable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, returns true; if false is returned ar may not be used. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ffmpeg__transcoder_8cc_source.html#l01457">1457</a> of file <a class="el" href="ffmpeg__transcoder_8cc_source.html">ffmpeg_transcoder.cc</a>.</p>

<p class="reference">Referenced by <a class="el" href="ffmpeg__transcoder_8cc_source.html#l01501">get_video_size()</a>.</p>

</div>
</div>
<a id="a642fab7ffb7ed1822a71663df978a9e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a642fab7ffb7ed1822a71663df978a9e9">&#9670;&nbsp;</a></span>get_format()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum AVPixelFormat FFmpeg_Transcoder::get_format </td>
          <td>(</td>
          <td class="paramtype">AVCodecContext *&#160;</td>
          <td class="paramname"><em>input_codec_ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const enum AVPixelFormat *&#160;</td>
          <td class="paramname"><em>pix_fmts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Callback to negotiate the pixelFormat </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input_codec_ctx</td><td>- Input codec context </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pix_fmts</td><td>is the list of formats which are supported by the codec, it is terminated by -1 as 0 is a valid format, the formats are ordered by quality. The first is always the native one. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The callback may be called again immediately if initialization for the selected (hardware-accelerated) pixel format failed. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Behavior is undefined if the callback returns a value not in the fmt list of formats. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the chosen format<ul>
<li>encoding: unused</li>
<li>decoding: Set by user, if not set the native format will be chosen. </li>
</ul>
</dd></dl>

<p class="definition">Definition at line <a class="el" href="ffmpeg__transcoder_8cc_source.html#l06756">6756</a> of file <a class="el" href="ffmpeg__transcoder_8cc_source.html">ffmpeg_transcoder.cc</a>.</p>

<p class="reference">References <a class="el" href="ffmpeg__transcoder_8h_source.html#l01191">m_have_seeked</a>.</p>

</div>
</div>
<a id="ac9b79354a3f5124f478e1310ea77bfdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9b79354a3f5124f478e1310ea77bfdc">&#9670;&nbsp;</a></span>get_format_static()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum AVPixelFormat FFmpeg_Transcoder::get_format_static </td>
          <td>(</td>
          <td class="paramtype">AVCodecContext *&#160;</td>
          <td class="paramname"><em>input_codec_ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const enum AVPixelFormat *&#160;</td>
          <td class="paramname"><em>pix_fmts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Callback to negotiate the pixelFormat </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input_codec_ctx</td><td>- Input codec context </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pix_fmts</td><td>is the list of formats which are supported by the codec, it is terminated by -1 as 0 is a valid format, the formats are ordered by quality. The first is always the native one. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The callback may be called again immediately if initialization for the selected (hardware-accelerated) pixel format failed. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Behavior is undefined if the callback returns a value not in the fmt list of formats. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the chosen format<ul>
<li>encoding: unused</li>
<li>decoding: Set by user, if not set the native format will be chosen. </li>
</ul>
</dd></dl>

<p class="definition">Definition at line <a class="el" href="ffmpeg__transcoder_8cc_source.html#l06756">6756</a> of file <a class="el" href="ffmpeg__transcoder_8cc_source.html">ffmpeg_transcoder.cc</a>.</p>

<p class="reference">Referenced by <a class="el" href="ffmpeg__transcoder_8cc_source.html#l06810">hwdevice_ctx_add_ref()</a>.</p>

</div>
</div>
<a id="ab1c5d95c822b31beee2815e1ef0d0aed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1c5d95c822b31beee2815e1ef0d0aed">&#9670;&nbsp;</a></span>get_hw_decoder_name()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int FFmpeg_Transcoder::get_hw_decoder_name </td>
          <td>(</td>
          <td class="paramtype">AVCodecID&#160;</td>
          <td class="paramname"><em>codec_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string *&#160;</td>
          <td class="paramname"><em>codec_name</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the hardware codec name as string. This is required, because e.g. the name for the software codec is libx264, but for hardware it is h264_vaapi under VAAPI. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">codec_id</td><td>- Id of encoder/decoder codec </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">codec_name</td><td>- Returns the name of the codec, may be nullptr if not requitred. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, a negative AVERROR code on failure.</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000017">Todo:</a></b></dt><dd><a class="el" href="structHWACCEL.html" title="Hardware acceleration device and type.">HWACCEL</a> - Supported formats</dd></dl>
<p>Tested and working: VA-API, MMAL and OMX.</p>
<p>Some VA-API formats do not yet work, see "fixit"</p>
<p>V4LM2M: implemented, but untested NIVIDA/CUDA: implemented, but untested </p>

<p class="definition">Definition at line <a class="el" href="ffmpeg__transcoder_8cc_source.html#l07014">7014</a> of file <a class="el" href="ffmpeg__transcoder_8cc_source.html">ffmpeg_transcoder.cc</a>.</p>

<p class="reference">References <a class="el" href="ffmpeg__transcoder_8cc_source.html#l07192">get_hw_mmal_decoder_name()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l07104">get_hw_vaapi_codec_name()</a>, <a class="el" href="ffmpegfs_8h_source.html#l00117">HWACCELAPI_MMAL</a>, <a class="el" href="ffmpegfs_8h_source.html#l00115">HWACCELAPI_VAAPI</a>, <a class="el" href="ffmpegfs_8h_source.html#l00214">FFMPEGFS_PARAMS::m_hwaccel_dec_API</a>, and <a class="el" href="ffmpegfs_8cc_source.html#l00072">params</a>.</p>

</div>
</div>
<a id="a710f9fdb600a77a684f8f90ce6a37b05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a710f9fdb600a77a684f8f90ce6a37b05">&#9670;&nbsp;</a></span>get_hw_encoder_name()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int FFmpeg_Transcoder::get_hw_encoder_name </td>
          <td>(</td>
          <td class="paramtype">AVCodecID&#160;</td>
          <td class="paramname"><em>codec_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string *&#160;</td>
          <td class="paramname"><em>codec_name</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the hardware codec name as string. This is required, because e.g. the name for the software codec is libx264, but for hardware it is h264_vaapi under VAAPI. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">codec_id</td><td>- Id of encoder/decoder codec </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">codec_name</td><td>- Returns the name of the codec, may be nullptr if not requitred. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, AVERROR_DECODER_NOT_FOUND if no codec available. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ffmpeg__transcoder_8cc_source.html#l07059">7059</a> of file <a class="el" href="ffmpeg__transcoder_8cc_source.html">ffmpeg_transcoder.cc</a>.</p>

<p class="reference">References <a class="el" href="ffmpeg__transcoder_8cc_source.html#l07339">get_hw_omx_encoder_name()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l07104">get_hw_vaapi_codec_name()</a>, <a class="el" href="ffmpegfs_8h_source.html#l00118">HWACCELAPI_OMX</a>, <a class="el" href="ffmpegfs_8h_source.html#l00115">HWACCELAPI_VAAPI</a>, <a class="el" href="ffmpegfs_8h_source.html#l00211">FFMPEGFS_PARAMS::m_hwaccel_enc_API</a>, and <a class="el" href="ffmpegfs_8cc_source.html#l00072">params</a>.</p>

<p class="reference">Referenced by <a class="el" href="ffmpeg__transcoder_8cc_source.html#l01631">add_stream()</a>, and <a class="el" href="ffmpeg__transcoder_8cc_source.html#l00592">open_bestmatch_video()</a>.</p>

</div>
</div>
<a id="a26f0c35e837afa3b58b39f4d0a165afe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26f0c35e837afa3b58b39f4d0a165afe">&#9670;&nbsp;</a></span>get_hw_mmal_decoder_name()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int FFmpeg_Transcoder::get_hw_mmal_decoder_name </td>
          <td>(</td>
          <td class="paramtype">AVCodecID&#160;</td>
          <td class="paramname"><em>codec_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string *&#160;</td>
          <td class="paramname"><em>codec_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine MMAL decoder codec name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">codec_id</td><td>- Id of encoder/decoder codec </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">codec_name</td><td>- Name of the codec. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, AVERROR_DECODER_NOT_FOUND if no codec available. </dd></dl>
<p>*** MMAL decoder ***</p>
<p>h264_mmal h264 (mmal) (codec h264) mpeg2_mmal mpeg2 (mmal) (codec mpeg2video) mpeg4_mmal mpeg4 (mmal) (codec mpeg4) vc1_mmal vc1 (mmal) (codec vc1)</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000019">Todo:</a></b></dt><dd>mmal MPEG1 hardware acceleration not working. Probably because I have not bought a key... <br  />
<br  />
INFO : [/root/test/in/En Vogue - Don-t Let Go (Love) (Official Music Video) (mpeg2).mpeg] Transcoding to ts. <br  />
INFO : [/root/test/in/En Vogue - Don-t Let Go (Love) (Official Music Video) (mpeg2).mpeg] Hardware decoder acceleration active using codec 'mpeg2_mmal'. <br  />
INFO : [/root/test/in/En Vogue - Don-t Let Go (Love) (Official Music Video) (mpeg2).mpeg] Hardware decoder acceleration enabled. Codec 'mpeg2_mmal'. <br  />
mmal: mmal_vc_port_info_set: failed to set port info (2:0): EINVAL <br  />
mmal: mmal_vc_port_set_format: mmal_vc_port_info_set failed 0x6b985440 (EINVAL) <br  />
mmal: mmal_port_disable: port vc.ril.video_decode:in:0(MP2V)(0x6b985440) is not enabled <br  />
mmal: mmal_port_disable: port vc.ril.video_decode:out:0(0x6b985890) is not enabled <br  />
mmal: mmal_port_disable: port vc.ril.video_decode:ctr:0(0x6b94db90) is not enabled <br  />
ERROR : [/root/test/in/En Vogue - Don-t Let Go (Love) (Official Music Video) (mpeg2).mpeg] Failed to open video input codec for stream video (error '0'). <br  />
ERROR : [/root/test/in/En Vogue - Don-t Let Go (Love) (Official Music Video) (mpeg2).mpeg] Failed to open video codec (error 'Unknown error occurred'). <br  />
ERROR : [/root/test/out/En Vogue - Don-t Let Go (Love) (Official Music Video) (mpeg2).ts] Transcoding exited with error. <br  />
ERROR : [/root/test/out/En Vogue - Don-t Let Go (Love) (Official Music Video) (mpeg2).ts] System error: (5) Input/output error <br  />
ERROR : [/root/test/out/En Vogue - Don-t Let Go (Love) (Official Music Video) (mpeg2).ts] FFMpeg error: (-1313558101) Unknown error occurred </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000020">Todo:</a></b></dt><dd>mmal VC1 hardware acceleration not working. Probably because I have not bought a key... <br  />
<br  />
INFO : [/root/test/in/Test_1440x576_WVC1_6Mbps.wmv] Hardware decoder acceleration active using codec 'vc1_mmal'. <br  />
INFO : [/root/test/in/Test_1440x576_WVC1_6Mbps.wmv] Hardware decoder acceleration enabled. Codec 'vc1_mmal'. <br  />
mmal: mmal_vc_port_info_set: failed to set port info (2:0): EINVAL <br  />
mmal: mmal_vc_port_set_format: mmal_vc_port_info_set failed 0x6e54c560 (EINVAL) <br  />
mmal: mmal_port_disable: port vc.ril.video_decode:in:0(WVC1)(0x6e54c560) is not enabled <br  />
mmal: mmal_port_disable: port vc.ril.video_decode:out:0(0x6e546660) is not enabled <br  />
mmal: mmal_port_disable: port vc.ril.video_decode:ctr:0(0x6e54c240) is not enabled <br  />
ERROR : [/root/test/in/Test_1440x576_WVC1_6Mbps.wmv] Failed to open video input codec for stream video (error '0'). <br  />
ERROR : [/root/test/in/Test_1440x576_WVC1_6Mbps.wmv] Failed to open video codec (error 'Unknown error occurred'). </dd></dl>

<p class="definition">Definition at line <a class="el" href="ffmpeg__transcoder_8cc_source.html#l07192">7192</a> of file <a class="el" href="ffmpeg__transcoder_8cc_source.html">ffmpeg_transcoder.cc</a>.</p>

<p class="reference">Referenced by <a class="el" href="ffmpeg__transcoder_8cc_source.html#l07014">get_hw_decoder_name()</a>.</p>

</div>
</div>
<a id="a15eb44b2f519bab0155ad1c261888827"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15eb44b2f519bab0155ad1c261888827">&#9670;&nbsp;</a></span>get_hw_omx_encoder_name()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int FFmpeg_Transcoder::get_hw_omx_encoder_name </td>
          <td>(</td>
          <td class="paramtype">AVCodecID&#160;</td>
          <td class="paramname"><em>codec_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string *&#160;</td>
          <td class="paramname"><em>codec_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine OMX encoder codec name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">codec_id</td><td>- Id of encoder/decoder codec </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">codec_name</td><td>- Name of the codec. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, AVERROR_DECODER_NOT_FOUND if no codec available. </dd></dl>
<p>*** Openmax encoder ***</p>
<p>h264_omx OpenMAX IL H.264 video encoder (codec h264)</p>

<p class="definition">Definition at line <a class="el" href="ffmpeg__transcoder_8cc_source.html#l07339">7339</a> of file <a class="el" href="ffmpeg__transcoder_8cc_source.html">ffmpeg_transcoder.cc</a>.</p>

<p class="reference">Referenced by <a class="el" href="ffmpeg__transcoder_8cc_source.html#l07059">get_hw_encoder_name()</a>.</p>

</div>
</div>
<a id="a8082130dde633c72a01bfc392387d3d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8082130dde633c72a01bfc392387d3d9">&#9670;&nbsp;</a></span>get_hw_pix_fmt()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">AVPixelFormat FFmpeg_Transcoder::get_hw_pix_fmt </td>
          <td>(</td>
          <td class="paramtype">const AVCodec *&#160;</td>
          <td class="paramname"><em>codec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AVHWDeviceType&#160;</td>
          <td class="paramname"><em>dev_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>use_device_ctx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine the hardware pixel format for the codec, if applicable. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">codec</td><td>- Input codec used </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dev_type</td><td>- Hardware device type </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">use_device_ctx</td><td>- If true checks for pix format if using a hardware device context, for a pix format using a hardware frames context otherwise. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns hardware pixel format, or AV_PIX_FMT_NONE if not applicable. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ffmpeg__transcoder_8cc_source.html#l00901">901</a> of file <a class="el" href="ffmpeg__transcoder_8cc_source.html">ffmpeg_transcoder.cc</a>.</p>

<p class="reference">References <a class="el" href="logging_8h_source.html#l00180">Logging::debug()</a>, <a class="el" href="logging_8h_source.html#l00237">Logging::error()</a>, and <a class="el" href="ffmpeg__utils_8cc_source.html#l02112">hwdevice_get_type_name()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ffmpeg__transcoder_8cc_source.html#l01631">add_stream()</a>.</p>

</div>
</div>
<a id="a8b841205dd50e316c6506744dcca16ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b841205dd50e316c6506744dcca16ec">&#9670;&nbsp;</a></span>get_hw_v4l2m2m_encoder_name()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int FFmpeg_Transcoder::get_hw_v4l2m2m_encoder_name </td>
          <td>(</td>
          <td class="paramtype">AVCodecID&#160;</td>
          <td class="paramname"><em>codec_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string *&#160;</td>
          <td class="paramname"><em>codec_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine video for linux encoder codec name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">codec_id</td><td>- Id of encoder/decoder codec </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">codec_name</td><td>- Name of the codec. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, AVERROR_DECODER_NOT_FOUND if no codec available. </dd></dl>
<ul>
<li>*** v4l2m2m (Video2linux) encoder ***</li>
</ul>
<p>h263_v4l2m2m V4L2 mem2mem H.263 encoder wrapper (codec h263) h264_v4l2m2m V4L2 mem2mem H.264 encoder wrapper (codec h264) hevc_v4l2m2m V4L2 mem2mem HEVC encoder wrapper (codec hevc) mpeg4_v4l2m2m V4L2 mem2mem MPEG4 encoder wrapper (codec mpeg4) vp8_v4l2m2m V4L2 mem2mem VP8 encoder wrapper (codec vp8)</p>

<p class="definition">Definition at line <a class="el" href="ffmpeg__transcoder_8cc_source.html#l07364">7364</a> of file <a class="el" href="ffmpeg__transcoder_8cc_source.html">ffmpeg_transcoder.cc</a>.</p>

</div>
</div>
<a id="a10d35e42fd531b0f96da0ad9eb5ead89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10d35e42fd531b0f96da0ad9eb5ead89">&#9670;&nbsp;</a></span>get_hw_vaapi_codec_name()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int FFmpeg_Transcoder::get_hw_vaapi_codec_name </td>
          <td>(</td>
          <td class="paramtype">AVCodecID&#160;</td>
          <td class="paramname"><em>codec_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string *&#160;</td>
          <td class="paramname"><em>codec_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine VAAPI codec name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">codec_id</td><td>- Id of encoder/decoder codec </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">codec_name</td><td>- Name of the codec. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, AVERROR_DECODER_NOT_FOUND if no codec available. </dd></dl>
<p>*** Intel VAAPI de/encoder ***</p>
<p>h264_vaapi H.264/AVC (VAAPI) (codec h264) hevc_vaapi H.265/HEVC (VAAPI) (codec hevc) mjpeg_vaapi MJPEG (VAAPI) (codec mjpeg) mpeg2_vaapi MPEG-2 (VAAPI) (codec mpeg2video) vp1_vaapi VC1 (VAAPI) (codec vc1) seems to be possible on my hardware vp8_vaapi VP8 (VAAPI) (codec vp8) vp9_vaapi VP9 (VAAPI) (codec vp9)</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000018">Todo:</a></b></dt><dd>fixit, MPEG-1 decoding does not work...</dd></dl>
<p>Program terminated with signal SIGSEGV, Segmentation fault. #0 __memmove_avx_unaligned_erms () at ../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:383 383 ../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S: Datei oder Verzeichnis nicht gefunden. [Current thread is 1 (Thread 0x7f95a24d4700 (LWP 16179))] (gdb) bt #0 __memmove_avx_unaligned_erms () at ../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:383 #1 0x00007f95903c4e26 in ?? () from /usr/lib/x86_64-linux-gnu/dri/iHD_drv_video.so #2 0x00007f95aaae80b8 in vaGetImage () from /lib/x86_64-linux-gnu/libva.so.2 #3 0x00007f95af524bb5 in ?? () from /lib/x86_64-linux-gnu/libavutil.so.56 #4 0x00007f95af5250fb in ?? () from /lib/x86_64-linux-gnu/libavutil.so.56 #5 0x00007f95af51c37f in av_hwframe_transfer_data () from /lib/x86_64-linux-gnu/libavutil.so.56 #6 0x00007f95af51c406 in av_hwframe_transfer_data () from /lib/x86_64-linux-gnu/libavutil.so.56 #7 0x0000555da4fde146 in <a class="el" href="classFFmpeg__Transcoder.html#a45d6501228351ff6407f0af09596d09f" title="Decode one video frame.">FFmpeg_Transcoder::decode_video_frame</a> (this=0x7f9598002e90, pkt=0x7f95a24d2f90, decoded=0x7f95a24d2ec4) at <a class="el" href="ffmpeg__transcoder_8cc.html" title="FFmpeg_Transcoder class implementation.">ffmpeg_transcoder.cc</a>:2655 #8 0x0000555da4fde5cd in <a class="el" href="classFFmpeg__Transcoder.html#a96c31a851e95a6fb714b2908c83ec696" title="Decode one frame.">FFmpeg_Transcoder::decode_frame</a> (this=0x7f9598002e90, pkt=0x7f95a24d2f90) at <a class="el" href="ffmpeg__transcoder_8cc.html" title="FFmpeg_Transcoder class implementation.">ffmpeg_transcoder.cc</a>:2852 #9 0x0000555da4fdea4b in <a class="el" href="classFFmpeg__Transcoder.html#a6afa2189ecd068bcbaa1054835db27c4" title="Read frame from source file, decode and store in FIFO.">FFmpeg_Transcoder::read_decode_convert_and_store</a> (this=0x7f9598002e90, finished=0x7f95a24d3030) at <a class="el" href="ffmpeg__transcoder_8cc.html" title="FFmpeg_Transcoder class implementation.">ffmpeg_transcoder.cc</a>:3189 #10 0x0000555da4fdfa73 in <a class="el" href="classFFmpeg__Transcoder.html#a33fe2abcc0767204dcd6dab22980d54e">FFmpeg_Transcoder::process_single_fr</a> (this=this@entry=0x7f9598002e90, status=@0x7f95a24d3134: 0) at <a class="el" href="ffmpeg__transcoder_8cc.html" title="FFmpeg_Transcoder class implementation.">ffmpeg_transcoder.cc</a>:3987 #11 0x0000555da4f8c997 in transcoder_thread (arg=optimized out) at <a class="el" href="transcode_8cc.html" title="File transcoder interface implementation.">transcode.cc</a>:874 #12 0x0000555da4fc54ef in <a class="el" href="classthread__pool.html#a8e3618dd406bf5c8b35d2b047c3e64d8" title="Start loop function.">thread_pool::loop_function</a> (this=0x7f959c002b40) at <a class="el" href="thread__pool_8cc.html" title="Thread pool class implementation.">thread_pool.cc</a>:78 #13 0x00007f95aeaf4c10 in ?? () from /lib/x86_64-linux-gnu/libstdc++.so.6 #14 0x00007f95ae9f0ea7 in start_thread (arg=optimized out) at pthread_create.c:477 #15 0x00007f95ae920d4f in clone () at ../sysdeps/unix/sysv/linux/x86_64/clone.S:95</p>

<p class="definition">Definition at line <a class="el" href="ffmpeg__transcoder_8cc_source.html#l07104">7104</a> of file <a class="el" href="ffmpeg__transcoder_8cc_source.html">ffmpeg_transcoder.cc</a>.</p>

<p class="reference">Referenced by <a class="el" href="ffmpeg__transcoder_8cc_source.html#l07014">get_hw_decoder_name()</a>, and <a class="el" href="ffmpeg__transcoder_8cc_source.html#l07059">get_hw_encoder_name()</a>.</p>

</div>
</div>
<a id="a46ec75f8a6ce02cbd86d88e56e3b0033"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46ec75f8a6ce02cbd86d88e56e3b0033">&#9670;&nbsp;</a></span>get_next_segment()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t FFmpeg_Transcoder::get_next_segment </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate next HLS segment from position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pos</td><td>- Current transcoder position in AV_TIMEBASE fractional seconds. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of next segment </dd></dl>

<p class="definition">Definition at line <a class="el" href="ffmpeg__transcoder_8cc_source.html#l07460">7460</a> of file <a class="el" href="ffmpeg__transcoder_8cc_source.html">ffmpeg_transcoder.cc</a>.</p>

<p class="reference">References <a class="el" href="ffmpegfs_8h_source.html#l00208">FFMPEGFS_PARAMS::m_segment_duration</a>, and <a class="el" href="ffmpegfs_8cc_source.html#l00072">params</a>.</p>

<p class="reference">Referenced by <a class="el" href="ffmpeg__transcoder_8cc_source.html#l03354">decode_video_frame()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l05210">process_single_fr()</a>, and <a class="el" href="ffmpeg__transcoder_8cc_source.html#l03634">store_packet()</a>.</p>

</div>
</div>
<a id="a457c2dd762d33080d1b70ae97a4ac5af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a457c2dd762d33080d1b70ae97a4ac5af">&#9670;&nbsp;</a></span>get_out_subtitle_stream()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFFmpeg__Transcoder_1_1StreamRef.html">FFmpeg_Transcoder::StreamRef</a> * FFmpeg_Transcoder::get_out_subtitle_stream </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>stream_idx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get subtitle stream for the stream index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">stream_idx</td><td>- Stream index to get subtitle stream for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to subbtitle stream or nullptr if not found </dd></dl>

<p class="definition">Definition at line <a class="el" href="ffmpeg__transcoder_8cc_source.html#l07487">7487</a> of file <a class="el" href="ffmpeg__transcoder_8cc_source.html">ffmpeg_transcoder.cc</a>.</p>

<p class="reference">References <a class="el" href="ffmpeg__transcoder_8h_source.html#l01218">m_out</a>, and <a class="el" href="ffmpeg__transcoder_8h_source.html#l00143">FFmpeg_Transcoder::INPUTFILE::m_subtitle</a>.</p>

<p class="reference">Referenced by <a class="el" href="ffmpeg__transcoder_8cc_source.html#l04620">encode_subtitle()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l01255">open_output()</a>, and <a class="el" href="ffmpeg__transcoder_8cc_source.html#l03634">store_packet()</a>.</p>

</div>
</div>
<a id="af26399e6b5c677b4d8eb0072dafcd05b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af26399e6b5c677b4d8eb0072dafcd05b">&#9670;&nbsp;</a></span>get_output_bit_rate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool FFmpeg_Transcoder::get_output_bit_rate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ffmpeg__utils_8h.html#a17468d10f0c67a4ee7b38aab09d9e096">BITRATE</a>&#160;</td>
          <td class="paramname"><em>input_bit_rate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ffmpeg__utils_8h.html#a17468d10f0c67a4ee7b38aab09d9e096">BITRATE</a>&#160;</td>
          <td class="paramname"><em>max_bit_rate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ffmpeg__utils_8h.html#a17468d10f0c67a4ee7b38aab09d9e096">BITRATE</a> *&#160;</td>
          <td class="paramname"><em>output_bit_rate</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate output bit rate based on user option. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input_bit_rate</td><td>- Bit rate from input file. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max_bit_rate</td><td>- Max. bit rate if set by user. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">output_bit_rate</td><td>- Selected output bit rate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true if bit rate was changed; false if not. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ffmpeg__transcoder_8cc_source.html#l01437">1437</a> of file <a class="el" href="ffmpeg__transcoder_8cc_source.html">ffmpeg_transcoder.cc</a>.</p>

<p class="reference">Referenced by <a class="el" href="ffmpeg__transcoder_8cc_source.html#l01631">add_stream()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l05695">audio_size()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l00796">can_copy_stream()</a>, and <a class="el" href="ffmpeg__transcoder_8cc_source.html#l05887">video_size()</a>.</p>

</div>
</div>
<a id="a54554e2e1177c1c1fc185c7c2e7f9d78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54554e2e1177c1c1fc185c7c2e7f9d78">&#9670;&nbsp;</a></span>get_output_sample_rate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool FFmpeg_Transcoder::get_output_sample_rate </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>input_sample_rate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>max_sample_rate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>output_sample_rate</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate output sample rate based on user option. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input_sample_rate</td><td>- Sample rate from input file. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max_sample_rate</td><td>- Max. sample rate if set by user </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">output_sample_rate</td><td>- Selected output sample rate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true if sample rate was changed; false if not. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ffmpeg__transcoder_8cc_source.html#l01417">1417</a> of file <a class="el" href="ffmpeg__transcoder_8cc_source.html">ffmpeg_transcoder.cc</a>.</p>

<p class="reference">Referenced by <a class="el" href="ffmpeg__transcoder_8cc_source.html#l01631">add_stream()</a>, and <a class="el" href="ffmpeg__transcoder_8cc_source.html#l05695">audio_size()</a>.</p>

</div>
</div>
<a id="af4fff93bbb68d997bdab241dee973628"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4fff93bbb68d997bdab241dee973628">&#9670;&nbsp;</a></span>get_pix_formats()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void FFmpeg_Transcoder::get_pix_formats </td>
          <td>(</td>
          <td class="paramtype">AVPixelFormat *&#160;</td>
          <td class="paramname"><em>in_pix_fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AVPixelFormat *&#160;</td>
          <td class="paramname"><em>out_pix_fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AVCodecContext *&#160;</td>
          <td class="paramname"><em>output_codec_ctx</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get correct input and output pixel format. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">output_codec_ctx</td><td>- Output codec context. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">in_pix_fmt</td><td>- Input pixel format. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out_pix_fmt</td><td>- Output pixel format. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="ffmpeg__transcoder_8cc_source.html#l07425">7425</a> of file <a class="el" href="ffmpeg__transcoder_8cc_source.html">ffmpeg_transcoder.cc</a>.</p>

<p class="reference">References <a class="el" href="ffmpeg__transcoder_8cc_source.html#l07413">find_sw_fmt_by_hw_type()</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l00120">FFmpeg_Transcoder::StreamRef::m_codec_ctx</a>, <a class="el" href="ffmpegfs_8h_source.html#l00215">FFMPEGFS_PARAMS::m_hwaccel_dec_device_type</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l01242">m_hwaccel_enable_dec_buffering</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l01241">m_hwaccel_enable_enc_buffering</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l01217">m_in</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l01218">m_out</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l00121">FFmpeg_Transcoder::StreamRef::m_stream</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l00141">FFmpeg_Transcoder::INPUTFILE::m_video</a>, and <a class="el" href="ffmpegfs_8cc_source.html#l00072">params</a>.</p>

<p class="reference">Referenced by <a class="el" href="ffmpeg__transcoder_8cc_source.html#l01097">open_output_frame_set()</a>.</p>

</div>
</div>
<a id="ad80dbd5504903dcb81db2e617929601a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad80dbd5504903dcb81db2e617929601a">&#9670;&nbsp;</a></span>get_prores_bitrate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ffmpeg__utils_8h.html#a17468d10f0c67a4ee7b38aab09d9e096">BITRATE</a> FFmpeg_Transcoder::get_prores_bitrate </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AVRational &amp;&#160;</td>
          <td class="paramname"><em>framerate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>interleaved</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>profile</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate the appropriate bitrate for a ProRes file given several parameters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">width</td><td>- Video width in pixels. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">height</td><td>- Video height in pixels. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">framerate</td><td>- Video frame rate. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">interleaved</td><td>- If true, video is interleaved; false if not. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">profile</td><td>- Selected ProRes profile. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Bitrate in bit/s. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ffmpeg__transcoder_8cc_source.html#l05620">5620</a> of file <a class="el" href="ffmpeg__transcoder_8cc_source.html">ffmpeg_transcoder.cc</a>.</p>

<p class="reference">References <a class="el" href="ffmpeg__transcoder_8h_source.html#l01235">m_prores_bitrate</a>, and <a class="el" href="ffmpeg__transcoder_8h_source.html#l00075">MAX_PRORES_FRAMERATE</a>.</p>

<p class="reference">Referenced by <a class="el" href="ffmpeg__transcoder_8cc_source.html#l05887">video_size()</a>.</p>

</div>
</div>
<a id="af7c3726c0165e3061d1fc4ef66985e87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7c3726c0165e3061d1fc4ef66985e87">&#9670;&nbsp;</a></span>get_video_size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool FFmpeg_Transcoder::get_video_size </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>output_width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>output_height</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the size of the output video based on user selection and apsect ratio. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">output_width</td><td>- Output video width. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">output_height</td><td>- Output video height. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true if video height/width was reduces; false if not. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ffmpeg__transcoder_8cc_source.html#l01501">1501</a> of file <a class="el" href="ffmpeg__transcoder_8cc_source.html">ffmpeg_transcoder.cc</a>.</p>

<p class="reference">References <a class="el" href="ffmpeg__transcoder_8cc_source.html#l01457">get_aspect_ratio()</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l01217">m_in</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l00121">FFmpeg_Transcoder::StreamRef::m_stream</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l00141">FFmpeg_Transcoder::INPUTFILE::m_video</a>, <a class="el" href="ffmpegfs_8h_source.html#l00205">FFMPEGFS_PARAMS::m_videoheight</a>, <a class="el" href="ffmpegfs_8h_source.html#l00204">FFMPEGFS_PARAMS::m_videowidth</a>, and <a class="el" href="ffmpegfs_8cc_source.html#l00072">params</a>.</p>

<p class="reference">Referenced by <a class="el" href="ffmpeg__transcoder_8cc_source.html#l01631">add_stream()</a>.</p>

</div>
</div>
<a id="a794e22b656e5711f332b06b8ee5e2804"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a794e22b656e5711f332b06b8ee5e2804">&#9670;&nbsp;</a></span>goto_next_segment()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool FFmpeg_Transcoder::goto_next_segment </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>next_segment</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if segment number is next designated segment. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">next_segment</td><td>- Number next current segment </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true if next segment should start, false if not. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ffmpeg__transcoder_8cc_source.html#l07465">7465</a> of file <a class="el" href="ffmpeg__transcoder_8cc_source.html">ffmpeg_transcoder.cc</a>.</p>

<p class="reference">References <a class="el" href="ffmpeg__transcoder_8h_source.html#l01221">m_current_segment</a>.</p>

<p class="reference">Referenced by <a class="el" href="ffmpeg__transcoder_8cc_source.html#l03354">decode_video_frame()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l05210">process_single_fr()</a>, and <a class="el" href="ffmpeg__transcoder_8cc_source.html#l03634">store_packet()</a>.</p>

</div>
</div>
<a id="a38dbce3d014b331e215341cb711385e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38dbce3d014b331e215341cb711385e7">&#9670;&nbsp;</a></span>have_seeked()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool FFmpeg_Transcoder::have_seeked </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if we made a seek operation. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns true if a seek was done, false if not. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ffmpeg__transcoder_8cc_source.html#l06756">6756</a> of file <a class="el" href="ffmpeg__transcoder_8cc_source.html">ffmpeg_transcoder.cc</a>.</p>

<p class="reference">Referenced by <a class="el" href="transcode_8cc_source.html#l00155">transcode_finish()</a>, and <a class="el" href="transcode_8cc_source.html#l00770">transcoder_thread()</a>.</p>

</div>
</div>
<a id="adca40886322ae7af60bcb4356a4eb658"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adca40886322ae7af60bcb4356a4eb658">&#9670;&nbsp;</a></span>hwdevice_ctx_add_ref()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int FFmpeg_Transcoder::hwdevice_ctx_add_ref </td>
          <td>(</td>
          <td class="paramtype">AVCodecContext *&#160;</td>
          <td class="paramname"><em>input_codec_ctx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add reference to hardware device context. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input_codec_ctx</td><td>- Input codec context </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, a negative AVERROR code on failure. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ffmpeg__transcoder_8cc_source.html#l06810">6810</a> of file <a class="el" href="ffmpeg__transcoder_8cc_source.html">ffmpeg_transcoder.cc</a>.</p>

<p class="reference">References <a class="el" href="logging_8h_source.html#l00237">Logging::error()</a>, <a class="el" href="ffmpeg__utils_8cc_source.html#l01139">ffmpeg_geterror()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l06761">get_format_static()</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l01244">m_hwaccel_dec_device_ctx</a>, and <a class="el" href="ffmpeg__transcoder_8cc_source.html#l06458">virtname()</a>.</p>

</div>
</div>
<a id="aa056b2ec3c7b93cc2522b61196d89e60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa056b2ec3c7b93cc2522b61196d89e60">&#9670;&nbsp;</a></span>hwdevice_ctx_create()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int FFmpeg_Transcoder::hwdevice_ctx_create </td>
          <td>(</td>
          <td class="paramtype">AVBufferRef **&#160;</td>
          <td class="paramname"><em>hwaccel_enc_device_ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AVHWDeviceType&#160;</td>
          <td class="paramname"><em>dev_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>device</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Open a device of the specified type and create an AVHWDeviceContext for it.</p>
<p>This is a convenience function intended to cover the simple cases. Callers who need to fine-tune device creation/management should open the device manually and then wrap it in an AVHWDeviceContext using av_hwdevice_ctx_alloc()/av_hwdevice_ctx_init().</p>
<p>The returned context is already initialized and ready for use, the caller should not call av_hwdevice_ctx_init() on it. The user_opaque/free fields of the created AVHWDeviceContext are set by this function and should not be touched by the caller.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">hwaccel_enc_device_ctx</td><td>- On success, a reference to the newly-created device context will be written here. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dev_type</td><td>- The type of the device to create. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>- A type-specific string identifying the device to open.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, a negative AVERROR code on failure. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ffmpeg__transcoder_8cc_source.html#l06791">6791</a> of file <a class="el" href="ffmpeg__transcoder_8cc_source.html">ffmpeg_transcoder.cc</a>.</p>

<p class="reference">References <a class="el" href="logging_8h_source.html#l00237">Logging::error()</a>, <a class="el" href="ffmpeg__utils_8cc_source.html#l01139">ffmpeg_geterror()</a>, <a class="el" href="ffmpeg__utils_8cc_source.html#l02112">hwdevice_get_type_name()</a>, and <a class="el" href="ffmpeg__transcoder_8cc_source.html#l06458">virtname()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ffmpeg__transcoder_8cc_source.html#l00592">open_bestmatch_video()</a>.</p>

</div>
</div>
<a id="af76536b79c199e9f79fca1b658c852fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af76536b79c199e9f79fca1b658c852fc">&#9670;&nbsp;</a></span>hwdevice_ctx_free()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void FFmpeg_Transcoder::hwdevice_ctx_free </td>
          <td>(</td>
          <td class="paramtype">AVBufferRef **&#160;</td>
          <td class="paramname"><em>hwaccel_device_ctx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Free (remove reference) to hardware device context. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">hwaccel_device_ctx</td><td>- Hardware device context to free </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, a negative AVERROR code on failure. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ffmpeg__transcoder_8cc_source.html#l06833">6833</a> of file <a class="el" href="ffmpeg__transcoder_8cc_source.html">ffmpeg_transcoder.cc</a>.</p>

<p class="reference">Referenced by <a class="el" href="ffmpeg__transcoder_8cc_source.html#l06427">close()</a>, and <a class="el" href="ffmpeg__transcoder_8cc_source.html#l01255">open_output()</a>.</p>

</div>
</div>
<a id="ae99a72991154cca5a3be501cb377d248"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae99a72991154cca5a3be501cb377d248">&#9670;&nbsp;</a></span>hwframe_copy_from_hw()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int FFmpeg_Transcoder::hwframe_copy_from_hw </td>
          <td>(</td>
          <td class="paramtype">AVCodecContext *&#160;</td>
          <td class="paramname"><em>output_codec_ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classFFmpeg__Frame.html">FFmpeg_Frame</a> *&#160;</td>
          <td class="paramname"><em>sw_frame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AVFrame *&#160;</td>
          <td class="paramname"><em>hw_frame</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Copy data hardware surface to software. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">output_codec_ctx</td><td>- Codec context </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">sw_frame</td><td>- AVFrame to copy data to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">hw_frame</td><td>- AVFrame to copy data from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, a negative AVERROR code on failure. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ffmpeg__transcoder_8cc_source.html#l06947">6947</a> of file <a class="el" href="ffmpeg__transcoder_8cc_source.html">ffmpeg_transcoder.cc</a>.</p>

<p class="reference">References <a class="el" href="logging_8h_source.html#l00237">Logging::error()</a>, <a class="el" href="ffmpeg__utils_8cc_source.html#l01139">ffmpeg_geterror()</a>, and <a class="el" href="ffmpeg__transcoder_8cc_source.html#l06448">filename()</a>.</p>

</div>
</div>
<a id="ac10aa97aa9f8bb5a427831c94d11c9a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac10aa97aa9f8bb5a427831c94d11c9a4">&#9670;&nbsp;</a></span>hwframe_copy_to_hw()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int FFmpeg_Transcoder::hwframe_copy_to_hw </td>
          <td>(</td>
          <td class="paramtype">AVCodecContext *&#160;</td>
          <td class="paramname"><em>output_codec_ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classFFmpeg__Frame.html">FFmpeg_Frame</a> *&#160;</td>
          <td class="paramname"><em>hw_frame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AVFrame *&#160;</td>
          <td class="paramname"><em>sw_frame</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Copy data software to a hardware surface. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">output_codec_ctx</td><td>- Codec context </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">hw_frame</td><td>- AVFrame to copy data to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sw_frame</td><td>- AVFrame to copy data from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, a negative AVERROR code on failure. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ffmpeg__transcoder_8cc_source.html#l06968">6968</a> of file <a class="el" href="ffmpeg__transcoder_8cc_source.html">ffmpeg_transcoder.cc</a>.</p>

<p class="reference">References <a class="el" href="logging_8h_source.html#l00237">Logging::error()</a>, <a class="el" href="ffmpeg__utils_8cc_source.html#l01139">ffmpeg_geterror()</a>, and <a class="el" href="ffmpeg__transcoder_8cc_source.html#l06458">virtname()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ffmpeg__transcoder_8cc_source.html#l04440">encode_video_frame()</a>.</p>

</div>
</div>
<a id="ac14bb3611aadd9d86b6082a234c96004"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac14bb3611aadd9d86b6082a234c96004">&#9670;&nbsp;</a></span>hwframe_ctx_set()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int FFmpeg_Transcoder::hwframe_ctx_set </td>
          <td>(</td>
          <td class="paramtype">AVCodecContext *&#160;</td>
          <td class="paramname"><em>output_codec_ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AVCodecContext *&#160;</td>
          <td class="paramname"><em>input_codec_ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AVBufferRef *&#160;</td>
          <td class="paramname"><em>hw_device_ctx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a reference to an existing decoder hardware frame context or allocates a new AVHWFramesContext tied to the given hardware device context if if the decoder runs in software. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">output_codec_ctx</td><td>- Encoder codexc context </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">input_codec_ctx</td><td>- Decoder codexc context </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">hw_device_ctx</td><td>- Existing hardware device context </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, a negative AVERROR code on failure. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ffmpeg__transcoder_8cc_source.html#l06842">6842</a> of file <a class="el" href="ffmpeg__transcoder_8cc_source.html">ffmpeg_transcoder.cc</a>.</p>

<p class="reference">References <a class="el" href="logging_8h_source.html#l00237">Logging::error()</a>, <a class="el" href="ffmpeg__utils_8cc_source.html#l01139">ffmpeg_geterror()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l07413">find_sw_fmt_by_hw_type()</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l01245">m_enc_hw_pix_fmt</a>, <a class="el" href="ffmpegfs_8h_source.html#l00212">FFMPEGFS_PARAMS::m_hwaccel_enc_device_type</a>, <a class="el" href="ffmpegfs_8cc_source.html#l00072">params</a>, and <a class="el" href="ffmpeg__transcoder_8cc_source.html#l06458">virtname()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ffmpeg__transcoder_8cc_source.html#l01631">add_stream()</a>.</p>

</div>
</div>
<a id="a84df98a3cadf75bd48b2bdc6afbd4846"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84df98a3cadf75bd48b2bdc6afbd4846">&#9670;&nbsp;</a></span>id3v1tag()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structID3v1.html">ID3v1</a> * FFmpeg_Transcoder::id3v1tag </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assemble an <a class="el" href="structID3v1.html" title="ID3 version 1 tag">ID3v1</a> file tag. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns an <a class="el" href="structID3v1.html" title="ID3 version 1 tag">ID3v1</a> file tag. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ffmpeg__transcoder_8cc_source.html#l06174">6174</a> of file <a class="el" href="ffmpeg__transcoder_8cc_source.html">ffmpeg_transcoder.cc</a>.</p>

<p class="reference">References <a class="el" href="ffmpeg__transcoder_8h_source.html#l00163">FFmpeg_Transcoder::OUTPUTFILE::m_id3v1</a>, and <a class="el" href="ffmpeg__transcoder_8h_source.html#l01218">m_out</a>.</p>

<p class="reference">Referenced by <a class="el" href="transcode_8cc_source.html#l00770">transcoder_thread()</a>.</p>

</div>
</div>
<a id="acd06225d230d8a6561e9febfd84d7e03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd06225d230d8a6561e9febfd84d7e03">&#9670;&nbsp;</a></span>init_audio_fifo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int FFmpeg_Transcoder::init_audio_fifo </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialise a FIFO buffer for the audio samples to be encoded. </p>
<dl class="section return"><dt>Returns</dt><dd>On success, returns 0; on error, a negative AVERROR value. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ffmpeg__transcoder_8cc_source.html#l02913">2913</a> of file <a class="el" href="ffmpeg__transcoder_8cc_source.html">ffmpeg_transcoder.cc</a>.</p>

<p class="reference">References <a class="el" href="logging_8h_source.html#l00237">Logging::error()</a>, <a class="el" href="ffmpeg__base_8cc_source.html#l00332">FFmpeg_Base::get_channels()</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l00140">FFmpeg_Transcoder::INPUTFILE::m_audio</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l01206">m_audio_fifo</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l00120">FFmpeg_Transcoder::StreamRef::m_codec_ctx</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l01218">m_out</a>, and <a class="el" href="ffmpeg__transcoder_8cc_source.html#l06458">virtname()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ffmpeg__transcoder_8cc_source.html#l01255">open_output()</a>.</p>

</div>
</div>
<a id="a868b41a725d6670538821f8deb62ac21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a868b41a725d6670538821f8deb62ac21">&#9670;&nbsp;</a></span>init_audio_output_frame()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int FFmpeg_Transcoder::init_audio_output_frame </td>
          <td>(</td>
          <td class="paramtype">AVFrame *&#160;</td>
          <td class="paramname"><em>frame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>frame_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialise one input frame for writing to the output file. The frame will be exactly frame_size samples large. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">frame</td><td>- Newly initialised frame. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">frame_size</td><td>- Size of new frame. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, returns 0; on error, a negative AVERROR value. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ffmpeg__transcoder_8cc_source.html#l04166">4166</a> of file <a class="el" href="ffmpeg__transcoder_8cc_source.html">ffmpeg_transcoder.cc</a>.</p>

<p class="reference">References <a class="el" href="logging_8h_source.html#l00237">Logging::error()</a>, <a class="el" href="ffmpeg__utils_8cc_source.html#l01139">ffmpeg_geterror()</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l00140">FFmpeg_Transcoder::INPUTFILE::m_audio</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l00120">FFmpeg_Transcoder::StreamRef::m_codec_ctx</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l01218">m_out</a>, and <a class="el" href="ffmpeg__transcoder_8cc_source.html#l06458">virtname()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ffmpeg__transcoder_8cc_source.html#l04758">create_audio_frame()</a>.</p>

</div>
</div>
<a id="a509e0e8082e8f270388ebb6abad29907"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a509e0e8082e8f270388ebb6abad29907">&#9670;&nbsp;</a></span>init_converted_samples()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int FFmpeg_Transcoder::init_converted_samples </td>
          <td>(</td>
          <td class="paramtype">uint8_t ***&#160;</td>
          <td class="paramname"><em>converted_input_samples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>frame_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialise a temporary storage for the specified number of audio samples. The conversion requires temporary storage due to the different format. The number of audio samples to be allocated is specified in frame_size. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">converted_input_samples</td><td>- Memory for input samples. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">frame_size</td><td>- Size of one frame. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, returns 0; on error, a negative AVERROR value. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ffmpeg__transcoder_8cc_source.html#l03908">3908</a> of file <a class="el" href="ffmpeg__transcoder_8cc_source.html">ffmpeg_transcoder.cc</a>.</p>

<p class="reference">References <a class="el" href="logging_8h_source.html#l00237">Logging::error()</a>, <a class="el" href="ffmpeg__utils_8cc_source.html#l01139">ffmpeg_geterror()</a>, <a class="el" href="ffmpeg__base_8cc_source.html#l00332">FFmpeg_Base::get_channels()</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l00140">FFmpeg_Transcoder::INPUTFILE::m_audio</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l00120">FFmpeg_Transcoder::StreamRef::m_codec_ctx</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l01218">m_out</a>, and <a class="el" href="ffmpeg__transcoder_8cc_source.html#l06458">virtname()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ffmpeg__transcoder_8cc_source.html#l03251">decode_audio_frame()</a>.</p>

</div>
</div>
<a id="a43f0931f679eebe77ccf75089308c623"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43f0931f679eebe77ccf75089308c623">&#9670;&nbsp;</a></span>init_deinterlace_filters()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int FFmpeg_Transcoder::init_deinterlace_filters </td>
          <td>(</td>
          <td class="paramtype">AVCodecContext *&#160;</td>
          <td class="paramname"><em>codec_ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AVPixelFormat&#160;</td>
          <td class="paramname"><em>pix_fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AVRational &amp;&#160;</td>
          <td class="paramname"><em>avg_frame_rate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AVRational &amp;&#160;</td>
          <td class="paramname"><em>time_base</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialise video filters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">codec_ctx</td><td>- AVCodecContext object of output video. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pix_fmt</td><td>- Output stream pixel format. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">avg_frame_rate</td><td>- Average output stream frame rate. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">time_base</td><td>- Output stream time base. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 if OK, or negative AVERROR value. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ffmpeg__transcoder_8cc_source.html#l06464">6464</a> of file <a class="el" href="ffmpeg__transcoder_8cc_source.html">ffmpeg_transcoder.cc</a>.</p>

<p class="reference">References <a class="el" href="logging_8h_source.html#l00180">Logging::debug()</a>, <a class="el" href="logging_8h_source.html#l00237">Logging::error()</a>, <a class="el" href="ffmpeg__utils_8cc_source.html#l01139">ffmpeg_geterror()</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l01210">m_buffer_sink_context</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l01211">m_buffer_source_context</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l01212">m_filter_graph</a>, <a class="el" href="ffmpeg__utils_8h_source.html#l00738">strsprintf()</a>, and <a class="el" href="ffmpeg__transcoder_8cc_source.html#l06458">virtname()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ffmpeg__transcoder_8cc_source.html#l02592">open_output_filestreams()</a>, and <a class="el" href="ffmpeg__transcoder_8cc_source.html#l01097">open_output_frame_set()</a>.</p>

</div>
</div>
<a id="a6573a50f95e464137ca200abb19dbf5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6573a50f95e464137ca200abb19dbf5e">&#9670;&nbsp;</a></span>init_resampler()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int FFmpeg_Transcoder::init_resampler </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize the audio resampler based on the input and output codec settings. If the input and output sample formats differ, a conversion is required libswresample takes care of this, but requires initialization. </p>
<dl class="section return"><dt>Returns</dt><dd>On success, returns 0; on error, a negative AVERROR value. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ffmpeg__transcoder_8cc_source.html#l02793">2793</a> of file <a class="el" href="ffmpeg__transcoder_8cc_source.html">ffmpeg_transcoder.cc</a>.</p>

<p class="reference">References <a class="el" href="ffmpeg__transcoder_8cc_source.html#l06260">close_resample()</a>, <a class="el" href="logging_8h_source.html#l00180">Logging::debug()</a>, <a class="el" href="logging_8h_source.html#l00237">Logging::error()</a>, <a class="el" href="ffmpeg__utils_8cc_source.html#l01139">ffmpeg_geterror()</a>, <a class="el" href="ffmpeg__utils_8cc_source.html#l01531">format_samplerate()</a>, <a class="el" href="ffmpeg__base_8cc_source.html#l00299">FFmpeg_Base::get_channel_layout_name()</a>, <a class="el" href="ffmpeg__base_8cc_source.html#l00293">FFmpeg_Base::get_sample_fmt_name()</a>, <a class="el" href="ffmpeg__compat_8h_source.html#l00116">LAVU_DEP_OLD_CHANNEL_LAYOUT</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l00140">FFmpeg_Transcoder::INPUTFILE::m_audio</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l01205">m_audio_resample_ctx</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l00120">FFmpeg_Transcoder::StreamRef::m_codec_ctx</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l01201">m_cur_ch_layout</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l01198">m_cur_sample_fmt</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l01199">m_cur_sample_rate</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l01217">m_in</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l01218">m_out</a>, and <a class="el" href="ffmpeg__transcoder_8cc_source.html#l06458">virtname()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ffmpeg__transcoder_8cc_source.html#l03251">decode_audio_frame()</a>.</p>

</div>
</div>
<a id="abcb61c1ba5a92ec7d8c8797f57938228"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcb61c1ba5a92ec7d8c8797f57938228">&#9670;&nbsp;</a></span>init_rescaler()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int FFmpeg_Transcoder::init_rescaler </td>
          <td>(</td>
          <td class="paramtype">AVPixelFormat&#160;</td>
          <td class="paramname"><em>in_pix_fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>in_width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>in_height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AVPixelFormat&#160;</td>
          <td class="paramname"><em>out_pix_fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>out_width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>out_height</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Init image size rescaler and pixel format converter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">in_pix_fmt</td><td>- Input pixel format </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">in_width</td><td>- Input image width </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">in_height</td><td>- Input image height </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">out_pix_fmt</td><td>- Output pixel format </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">out_width</td><td>- Output image width </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">out_height</td><td>- Output pixel format </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 if OK, or negative AVERROR value. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ffmpeg__transcoder_8cc_source.html#l01594">1594</a> of file <a class="el" href="ffmpeg__transcoder_8cc_source.html">ffmpeg_transcoder.cc</a>.</p>

<p class="reference">References <a class="el" href="logging_8h_source.html#l00180">Logging::debug()</a>, <a class="el" href="logging_8h_source.html#l00237">Logging::error()</a>, <a class="el" href="ffmpeg__base_8cc_source.html#l00287">FFmpeg_Base::get_pix_fmt_name()</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l01209">m_sws_ctx</a>, <a class="el" href="logging_8h_source.html#l00161">Logging::trace()</a>, and <a class="el" href="ffmpeg__transcoder_8cc_source.html#l06458">virtname()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ffmpeg__transcoder_8cc_source.html#l01097">open_output_frame_set()</a>.</p>

</div>
</div>
<a id="a203942f9d2bb0d8dbcb547624fe6c728"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a203942f9d2bb0d8dbcb547624fe6c728">&#9670;&nbsp;</a></span>input_read()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int FFmpeg_Transcoder::input_read </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>opaque</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Custom read function for FFmpeg. </p>
<p>Read from virtual files, may be a physical file but also a DVD, VCD or Blu-ray chapter.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">opaque</td><td>- Payload given to FFmpeg, basically the <a class="el" href="classFileIO.html" title="Base class for I/O.">FileIO</a> object </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>- Returned data read from file. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>- Size of data buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, returns bytes read. May be less than size or even 0. On error, returns a negative AVERROR value. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ffmpeg__transcoder_8cc_source.html#l06179">6179</a> of file <a class="el" href="ffmpeg__transcoder_8cc_source.html">ffmpeg_transcoder.cc</a>.</p>

<p class="reference">References <a class="el" href="classFileIO.html#ad7bf956d13e66a11644c30c4b2b7d0ee">FileIO::eof()</a>, <a class="el" href="classFileIO.html#a705727f41def56f0d14c631514d3b115">FileIO::error()</a>, <a class="el" href="logging_8h_source.html#l00237">Logging::error()</a>, and <a class="el" href="classFileIO.html#afe9ad83e019855f655e4c69c3a282f26">FileIO::read()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ffmpeg__transcoder_8cc_source.html#l00306">open_input_file()</a>.</p>

</div>
</div>
<a id="a78591e7d33aa33b2e748299272374d82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78591e7d33aa33b2e748299272374d82">&#9670;&nbsp;</a></span>is_audio_stream()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool FFmpeg_Transcoder::is_audio_stream </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>stream_idx</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check for audio stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">stream_idx</td><td>- ID of stream to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true if stream is an audio stream, false if not. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ffmpeg__transcoder_8cc_source.html#l07470">7470</a> of file <a class="el" href="ffmpeg__transcoder_8cc_source.html">ffmpeg_transcoder.cc</a>.</p>

<p class="reference">References <a class="el" href="ffmpeg__transcoder_8h_source.html#l00140">FFmpeg_Transcoder::INPUTFILE::m_audio</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l01217">m_in</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l00122">FFmpeg_Transcoder::StreamRef::m_stream_idx</a>, and <a class="el" href="ffmpeg__transcoder_8cc_source.html#l07499">stream_exists()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ffmpeg__transcoder_8cc_source.html#l03197">decode()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l03740">decode_frame()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l04037">flush_frames_single()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l04919">process_metadata()</a>, and <a class="el" href="ffmpeg__transcoder_8cc_source.html#l04095">read_decode_convert_and_store()</a>.</p>

</div>
</div>
<a id="ad14124399e5f41dac9c9c9c9a501edbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad14124399e5f41dac9c9c9c9a501edbe">&#9670;&nbsp;</a></span>is_frameset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool FFmpeg_Transcoder::is_frameset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check for an export frame format. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns true for formats that export all frames as images. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ffmpeg__transcoder_8cc_source.html#l06732">6732</a> of file <a class="el" href="ffmpeg__transcoder_8cc_source.html">ffmpeg_transcoder.cc</a>.</p>

<p class="reference">References <a class="el" href="ffmpeg__utils_8cc_source.html#l00917">FFmpegfs_Format::is_frameset()</a>, and <a class="el" href="ffmpeg__transcoder_8h_source.html#l01228">m_current_format</a>.</p>

<p class="reference">Referenced by <a class="el" href="ffmpeg__transcoder_8cc_source.html#l03740">decode_frame()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l06138">encode_finish()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l05103">flush_delayed_video()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l04037">flush_frames_single()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l00844">open_output_file()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l05210">process_single_fr()</a>, and <a class="el" href="transcode_8cc_source.html#l00770">transcoder_thread()</a>.</p>

</div>
</div>
<a id="a730037b1e5595dbe44664e3d2944d544"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a730037b1e5595dbe44664e3d2944d544">&#9670;&nbsp;</a></span>is_hls()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool FFmpeg_Transcoder::is_hls </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check for HLS format. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns true for formats that create an HLS set including the m3u file. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ffmpeg__transcoder_8cc_source.html#l06744">6744</a> of file <a class="el" href="ffmpeg__transcoder_8cc_source.html">ffmpeg_transcoder.cc</a>.</p>

<p class="reference">References <a class="el" href="ffmpeg__utils_8cc_source.html#l00922">FFmpegfs_Format::is_hls()</a>, and <a class="el" href="ffmpeg__transcoder_8h_source.html#l01228">m_current_format</a>.</p>

<p class="reference">Referenced by <a class="el" href="ffmpeg__transcoder_8cc_source.html#l03354">decode_video_frame()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l06138">encode_finish()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l01255">open_output()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l05210">process_single_fr()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l03634">store_packet()</a>, and <a class="el" href="transcode_8cc_source.html#l00770">transcoder_thread()</a>.</p>

</div>
</div>
<a id="a9952d0e524a33781ff89f3cbd7c93aa1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9952d0e524a33781ff89f3cbd7c93aa1">&#9670;&nbsp;</a></span>is_multiformat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool FFmpeg_Transcoder::is_multiformat </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check for an export frame format. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns true for formats that export all frames as images. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ffmpeg__transcoder_8cc_source.html#l06719">6719</a> of file <a class="el" href="ffmpeg__transcoder_8cc_source.html">ffmpeg_transcoder.cc</a>.</p>

<p class="reference">References <a class="el" href="ffmpeg__utils_8cc_source.html#l00912">FFmpegfs_Format::is_multiformat()</a>, and <a class="el" href="ffmpeg__transcoder_8h_source.html#l01228">m_current_format</a>.</p>

<p class="reference">Referenced by <a class="el" href="transcode_8cc_source.html#l00155">transcode_finish()</a>.</p>

</div>
</div>
<a id="abae5d70063ce52f3b9ccf5157265d97b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abae5d70063ce52f3b9ccf5157265d97b">&#9670;&nbsp;</a></span>is_open()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool FFmpeg_Transcoder::is_open </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check if input file is already open.</p>
<dl class="section return"><dt>Returns</dt><dd>true if open; false if closed </dd></dl>

<p class="definition">Definition at line <a class="el" href="ffmpeg__transcoder_8cc_source.html#l00301">301</a> of file <a class="el" href="ffmpeg__transcoder_8cc_source.html">ffmpeg_transcoder.cc</a>.</p>

<p class="reference">References <a class="el" href="ffmpeg__transcoder_8h_source.html#l00138">FFmpeg_Transcoder::INPUTFILE::m_format_ctx</a>, and <a class="el" href="ffmpeg__transcoder_8h_source.html#l01217">m_in</a>.</p>

<p class="reference">Referenced by <a class="el" href="ffmpeg__transcoder_8cc_source.html#l00306">open_input_file()</a>.</p>

</div>
</div>
<a id="a7f504b427d592b7f6f48e07cdc2f3924"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f504b427d592b7f6f48e07cdc2f3924">&#9670;&nbsp;</a></span>is_subtitle_stream()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool FFmpeg_Transcoder::is_subtitle_stream </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>stream_idx</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check for subtitle stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">stream_idx</td><td>- ID of stream to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true if stream is a subtitle stream, false if not. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ffmpeg__transcoder_8cc_source.html#l07480">7480</a> of file <a class="el" href="ffmpeg__transcoder_8cc_source.html">ffmpeg_transcoder.cc</a>.</p>

<p class="reference">References <a class="el" href="ffmpeg__transcoder_8h_source.html#l01217">m_in</a>, and <a class="el" href="ffmpeg__transcoder_8h_source.html#l00143">FFmpeg_Transcoder::INPUTFILE::m_subtitle</a>.</p>

<p class="reference">Referenced by <a class="el" href="ffmpeg__transcoder_8cc_source.html#l03740">decode_frame()</a>.</p>

</div>
</div>
<a id="a6e5172ec9ba20ff8229712b2ce4d2c11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e5172ec9ba20ff8229712b2ce4d2c11">&#9670;&nbsp;</a></span>is_video()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool FFmpeg_Transcoder::is_video </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>FFmpeg handles cover arts like video streams. Try to find out if we have a video stream or a cover art. </p><dl class="section return"><dt>Returns</dt><dd>Return true if file contains a video stream. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ffmpeg__transcoder_8cc_source.html#l00289">289</a> of file <a class="el" href="ffmpeg__transcoder_8cc_source.html">ffmpeg_transcoder.cc</a>.</p>

<p class="reference">References <a class="el" href="ffmpeg__utils_8cc_source.html#l02013">is_album_art()</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l00120">FFmpeg_Transcoder::StreamRef::m_codec_ctx</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l01217">m_in</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l00121">FFmpeg_Transcoder::StreamRef::m_stream</a>, and <a class="el" href="ffmpeg__transcoder_8h_source.html#l00141">FFmpeg_Transcoder::INPUTFILE::m_video</a>.</p>

<p class="reference">Referenced by <a class="el" href="ffmpeg__transcoder_8cc_source.html#l00592">open_bestmatch_video()</a>.</p>

</div>
</div>
<a id="a7bf4228e945ba438112c254354a0729d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bf4228e945ba438112c254354a0729d">&#9670;&nbsp;</a></span>is_video_stream()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool FFmpeg_Transcoder::is_video_stream </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>stream_idx</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check for video stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">stream_idx</td><td>- ID of stream to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true if stream is a video stream, false if not. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ffmpeg__transcoder_8cc_source.html#l07475">7475</a> of file <a class="el" href="ffmpeg__transcoder_8cc_source.html">ffmpeg_transcoder.cc</a>.</p>

<p class="reference">References <a class="el" href="ffmpeg__transcoder_8h_source.html#l01217">m_in</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l00122">FFmpeg_Transcoder::StreamRef::m_stream_idx</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l00141">FFmpeg_Transcoder::INPUTFILE::m_video</a>, and <a class="el" href="ffmpeg__transcoder_8cc_source.html#l07499">stream_exists()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ffmpeg__transcoder_8cc_source.html#l03197">decode()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l03740">decode_frame()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l04037">flush_frames_single()</a>, and <a class="el" href="ffmpeg__transcoder_8cc_source.html#l04919">process_metadata()</a>.</p>

</div>
</div>
<a id="a37e2d8c74a1111eed8951c8a7748c9fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37e2d8c74a1111eed8951c8a7748c9fb">&#9670;&nbsp;</a></span>map_in_to_out_stream()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int FFmpeg_Transcoder::map_in_to_out_stream </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>in_stream_idx</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Map input stream index to output stream index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">in_stream_idx</td><td>- Index of input stream </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns output stream index or INVALID_STREAM if no match </dd></dl>

<p class="definition">Definition at line <a class="el" href="ffmpeg__transcoder_8cc_source.html#l07512">7512</a> of file <a class="el" href="ffmpeg__transcoder_8cc_source.html">ffmpeg_transcoder.cc</a>.</p>

<p class="reference">References <a class="el" href="ffmpeg__utils_8h_source.html#l00074">INVALID_STREAM</a>, and <a class="el" href="ffmpeg__transcoder_8h_source.html#l01219">m_stream_map</a>.</p>

<p class="reference">Referenced by <a class="el" href="ffmpeg__transcoder_8cc_source.html#l02762">add_subtitle_streams()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l03564">decode_subtitle()</a>, and <a class="el" href="ffmpeg__transcoder_8cc_source.html#l01255">open_output()</a>.</p>

</div>
</div>
<a id="ac390e42bd912f1579fc27b33495f2f08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac390e42bd912f1579fc27b33495f2f08">&#9670;&nbsp;</a></span>mtime()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">time_t FFmpeg_Transcoder::mtime </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get last modification time of file. </p>
<dl class="section return"><dt>Returns</dt><dd>Modification time (seconds since epoch) </dd></dl>

<p class="definition">Definition at line <a class="el" href="ffmpeg__transcoder_8cc_source.html#l04848">4848</a> of file <a class="el" href="ffmpeg__transcoder_8cc_source.html">ffmpeg_transcoder.cc</a>.</p>

<p class="reference">References <a class="el" href="ffmpeg__transcoder_8h_source.html#l01187">m_mtime</a>.</p>

</div>
</div>
<a id="a0c9bf0428b8c28d8c09e748ed987c1aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c9bf0428b8c28d8c09e748ed987c1aa">&#9670;&nbsp;</a></span>open_albumarts()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int FFmpeg_Transcoder::open_albumarts </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>open_albumarts </p>
<dl class="section return"><dt>Returns</dt><dd>On success, returns 0; on error, a negative AVERROR value. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ffmpeg__transcoder_8cc_source.html#l00761">761</a> of file <a class="el" href="ffmpeg__transcoder_8cc_source.html">ffmpeg_transcoder.cc</a>.</p>

<p class="reference">References <a class="el" href="logging_8h_source.html#l00237">Logging::error()</a>, <a class="el" href="ffmpeg__utils_8cc_source.html#l01139">ffmpeg_geterror()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l06448">filename()</a>, <a class="el" href="ffmpeg__utils_8cc_source.html#l02013">is_album_art()</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l00145">FFmpeg_Transcoder::INPUTFILE::m_album_art</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l00140">FFmpeg_Transcoder::INPUTFILE::m_audio</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l00138">FFmpeg_Transcoder::INPUTFILE::m_format_ctx</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l01217">m_in</a>, <a class="el" href="ffmpegfs_8h_source.html#l00221">FFMPEGFS_PARAMS::m_noalbumarts</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l00121">FFmpeg_Transcoder::StreamRef::m_stream</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l00122">FFmpeg_Transcoder::StreamRef::m_stream_idx</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l00934">open_decoder()</a>, <a class="el" href="ffmpegfs_8cc_source.html#l00072">params</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l00209">FFmpeg_Transcoder::StreamRef::set_codec_ctx()</a>, and <a class="el" href="logging_8h_source.html#l00161">Logging::trace()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ffmpeg__transcoder_8cc_source.html#l00306">open_input_file()</a>.</p>

</div>
</div>
<a id="a13cc0b11c9ec3cb067bd9baa72550b7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13cc0b11c9ec3cb067bd9baa72550b7d">&#9670;&nbsp;</a></span>open_bestmatch_audio()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int FFmpeg_Transcoder::open_bestmatch_audio </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Open the best match audio stream. </p>
<dl class="section return"><dt>Returns</dt><dd>On success, returns 0; on error, a negative AVERROR value. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ffmpeg__transcoder_8cc_source.html#l00678">678</a> of file <a class="el" href="ffmpeg__transcoder_8cc_source.html">ffmpeg_transcoder.cc</a>.</p>

<p class="reference">References <a class="el" href="ffmpeg__base_8cc_source.html#l00244">FFmpeg_Base::audio_info()</a>, <a class="el" href="logging_8h_source.html#l00237">Logging::error()</a>, <a class="el" href="ffmpeg__utils_8cc_source.html#l01139">ffmpeg_geterror()</a>, <a class="el" href="ffmpeg__utils_8cc_source.html#l01153">ffmpeg_rescale_q()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l06448">filename()</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l00140">FFmpeg_Transcoder::INPUTFILE::m_audio</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l00138">FFmpeg_Transcoder::INPUTFILE::m_format_ctx</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l01217">m_in</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l00121">FFmpeg_Transcoder::StreamRef::m_stream</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l00122">FFmpeg_Transcoder::StreamRef::m_stream_idx</a>, <a class="el" href="fileio_8h_source.html#l00142">VIRTUALFILE::m_type</a>, <a class="el" href="ffmpeg__base_8h_source.html#l00280">FFmpeg_Base::m_virtualfile</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l00873">open_bestmatch_decoder()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l00209">FFmpeg_Transcoder::StreamRef::set_codec_ctx()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l07499">stream_exists()</a>, <a class="el" href="fileio_8h_source.html#l00099">VIRTUALTYPE_BLURAY</a>, and <a class="el" href="fileio_8h_source.html#l00096">VIRTUALTYPE_DVD</a>.</p>

<p class="reference">Referenced by <a class="el" href="ffmpeg__transcoder_8cc_source.html#l00306">open_input_file()</a>.</p>

</div>
</div>
<a id="ac2bea40522d0bf8c4fb31e55c97881a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2bea40522d0bf8c4fb31e55c97881a7">&#9670;&nbsp;</a></span>open_bestmatch_decoder()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int FFmpeg_Transcoder::open_bestmatch_decoder </td>
          <td>(</td>
          <td class="paramtype">AVFormatContext *&#160;</td>
          <td class="paramname"><em>format_ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AVCodecContext **&#160;</td>
          <td class="paramname"><em>codec_ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>stream_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AVMediaType&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find best match stream and open codec context for it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">format_ctx</td><td>- Output format context </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">codec_ctx,-</td><td>Newly created codec context </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stream_idx</td><td>- Stream index of new stream. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>- Type of media: audio or video. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, returns 0; on error, a negative AVERROR value. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ffmpeg__transcoder_8cc_source.html#l00873">873</a> of file <a class="el" href="ffmpeg__transcoder_8cc_source.html">ffmpeg_transcoder.cc</a>.</p>

<p class="reference">References <a class="el" href="logging_8h_source.html#l00237">Logging::error()</a>, <a class="el" href="ffmpeg__utils_8cc_source.html#l01139">ffmpeg_geterror()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l06448">filename()</a>, <a class="el" href="ffmpeg__utils_8cc_source.html#l01184">get_media_type_string()</a>, <a class="el" href="ffmpeg__utils_8h_source.html#l00074">INVALID_STREAM</a>, and <a class="el" href="ffmpeg__transcoder_8cc_source.html#l00934">open_decoder()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ffmpeg__transcoder_8cc_source.html#l07590">add_external_subtitle_stream()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l00678">open_bestmatch_audio()</a>, and <a class="el" href="ffmpeg__transcoder_8cc_source.html#l00592">open_bestmatch_video()</a>.</p>

</div>
</div>
<a id="a4b605803534f5b45472efc419952ffc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b605803534f5b45472efc419952ffc3">&#9670;&nbsp;</a></span>open_bestmatch_video()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int FFmpeg_Transcoder::open_bestmatch_video </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Open the best match video stream, if present in input file. </p>
<dl class="section return"><dt>Returns</dt><dd>On success, returns 0; on error, a negative AVERROR value. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ffmpeg__transcoder_8cc_source.html#l00592">592</a> of file <a class="el" href="ffmpeg__transcoder_8cc_source.html">ffmpeg_transcoder.cc</a>.</p>

<p class="reference">References <a class="el" href="logging_8h_source.html#l00180">Logging::debug()</a>, <a class="el" href="logging_8h_source.html#l00237">Logging::error()</a>, <a class="el" href="ffmpeg__utils_8cc_source.html#l01139">ffmpeg_geterror()</a>, <a class="el" href="ffmpeg__utils_8cc_source.html#l01153">ffmpeg_rescale_q()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l06448">filename()</a>, <a class="el" href="ffmpeg__utils_8cc_source.html#l01354">get_codec_name()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l07059">get_hw_encoder_name()</a>, <a class="el" href="ffmpegfs_8cc_source.html#l01590">get_hwaccel_API_text()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l06791">hwdevice_ctx_create()</a>, <a class="el" href="logging_8h_source.html#l00199">Logging::info()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l00289">is_video()</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l00120">FFmpeg_Transcoder::StreamRef::m_codec_ctx</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l01228">m_current_format</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l00138">FFmpeg_Transcoder::INPUTFILE::m_format_ctx</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l01241">m_hwaccel_enable_enc_buffering</a>, <a class="el" href="ffmpegfs_8h_source.html#l00211">FFMPEGFS_PARAMS::m_hwaccel_enc_API</a>, <a class="el" href="ffmpegfs_8h_source.html#l00213">FFMPEGFS_PARAMS::m_hwaccel_enc_device</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l01243">m_hwaccel_enc_device_ctx</a>, <a class="el" href="ffmpegfs_8h_source.html#l00212">FFMPEGFS_PARAMS::m_hwaccel_enc_device_type</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l01217">m_in</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l01193">m_is_video</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l00121">FFmpeg_Transcoder::StreamRef::m_stream</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l00122">FFmpeg_Transcoder::StreamRef::m_stream_idx</a>, <a class="el" href="fileio_8h_source.html#l00142">VIRTUALFILE::m_type</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l00141">FFmpeg_Transcoder::INPUTFILE::m_video</a>, <a class="el" href="ffmpeg__base_8h_source.html#l00280">FFmpeg_Base::m_virtualfile</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l00873">open_bestmatch_decoder()</a>, <a class="el" href="ffmpegfs_8cc_source.html#l00072">params</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l00209">FFmpeg_Transcoder::StreamRef::set_codec_ctx()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l07499">stream_exists()</a>, <a class="el" href="logging_8h_source.html#l00161">Logging::trace()</a>, <a class="el" href="ffmpeg__utils_8cc_source.html#l00932">FFmpegfs_Format::video_codec()</a>, <a class="el" href="ffmpeg__base_8cc_source.html#l00219">FFmpeg_Base::video_info()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l06458">virtname()</a>, <a class="el" href="fileio_8h_source.html#l00099">VIRTUALTYPE_BLURAY</a>, and <a class="el" href="fileio_8h_source.html#l00096">VIRTUALTYPE_DVD</a>.</p>

<p class="reference">Referenced by <a class="el" href="ffmpeg__transcoder_8cc_source.html#l00306">open_input_file()</a>.</p>

</div>
</div>
<a id="aa930a77b301f5a24bb3c2fafa85b89e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa930a77b301f5a24bb3c2fafa85b89e9">&#9670;&nbsp;</a></span>open_decoder()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int FFmpeg_Transcoder::open_decoder </td>
          <td>(</td>
          <td class="paramtype">AVFormatContext *&#160;</td>
          <td class="paramname"><em>format_ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AVCodecContext **&#160;</td>
          <td class="paramname"><em>codec_ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>stream_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AVCodec *&#160;</td>
          <td class="paramname"><em>input_codec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AVMediaType&#160;</td>
          <td class="paramname"><em>mediatype</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Open codec context for stream_idx. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">format_ctx</td><td>- Output format context </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">codec_ctx</td><td>- Newly created codec context </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stream_idx</td><td>- Stream index of new stream. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">input_codec</td><td>- Decoder codec to open, may be nullptr. Will open a matching codec automatically. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mediatype</td><td>- Type of media: audio or video. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, returns 0; on error, a negative AVERROR value. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ffmpeg__transcoder_8cc_source.html#l00934">934</a> of file <a class="el" href="ffmpeg__transcoder_8cc_source.html">ffmpeg_transcoder.cc</a>.</p>

<p class="reference">References <a class="el" href="logging_8h_source.html#l00237">Logging::error()</a>, <a class="el" href="ffmpegfs_8h_source.html#l00214">FFMPEGFS_PARAMS::m_hwaccel_dec_API</a>, and <a class="el" href="ffmpegfs_8cc_source.html#l00072">params</a>.</p>

<p class="reference">Referenced by <a class="el" href="ffmpeg__transcoder_8cc_source.html#l00761">open_albumarts()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l00873">open_bestmatch_decoder()</a>, and <a class="el" href="ffmpeg__transcoder_8cc_source.html#l00717">open_subtitles()</a>.</p>

</div>
</div>
<a id="a556a0c7071ee2e8e249ef35eb7c64ec7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a556a0c7071ee2e8e249ef35eb7c64ec7">&#9670;&nbsp;</a></span>open_input_file()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int FFmpeg_Transcoder::open_input_file </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="fileio_8h.html#ae8356f209b2b74cc385a8d7551f1f27a">LPVIRTUALFILE</a>&#160;</td>
          <td class="paramname"><em>virtualfile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classFileIO.html">FileIO</a> *&#160;</td>
          <td class="paramname"><em>fio</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Open the given FFmpeg file and prepare for decoding. Collect information for the file (duration, bitrate, etc.). After this function, the other methods can be used to process the file.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">virtualfile</td><td>- Virtualfile object for desired file. May be a physical file, a DVD, Blu-ray or video CD </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">fio</td><td>- Pass an already open fileio object. Normally the file is opened, but if this parameter is not nullptr the already existing object is used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, returns 0; on error, a negative AVERROR value. </dd></dl>
<dl class="bug"><dt><b><a class="el" href="bug.html#_bug000001">Bug:</a></b></dt><dd>Fix memory leak: Probably in FFmpeg API av_probe_input_buffer2(), the av_reallocp is missing a matching free() call... <br  />
<br  />
102,400 bytes in 1 blocks are definitely lost in loss record 248 of 249 <br  />
 in FFmpeg_Transcoder::open_input_file(VIRTUALFILE*, FileIO*) in /home/norbert/dev/prj/ffmpegfs/src/ffmpeg_transcoder.cc:368 <br  />
 1: realloc in ./coregrind/m_replacemalloc/vg_replace_malloc.c:834 <br  />
 2: av_realloc_f in /usr/lib/x86_64-linux-gnu/libavutil.so.56.51.100 <br  />
 3: /usr/lib/x86_64-linux-gnu/libavformat.so.58.45.100 <br  />
 4: av_probe_input_buffer2 in /usr/lib/x86_64-linux-gnu/libavformat.so.58.45.100 <br  />
 5: avformat_open_input in /usr/lib/x86_64-linux-gnu/libavformat.so.58.45.100 <br  />
 6: FFmpeg_Transcoder::open_input_file(VIRTUALFILE*, FileIO*) in /home/norbert/dev/prj/ffmpegfs/src/ffmpeg_transcoder.cc:368 <br  />
 7: transcoder_predict_filesize(VIRTUALFILE*, Cache_Entry*) in /home/norbert/dev/prj/ffmpegfs/src/transcode.cc:320 <br  />
 8: transcoder_new(VIRTUALFILE*, bool) in /home/norbert/dev/prj/ffmpegfs/src/transcode.cc:425 <br  />
 9: <a class="el" href="fuseops_8cc.html#a823061cda8036c46d185b5edd62bf770" title="Get file attributes.">ffmpegfs_getattr(char const*, stat*)</a> in /home/norbert/dev/prj/ffmpegfs/src/fuseops.cc:1323 <br  />
 10: /usr/lib/x86_64-linux-gnu/libfuse.so.2.9.9 <br  />
 11: /usr/lib/x86_64-linux-gnu/libfuse.so.2.9.9 <br  />
 12: /usr/lib/x86_64-linux-gnu/libfuse.so.2.9.9 <br  />
 13: /usr/lib/x86_64-linux-gnu/libfuse.so.2.9.9 <br  />
 14: start_thread in ./nptl/pthread_create.c:477 <br  />
 15: clone in ./misc/../sysdeps/unix/sysv/linux/x86_64/clone.S:95 <br  />
 </dd></dl>

<p class="definition">Definition at line <a class="el" href="ffmpeg__transcoder_8cc_source.html#l00306">306</a> of file <a class="el" href="ffmpeg__transcoder_8cc_source.html">ffmpeg_transcoder.cc</a>.</p>

<p class="reference">References <a class="el" href="fileio_8cc_source.html#l00066">FileIO::alloc()</a>, <a class="el" href="classFileIO.html#a9ef072d7a6f475c0b185c3912d828342">FileIO::bufsize()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l06046">calculate_predicted_filesize()</a>, <a class="el" href="ffmpegfs_8cc_source.html#l00233">FFMPEGFS_PARAMS::current_format()</a>, <a class="el" href="logging_8h_source.html#l00180">Logging::debug()</a>, <a class="el" href="ffmpeg__base_8cc_source.html#l00173">FFmpeg_Base::dict_set_with_check()</a>, <a class="el" href="classFileIO.html#aaffdefd15fa7c5e54a9733b1770c8bcd">FileIO::duration()</a>, <a class="el" href="logging_8h_source.html#l00237">Logging::error()</a>, <a class="el" href="ffmpeg__utils_8h_source.html#l00136">FF_INPUT_BUFFER_PADDING_SIZE</a>, <a class="el" href="ffmpeg__utils_8cc_source.html#l01139">ffmpeg_geterror()</a>, <a class="el" href="ffmpeg__utils_8cc_source.html#l01153">ffmpeg_rescale_q()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l06448">filename()</a>, <a class="el" href="ffmpeg__utils_8cc_source.html#l01468">get_filetype_from_list()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l06179">input_read()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l00301">is_open()</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l00140">FFmpeg_Transcoder::INPUTFILE::m_audio</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l01186">m_close_fileio</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l00120">FFmpeg_Transcoder::StreamRef::m_codec_ctx</a>, <a class="el" href="structVIRTUALFILE.html#ac05832e00e22fb501023551962d2879c">VIRTUALFILE::m_cuesheet_track</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l01228">m_current_format</a>, <a class="el" href="fileio_8h_source.html#l00152">VIRTUALFILE::m_duration</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l01185">m_fileio</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l00136">FFmpeg_Transcoder::INPUTFILE::m_filetype</a>, <a class="el" href="fileio_8h_source.html#l00143">VIRTUALFILE::m_flags</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l00138">FFmpeg_Transcoder::INPUTFILE::m_format_ctx</a>, <a class="el" href="fileio_8h_source.html#l00247">VIRTUALFILE::m_framerate</a>, <a class="el" href="fileio_8h_source.html#l00246">VIRTUALFILE::m_height</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l01217">m_in</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l01187">m_mtime</a>, <a class="el" href="ffmpegfs_8h_source.html#l00219">FFMPEGFS_PARAMS::m_no_subtitles</a>, <a class="el" href="fileio_8h_source.html#l00153">VIRTUALFILE::m_predicted_size</a>, <a class="el" href="fileio_8h_source.html#l00149">VIRTUALFILE::m_st</a>, <a class="el" href="fileio_8h_source.html#l00234">VIRTUALFILE::CUESHEET_TRACK::m_start</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l00121">FFmpeg_Transcoder::StreamRef::m_stream</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l00122">FFmpeg_Transcoder::StreamRef::m_stream_idx</a>, <a class="el" href="fileio_8h_source.html#l00142">VIRTUALFILE::m_type</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l00141">FFmpeg_Transcoder::INPUTFILE::m_video</a>, <a class="el" href="fileio_8h_source.html#l00154">VIRTUALFILE::m_video_frame_count</a>, <a class="el" href="ffmpeg__base_8h_source.html#l00280">FFmpeg_Base::m_virtualfile</a>, <a class="el" href="fileio_8h_source.html#l00245">VIRTUALFILE::m_width</a>, <a class="el" href="classFileIO.html#ac6f8d683c47d7b37a8d20351f084af10">FileIO::open()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l00761">open_albumarts()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l00678">open_bestmatch_audio()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l00592">open_bestmatch_video()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l00717">open_subtitles()</a>, <a class="el" href="ffmpegfs_8cc_source.html#l00072">params</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l06225">seek()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l07499">stream_exists()</a>, <a class="el" href="fileio_8h_source.html#l00113">VIRTUALFLAG_CUESHEET</a>, <a class="el" href="fileio_8h_source.html#l00099">VIRTUALTYPE_BLURAY</a>, <a class="el" href="fileio_8h_source.html#l00096">VIRTUALTYPE_DVD</a>, <a class="el" href="fileio_8h_source.html#l00093">VIRTUALTYPE_VCD</a>, and <a class="el" href="logging_8h_source.html#l00218">Logging::warning()</a>.</p>

<p class="reference">Referenced by <a class="el" href="transcode_8cc_source.html#l00329">transcoder_predict_filesize()</a>, and <a class="el" href="transcode_8cc_source.html#l00770">transcoder_thread()</a>.</p>

</div>
</div>
<a id="a0d77a6730de37eff3a8dc295e95a4c9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d77a6730de37eff3a8dc295e95a4c9d">&#9670;&nbsp;</a></span>open_output()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int FFmpeg_Transcoder::open_output </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classBuffer.html">Buffer</a> *&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Open output file. Data will actually be written to buffer and copied by FUSE when accessed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>- Stream buffer to operate on </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, returns 0; on error, a negative AVERROR value. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ffmpeg__transcoder_8cc_source.html#l01255">1255</a> of file <a class="el" href="ffmpeg__transcoder_8cc_source.html">ffmpeg_transcoder.cc</a>.</p>

<p class="reference">References <a class="el" href="ffmpeg__base_8cc_source.html#l00244">FFmpeg_Base::audio_info()</a>, <a class="el" href="buffer_8h_source.html#l00050">CACHE_FLAG_RW</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l06343">close_output_file()</a>, <a class="el" href="logging_8h_source.html#l00237">Logging::error()</a>, <a class="el" href="ffmpeg__utils_8cc_source.html#l01168">ffmpeg_rescale_q_rnd()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l06448">filename()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l07487">get_out_subtitle_stream()</a>, <a class="el" href="fileio_8cc_source.html#l00048">VIRTUALFILE::get_segment_count()</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l00171">HWACCELMODE_ENABLED</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l00172">HWACCELMODE_FALLBACK</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l06833">hwdevice_ctx_free()</a>, <a class="el" href="logging_8h_source.html#l00199">Logging::info()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l02913">init_audio_fifo()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l06744">is_hls()</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l00140">FFmpeg_Transcoder::INPUTFILE::m_audio</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l00159">FFmpeg_Transcoder::OUTPUTFILE::m_audio_pts</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l01230">m_buffer</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l00120">FFmpeg_Transcoder::StreamRef::m_codec_ctx</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l01228">m_current_format</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l01221">m_current_segment</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l01245">m_enc_hw_pix_fmt</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l00138">FFmpeg_Transcoder::INPUTFILE::m_format_ctx</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l01241">m_hwaccel_enable_enc_buffering</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l01243">m_hwaccel_enc_device_ctx</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l01239">m_hwaccel_enc_mode</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l01217">m_in</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l01222">m_insert_keyframe</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l00161">FFmpeg_Transcoder::OUTPUTFILE::m_last_mux_dts</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l01218">m_out</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l00123">FFmpeg_Transcoder::StreamRef::m_start_time</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l00121">FFmpeg_Transcoder::StreamRef::m_stream</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l00122">FFmpeg_Transcoder::StreamRef::m_stream_idx</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l00143">FFmpeg_Transcoder::INPUTFILE::m_subtitle</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l00141">FFmpeg_Transcoder::INPUTFILE::m_video</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l00160">FFmpeg_Transcoder::OUTPUTFILE::m_video_pts</a>, <a class="el" href="ffmpeg__base_8h_source.html#l00280">FFmpeg_Base::m_virtualfile</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l07512">map_in_to_out_stream()</a>, <a class="el" href="buffer_8cc_source.html#l00078">Buffer::open_file()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l02592">open_output_filestreams()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l06123">predicted_filesize()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l01396">process_output()</a>, <a class="el" href="buffer_8cc_source.html#l00605">Buffer::reserve()</a>, <a class="el" href="buffer_8cc_source.html#l00822">Buffer::size()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l07499">stream_exists()</a>, <a class="el" href="ffmpeg__base_8cc_source.html#l00271">FFmpeg_Base::subtitle_info()</a>, <a class="el" href="ffmpeg__utils_8cc_source.html#l00932">FFmpegfs_Format::video_codec()</a>, <a class="el" href="ffmpeg__base_8cc_source.html#l00219">FFmpeg_Base::video_info()</a>, and <a class="el" href="ffmpeg__transcoder_8cc_source.html#l06458">virtname()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ffmpeg__transcoder_8cc_source.html#l00844">open_output_file()</a>, and <a class="el" href="ffmpeg__transcoder_8cc_source.html#l05490">start_new_segment()</a>.</p>

</div>
</div>
<a id="ac17eddfaa818018ceabb87165d44b968"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac17eddfaa818018ceabb87165d44b968">&#9670;&nbsp;</a></span>open_output_file()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int FFmpeg_Transcoder::open_output_file </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classBuffer.html">Buffer</a> *&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Open output file. Data will actually be written to buffer and copied by FUSE when accessed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>- <a class="el" href="classCache.html" title="The Cache class.">Cache</a> buffer to be written. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, returns 0; on error, a negative AVERROR value. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ffmpeg__transcoder_8cc_source.html#l00844">844</a> of file <a class="el" href="ffmpeg__transcoder_8cc_source.html">ffmpeg_transcoder.cc</a>.</p>

<p class="reference">References <a class="el" href="logging_8h_source.html#l00180">Logging::debug()</a>, <a class="el" href="ffmpeg__utils_8cc_source.html#l00892">FFmpegfs_Format::desttype()</a>, <a class="el" href="logging_8h_source.html#l00237">Logging::error()</a>, <a class="el" href="ffmpeg__utils_8cc_source.html#l00907">FFmpegfs_Format::filetype()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l06732">is_frameset()</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l00140">FFmpeg_Transcoder::INPUTFILE::m_audio</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l01228">m_current_format</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l00136">FFmpeg_Transcoder::INPUTFILE::m_filetype</a>, <a class="el" href="fileio_8h_source.html#l00143">VIRTUALFILE::m_flags</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l01217">m_in</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l01218">m_out</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l00122">FFmpeg_Transcoder::StreamRef::m_stream_idx</a>, <a class="el" href="ffmpeg__base_8h_source.html#l00280">FFmpeg_Base::m_virtualfile</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l01255">open_output()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l01097">open_output_frame_set()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l07499">stream_exists()</a>, <a class="el" href="ffmpeg__utils_8cc_source.html#l00932">FFmpegfs_Format::video_codec()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l06458">virtname()</a>, and <a class="el" href="fileio_8h_source.html#l00114">VIRTUALFLAG_HIDDEN</a>.</p>

<p class="reference">Referenced by <a class="el" href="transcode_8cc_source.html#l00770">transcoder_thread()</a>.</p>

</div>
</div>
<a id="a97298697701d9e28f8c29580a6951237"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97298697701d9e28f8c29580a6951237">&#9670;&nbsp;</a></span>open_output_filestreams()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int FFmpeg_Transcoder::open_output_filestreams </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classBuffer.html">Buffer</a> *&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Open an output file and the required encoder. Also set some basic encoder parameters. Some of these parameters are based on the input file's parameters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>- Stream buffer to operate on </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, returns 0; on error, a negative AVERROR value. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ffmpeg__transcoder_8cc_source.html#l02592">2592</a> of file <a class="el" href="ffmpeg__transcoder_8cc_source.html">ffmpeg_transcoder.cc</a>.</p>

<p class="reference">References <a class="el" href="ffmpeg__transcoder_8cc_source.html#l02457">add_albumart_stream()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l07732">add_external_subtitle_streams()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l01631">add_stream()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l02378">add_stream_copy()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l02762">add_subtitle_streams()</a>, <a class="el" href="ffmpeg__utils_8cc_source.html#l00927">FFmpegfs_Format::albumart_supported()</a>, <a class="el" href="ffmpeg__utils_8cc_source.html#l00947">FFmpegfs_Format::audio_codec()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l00796">can_copy_stream()</a>, <a class="el" href="logging_8h_source.html#l00180">Logging::debug()</a>, <a class="el" href="ffmpeg__utils_8cc_source.html#l00892">FFmpegfs_Format::desttype()</a>, <a class="el" href="logging_8h_source.html#l00237">Logging::error()</a>, <a class="el" href="ffmpeg__utils_8h_source.html#l00136">FF_INPUT_BUFFER_PADDING_SIZE</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l01248">FFMPEGFS_AUDIO</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l01249">FFMPEGFS_VIDEO</a>, <a class="el" href="ffmpeg__utils_8cc_source.html#l00907">FFmpegfs_Format::filetype()</a>, <a class="el" href="ffmpeg__utils_8cc_source.html#l00897">FFmpegfs_Format::format_name()</a>, <a class="el" href="logging_8h_source.html#l00199">Logging::info()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l06464">init_deinterlace_filters()</a>, <a class="el" href="ffmpeg__utils_8h_source.html#l00074">INVALID_STREAM</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l01252">m_active_stream_msk</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l00145">FFmpeg_Transcoder::INPUTFILE::m_album_art</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l00140">FFmpeg_Transcoder::INPUTFILE::m_audio</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l00120">FFmpeg_Transcoder::StreamRef::m_codec_ctx</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l01225">m_copy_audio</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l01226">m_copy_video</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l01228">m_current_format</a>, <a class="el" href="ffmpegfs_8h_source.html#l00206">FFMPEGFS_PARAMS::m_deinterlace</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l00136">FFmpeg_Transcoder::INPUTFILE::m_filetype</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l00138">FFmpeg_Transcoder::INPUTFILE::m_format_ctx</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l01217">m_in</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l01253">m_inhibit_stream_msk</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l01193">m_is_video</a>, <a class="el" href="ffmpegfs_8h_source.html#l00221">FFMPEGFS_PARAMS::m_noalbumarts</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l01218">m_out</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l00142">FFmpeg_Transcoder::INPUTFILE::m_pix_fmt</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l00121">FFmpeg_Transcoder::StreamRef::m_stream</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l00122">FFmpeg_Transcoder::StreamRef::m_stream_idx</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l00143">FFmpeg_Transcoder::INPUTFILE::m_subtitle</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l00141">FFmpeg_Transcoder::INPUTFILE::m_video</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l06206">output_write()</a>, <a class="el" href="ffmpegfs_8cc_source.html#l00072">params</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l06225">seek()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l07499">stream_exists()</a>, <a class="el" href="ffmpeg__utils_8cc_source.html#l00932">FFmpegfs_Format::video_codec()</a>, and <a class="el" href="ffmpeg__transcoder_8cc_source.html#l06458">virtname()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ffmpeg__transcoder_8cc_source.html#l01255">open_output()</a>.</p>

</div>
</div>
<a id="aac45e5ea83a42253119635023ce8d8e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac45e5ea83a42253119635023ce8d8e6">&#9670;&nbsp;</a></span>open_output_frame_set()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int FFmpeg_Transcoder::open_output_frame_set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classBuffer.html">Buffer</a> *&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Open output frame set. Data will actually be written to buffer and copied by FUSE when accessed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>- Stream buffer to operate on </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, returns 0; on error, a negative AVERROR value. </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000008">Todo:</a></b></dt><dd>Make frame image compression rate command line settable </dd></dl>

<p class="definition">Definition at line <a class="el" href="ffmpeg__transcoder_8cc_source.html#l01097">1097</a> of file <a class="el" href="ffmpeg__transcoder_8cc_source.html">ffmpeg_transcoder.cc</a>.</p>

<p class="reference">References <a class="el" href="buffer_8h_source.html#l00050">CACHE_FLAG_RW</a>, <a class="el" href="logging_8h_source.html#l00180">Logging::debug()</a>, <a class="el" href="ffmpeg__base_8cc_source.html#l00173">FFmpeg_Base::dict_set_with_check()</a>, <a class="el" href="logging_8h_source.html#l00237">Logging::error()</a>, <a class="el" href="ffmpeg__base_8cc_source.html#l00287">FFmpeg_Base::get_pix_fmt_name()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l07425">get_pix_formats()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l06464">init_deinterlace_filters()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l01594">init_rescaler()</a>, <a class="el" href="ffmpeg__utils_8h_source.html#l00074">INVALID_STREAM</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l00140">FFmpeg_Transcoder::INPUTFILE::m_audio</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l01230">m_buffer</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l00120">FFmpeg_Transcoder::StreamRef::m_codec_ctx</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l01228">m_current_format</a>, <a class="el" href="ffmpegfs_8h_source.html#l00206">FFMPEGFS_PARAMS::m_deinterlace</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l01191">m_have_seeked</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l01217">m_in</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l01218">m_out</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l00142">FFmpeg_Transcoder::INPUTFILE::m_pix_fmt</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l01189">m_seek_to_fifo</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l01188">m_seek_to_fifo_mutex</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l00121">FFmpeg_Transcoder::StreamRef::m_stream</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l00122">FFmpeg_Transcoder::StreamRef::m_stream_idx</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l00141">FFmpeg_Transcoder::INPUTFILE::m_video</a>, <a class="el" href="buffer_8cc_source.html#l00078">Buffer::open_file()</a>, <a class="el" href="ffmpegfs_8cc_source.html#l00072">params</a>, <a class="el" href="buffer_8cc_source.html#l00605">Buffer::reserve()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l00209">FFmpeg_Transcoder::StreamRef::set_codec_ctx()</a>, <a class="el" href="buffer_8cc_source.html#l00822">Buffer::size()</a>, <a class="el" href="ffmpeg__utils_8cc_source.html#l00932">FFmpegfs_Format::video_codec()</a>, and <a class="el" href="ffmpeg__transcoder_8cc_source.html#l06458">virtname()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ffmpeg__transcoder_8cc_source.html#l00844">open_output_file()</a>.</p>

</div>
</div>
<a id="a47031e756634d90dc5e82eef8b38a618"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47031e756634d90dc5e82eef8b38a618">&#9670;&nbsp;</a></span>open_subtitles()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int FFmpeg_Transcoder::open_subtitles </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Open all subtitles streams, if present in input file and if supported by output file. The input and output codec type must also match: Can only transcode bitmap subtitles into bitmap subtitles or text to text. </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000021">Todo:</a></b></dt><dd>Add text to bitmap conversion. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>On success, returns 0; on error, a negative AVERROR value. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ffmpeg__transcoder_8cc_source.html#l00717">717</a> of file <a class="el" href="ffmpeg__transcoder_8cc_source.html">ffmpeg_transcoder.cc</a>.</p>

<p class="reference">References <a class="el" href="logging_8h_source.html#l00237">Logging::error()</a>, <a class="el" href="ffmpeg__utils_8cc_source.html#l01139">ffmpeg_geterror()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l06448">filename()</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l01228">m_current_format</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l00138">FFmpeg_Transcoder::INPUTFILE::m_format_ctx</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l01217">m_in</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l00121">FFmpeg_Transcoder::StreamRef::m_stream</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l00122">FFmpeg_Transcoder::StreamRef::m_stream_idx</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l00143">FFmpeg_Transcoder::INPUTFILE::m_subtitle</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l00934">open_decoder()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l00209">FFmpeg_Transcoder::StreamRef::set_codec_ctx()</a>, <a class="el" href="ffmpeg__utils_8cc_source.html#l00977">FFmpegfs_Format::subtitle_codec()</a>, and <a class="el" href="ffmpeg__base_8cc_source.html#l00271">FFmpeg_Base::subtitle_info()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ffmpeg__transcoder_8cc_source.html#l00306">open_input_file()</a>.</p>

</div>
</div>
<a id="a3110f05414808742ea6d579191982bf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3110f05414808742ea6d579191982bf5">&#9670;&nbsp;</a></span>output_write()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int FFmpeg_Transcoder::output_write </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>opaque</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Custom write function for FFmpeg. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">opaque</td><td>- Payload given to FFmpeg, basically the <a class="el" href="classFileIO.html" title="Base class for I/O.">FileIO</a> object </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>- Data to be written </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>- Size of data block. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, returns bytes written. On error, returns a negative AVERROR value. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ffmpeg__transcoder_8cc_source.html#l06206">6206</a> of file <a class="el" href="ffmpeg__transcoder_8cc_source.html">ffmpeg_transcoder.cc</a>.</p>

<p class="reference">References <a class="el" href="logging_8h_source.html#l00237">Logging::error()</a>, and <a class="el" href="buffer_8cc_source.html#l00642">Buffer::write()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ffmpeg__transcoder_8cc_source.html#l02592">open_output_filestreams()</a>.</p>

</div>
</div>
<a id="a7a6211a8309c94b646b7f24adb4128ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a6211a8309c94b646b7f24adb4128ce">&#9670;&nbsp;</a></span>predicted_filesize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t FFmpeg_Transcoder::predicted_filesize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Try to predict the recoded file size. This may (better will surely) be inaccurate. </p>
<dl class="section return"><dt>Returns</dt><dd>Predicted file size in bytes. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ffmpeg__transcoder_8cc_source.html#l06123">6123</a> of file <a class="el" href="ffmpeg__transcoder_8cc_source.html">ffmpeg_transcoder.cc</a>.</p>

<p class="reference">References <a class="el" href="ffmpeg__base_8h_source.html#l00280">FFmpeg_Base::m_virtualfile</a>, and <a class="el" href="ffmpeg__utils_8h_source.html#l00152">SAFE_VALUE</a>.</p>

<p class="reference">Referenced by <a class="el" href="ffmpeg__transcoder_8cc_source.html#l03080">create_fake_aiff_header()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l02977">create_fake_wav_header()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l01255">open_output()</a>, <a class="el" href="transcode_8cc_source.html#l00329">transcoder_predict_filesize()</a>, and <a class="el" href="transcode_8cc_source.html#l00770">transcoder_thread()</a>.</p>

</div>
</div>
<a id="a942d65ca55684bbca639af2d0ea30143"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a942d65ca55684bbca639af2d0ea30143">&#9670;&nbsp;</a></span>prepare_codec()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int FFmpeg_Transcoder::prepare_codec </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>opt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ffmpeg__utils_8h.html#adf12e2d9ad420681d96f755088d37237">FILETYPE</a>&#160;</td>
          <td class="paramname"><em>filetype</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prepare codec options for a file type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">opt</td><td>- Codec private data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filetype</td><td>- File type: MP3, MP4 etc. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, returns 0; on error, a negative AVERROR value. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ffmpeg__transcoder_8cc_source.html#l01578">1578</a> of file <a class="el" href="ffmpeg__transcoder_8cc_source.html">ffmpeg_transcoder.cc</a>.</p>

<p class="reference">References <a class="el" href="ffmpeg__profiles_8h_source.html#l00086">FFmpeg_Profiles::m_profile</a>, <a class="el" href="ffmpegfs_8h_source.html#l00195">FFMPEGFS_PARAMS::m_profile</a>, <a class="el" href="ffmpegfs_8cc_source.html#l00072">params</a>, and <a class="el" href="ffmpeg__transcoder_8cc_source.html#l01556">update_codec()</a>.</p>

</div>
</div>
<a id="a446ae8092e28817c97c3fb74ad1acc19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a446ae8092e28817c97c3fb74ad1acc19">&#9670;&nbsp;</a></span>prepare_format()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int FFmpeg_Transcoder::prepare_format </td>
          <td>(</td>
          <td class="paramtype">AVDictionary **&#160;</td>
          <td class="paramname"><em>dict</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ffmpeg__utils_8h.html#adf12e2d9ad420681d96f755088d37237">FILETYPE</a>&#160;</td>
          <td class="paramname"><em>filetype</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prepare format optimisations. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dict</td><td>- Dictionary to update. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filetype</td><td>- File type: MP3, MP4 etc. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, returns 0; on error, a negative AVERROR value. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ffmpeg__transcoder_8cc_source.html#l02954">2954</a> of file <a class="el" href="ffmpeg__transcoder_8cc_source.html">ffmpeg_transcoder.cc</a>.</p>

<p class="reference">References <a class="el" href="ffmpeg__profiles_8h_source.html#l00086">FFmpeg_Profiles::m_profile</a>, <a class="el" href="ffmpegfs_8h_source.html#l00195">FFMPEGFS_PARAMS::m_profile</a>, <a class="el" href="ffmpegfs_8cc_source.html#l00072">params</a>, and <a class="el" href="ffmpeg__transcoder_8cc_source.html#l02925">update_format()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ffmpeg__transcoder_8cc_source.html#l03139">write_output_file_header()</a>.</p>

</div>
</div>
<a id="ab1313f014849b4990dbc7c9b1538c108"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1313f014849b4990dbc7c9b1538c108">&#9670;&nbsp;</a></span>process_albumarts()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int FFmpeg_Transcoder::process_albumarts </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy all album arts from source to target. </p>
<dl class="section return"><dt>Returns</dt><dd>On success, returns 0; on error, a negative AVERROR value. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ffmpeg__transcoder_8cc_source.html#l04971">4971</a> of file <a class="el" href="ffmpeg__transcoder_8cc_source.html">ffmpeg_transcoder.cc</a>.</p>

<p class="reference">References <a class="el" href="ffmpeg__transcoder_8cc_source.html#l02565">add_albumart_frame()</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l00145">FFmpeg_Transcoder::INPUTFILE::m_album_art</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l01217">m_in</a>, and <a class="el" href="ffmpeg__transcoder_8h_source.html#l01218">m_out</a>.</p>

<p class="reference">Referenced by <a class="el" href="ffmpeg__transcoder_8cc_source.html#l01396">process_output()</a>.</p>

</div>
</div>
<a id="abcb1a10b6a56f504f03bd06142e2da43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcb1a10b6a56f504f03bd06142e2da43">&#9670;&nbsp;</a></span>process_metadata()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int FFmpeg_Transcoder::process_metadata </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy metadata from source to target. </p>
<dl class="section return"><dt>Returns</dt><dd>On success, returns 0; on error, a negative AVERROR value. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ffmpeg__transcoder_8cc_source.html#l04919">4919</a> of file <a class="el" href="ffmpeg__transcoder_8cc_source.html">ffmpeg_transcoder.cc</a>.</p>

<p class="reference">References <a class="el" href="ffmpeg__transcoder_8cc_source.html#l04861">copy_metadata()</a>, <a class="el" href="ffmpeg__base_8cc_source.html#l00173">FFmpeg_Base::dict_set_with_check()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l07470">is_audio_stream()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l07475">is_video_stream()</a>, <a class="el" href="fileio_8h_source.html#l00230">VIRTUALFILE::CUESHEET_TRACK::m_album</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l00145">FFmpeg_Transcoder::INPUTFILE::m_album_art</a>, <a class="el" href="fileio_8h_source.html#l00228">VIRTUALFILE::CUESHEET_TRACK::m_artist</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l00140">FFmpeg_Transcoder::INPUTFILE::m_audio</a>, <a class="el" href="structVIRTUALFILE.html#ac05832e00e22fb501023551962d2879c">VIRTUALFILE::m_cuesheet_track</a>, <a class="el" href="fileio_8h_source.html#l00232">VIRTUALFILE::CUESHEET_TRACK::m_date</a>, <a class="el" href="fileio_8h_source.html#l00143">VIRTUALFILE::m_flags</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l00138">FFmpeg_Transcoder::INPUTFILE::m_format_ctx</a>, <a class="el" href="fileio_8h_source.html#l00231">VIRTUALFILE::CUESHEET_TRACK::m_genre</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l01217">m_in</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l01218">m_out</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l00121">FFmpeg_Transcoder::StreamRef::m_stream</a>, <a class="el" href="fileio_8h_source.html#l00229">VIRTUALFILE::CUESHEET_TRACK::m_title</a>, <a class="el" href="fileio_8h_source.html#l00227">VIRTUALFILE::CUESHEET_TRACK::m_trackno</a>, <a class="el" href="fileio_8h_source.html#l00226">VIRTUALFILE::CUESHEET_TRACK::m_tracktotal</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l00141">FFmpeg_Transcoder::INPUTFILE::m_video</a>, <a class="el" href="ffmpeg__base_8h_source.html#l00280">FFmpeg_Base::m_virtualfile</a>, <a class="el" href="logging_8h_source.html#l00161">Logging::trace()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l06458">virtname()</a>, and <a class="el" href="fileio_8h_source.html#l00113">VIRTUALFLAG_CUESHEET</a>.</p>

<p class="reference">Referenced by <a class="el" href="ffmpeg__transcoder_8cc_source.html#l01396">process_output()</a>.</p>

</div>
</div>
<a id="ad5bdbf25667f6f7440ddc5194e39aac9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5bdbf25667f6f7440ddc5194e39aac9">&#9670;&nbsp;</a></span>process_output()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int FFmpeg_Transcoder::process_output </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Process headers of output file Write file header, process meta data and add album arts. </p>
<dl class="section return"><dt>Returns</dt><dd>On success, returns 0; on error, a negative AVERROR value. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ffmpeg__transcoder_8cc_source.html#l01396">1396</a> of file <a class="el" href="ffmpeg__transcoder_8cc_source.html">ffmpeg_transcoder.cc</a>.</p>

<p class="reference">References <a class="el" href="ffmpeg__transcoder_8cc_source.html#l04971">process_albumarts()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l04919">process_metadata()</a>, and <a class="el" href="ffmpeg__transcoder_8cc_source.html#l03139">write_output_file_header()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ffmpeg__transcoder_8cc_source.html#l01255">open_output()</a>, and <a class="el" href="ffmpeg__transcoder_8cc_source.html#l05490">start_new_segment()</a>.</p>

</div>
</div>
<a id="a33fe2abcc0767204dcd6dab22980d54e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33fe2abcc0767204dcd6dab22980d54e">&#9670;&nbsp;</a></span>process_single_fr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int FFmpeg_Transcoder::process_single_fr </td>
          <td>(</td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>status</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Process a single frame of audio data. The encode_pcm_data() method of the Encoder will be used to process the resulting audio data, with the result going into the given <a class="el" href="classBuffer.html" title="The Buffer class.">Buffer</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">status</td><td>- On success, returns 0; if at EOF, returns 1; on error, returns -1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, returns 0; on error, a negative AVERROR value. If EOF is reached, it returns 1. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ffmpeg__transcoder_8cc_source.html#l05210">5210</a> of file <a class="el" href="ffmpeg__transcoder_8cc_source.html">ffmpeg_transcoder.cc</a>.</p>

<p class="reference">References <a class="el" href="ffmpeg__transcoder_8cc_source.html#l05146">copy_audio_to_frame_buffer()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l04245">encode_audio_frame()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l04323">encode_image_frame()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l04620">encode_subtitle()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l04440">encode_video_frame()</a>, <a class="el" href="logging_8h_source.html#l00237">Logging::error()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l05073">flush_delayed_audio()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l05141">flush_delayed_subtitles()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l05103">flush_delayed_video()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l07460">get_next_segment()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l07465">goto_next_segment()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l06732">is_frameset()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l06744">is_hls()</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l01252">m_active_stream_msk</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l00140">FFmpeg_Transcoder::INPUTFILE::m_audio</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l01225">m_copy_audio</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l01195">m_frame_map</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l01217">m_in</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l01253">m_inhibit_stream_msk</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l01218">m_out</a>, <a class="el" href="ffmpegfs_8h_source.html#l00208">FFMPEGFS_PARAMS::m_segment_duration</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l00121">FFmpeg_Transcoder::StreamRef::m_stream</a>, <a class="el" href="ffmpeg__frame_8h_source.html#l00119">FFmpeg_Frame::m_stream_idx</a>, <a class="el" href="ffmpeg__subtitle_8h_source.html#l00094">FFmpeg_Subtitle::m_stream_idx</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l00122">FFmpeg_Transcoder::StreamRef::m_stream_idx</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l00141">FFmpeg_Transcoder::INPUTFILE::m_video</a>, <a class="el" href="ffmpegfs_8cc_source.html#l00072">params</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l04095">read_decode_convert_and_store()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l05433">seek_frame()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l05490">start_new_segment()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l07499">stream_exists()</a>, and <a class="el" href="ffmpeg__transcoder_8cc_source.html#l06458">virtname()</a>.</p>

<p class="reference">Referenced by <a class="el" href="transcode_8cc_source.html#l00770">transcoder_thread()</a>.</p>

</div>
</div>
<a id="ae9493510e3944742d2027f0d2b459f0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9493510e3944742d2027f0d2b459f0c">&#9670;&nbsp;</a></span>produce_audio_dts()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void FFmpeg_Transcoder::produce_audio_dts </td>
          <td>(</td>
          <td class="paramtype">AVPacket *&#160;</td>
          <td class="paramname"><em>pkt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Produce audio dts/pts. This is required because the target codec usually has a different frame size than the source, so the number of packets will not match 1:1. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pkt</td><td>- Packet to add dts/pts to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000013">Todo:</a></b></dt><dd>Is this a FFmpeg bug or am I too stupid? <br  />
OPUS is a bit strange. Whatever we feed into the encoder, the result will always be floating point planar at 48 K sampling rate. <br  />
For some reason the duration calculated by the FFMpeg API is wrong. We have to rescale it to the correct value. Same applies to mpegts, so let's rescale. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ffmpeg__transcoder_8cc_source.html#l04205">4205</a> of file <a class="el" href="ffmpeg__transcoder_8cc_source.html">ffmpeg_transcoder.cc</a>.</p>

<p class="reference">References <a class="el" href="ffmpeg__transcoder_8cc_source.html#l06118">duration()</a>, <a class="el" href="ffmpeg__utils_8cc_source.html#l00907">FFmpegfs_Format::filetype()</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l00140">FFmpeg_Transcoder::INPUTFILE::m_audio</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l00120">FFmpeg_Transcoder::StreamRef::m_codec_ctx</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l01228">m_current_format</a>, and <a class="el" href="ffmpeg__transcoder_8h_source.html#l01218">m_out</a>.</p>

<p class="reference">Referenced by <a class="el" href="ffmpeg__transcoder_8cc_source.html#l04245">encode_audio_frame()</a>.</p>

</div>
</div>
<a id="a118d031aacd8398c1696ea1fc3f25a71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a118d031aacd8398c1696ea1fc3f25a71">&#9670;&nbsp;</a></span>purge_audio_fifo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int FFmpeg_Transcoder::purge_audio_fifo </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Purge all samples in audio FIFO. </p>
<dl class="section return"><dt>Returns</dt><dd>Number of samples that have been purged. Function never fails. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ffmpeg__transcoder_8cc_source.html#l06272">6272</a> of file <a class="el" href="ffmpeg__transcoder_8cc_source.html">ffmpeg_transcoder.cc</a>.</p>

<p class="reference">References <a class="el" href="ffmpeg__transcoder_8h_source.html#l01206">m_audio_fifo</a>.</p>

<p class="reference">Referenced by <a class="el" href="ffmpeg__transcoder_8cc_source.html#l06310">purge()</a>.</p>

</div>
</div>
<a id="accfa0ea6196c1211b3aa4acce34597c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accfa0ea6196c1211b3aa4acce34597c6">&#9670;&nbsp;</a></span>purge_hls_fifo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t FFmpeg_Transcoder::purge_hls_fifo </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Purge all packets in HLS FIFO buffer. </p>
<dl class="section return"><dt>Returns</dt><dd>Number of Packets that have been purged. Function never fails. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ffmpeg__transcoder_8cc_source.html#l06295">6295</a> of file <a class="el" href="ffmpeg__transcoder_8cc_source.html">ffmpeg_transcoder.cc</a>.</p>

<p class="reference">References <a class="el" href="ffmpeg__transcoder_8h_source.html#l01254">m_hls_packet_fifo</a>.</p>

<p class="reference">Referenced by <a class="el" href="ffmpeg__transcoder_8cc_source.html#l06310">purge()</a>, and <a class="el" href="ffmpeg__transcoder_8cc_source.html#l05490">start_new_segment()</a>.</p>

</div>
</div>
<a id="a269aac0e72c7132ab8ec33f4e715afe2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a269aac0e72c7132ab8ec33f4e715afe2">&#9670;&nbsp;</a></span>purge_multiframe_map()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t FFmpeg_Transcoder::purge_multiframe_map </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Purge all frames in buffer. </p>
<dl class="section return"><dt>Returns</dt><dd>Number of frames that have been purged. Function never fails. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ffmpeg__transcoder_8cc_source.html#l06286">6286</a> of file <a class="el" href="ffmpeg__transcoder_8cc_source.html">ffmpeg_transcoder.cc</a>.</p>

<p class="reference">References <a class="el" href="ffmpeg__transcoder_8h_source.html#l01195">m_frame_map</a>.</p>

<p class="reference">Referenced by <a class="el" href="ffmpeg__transcoder_8cc_source.html#l06310">purge()</a>.</p>

</div>
</div>
<a id="a7801f1c9b7542a8852d274af38be7256"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7801f1c9b7542a8852d274af38be7256">&#9670;&nbsp;</a></span>read_aiff_chunk()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int FFmpeg_Transcoder::read_aiff_chunk </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classBuffer.html">Buffer</a> *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>buffoffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>ID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>chunk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read AIFF chunk. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>- <a class="el" href="classCache.html" title="The Cache class.">Cache</a> buffer to read from </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">buffoffset</td><td>- Byte offset into buffer. Upon return holds offset to the position of the chunk. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ID</td><td>- Chunk ID (fourCC) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">chunk</td><td>- <a class="el" href="classBuffer.html" title="The Buffer class.">Buffer</a> for chunk </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">size</td><td>- Size of chunk. <a class="el" href="classBuffer.html" title="The Buffer class.">Buffer</a> for chunk must be large enough to hold it. Upon return holds the actual size of the chunk read. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 if successful or -1 On error, or end of file. Check buffer-&gt;eof(). </dd></dl>

<p class="definition">Definition at line <a class="el" href="ffmpeg__transcoder_8cc_source.html#l03035">3035</a> of file <a class="el" href="ffmpeg__transcoder_8cc_source.html">ffmpeg_transcoder.cc</a>.</p>

<p class="reference">References <a class="el" href="aiff_8h_source.html#l00044">AIFF_FORMID</a>, <a class="el" href="buffer_8cc_source.html#l00853">Buffer::copy()</a>, <a class="el" href="buffer_8cc_source.html#l01000">Buffer::eof()</a>, <a class="el" href="aiff_8h_source.html#l00061">AIFF_CHUNK::m_ckID</a>, and <a class="el" href="aiff_8h_source.html#l00062">AIFF_CHUNK::m_ckSize</a>.</p>

<p class="reference">Referenced by <a class="el" href="ffmpeg__transcoder_8cc_source.html#l03080">create_fake_aiff_header()</a>.</p>

</div>
</div>
<a id="a6afa2189ecd068bcbaa1054835db27c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6afa2189ecd068bcbaa1054835db27c4">&#9670;&nbsp;</a></span>read_decode_convert_and_store()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int FFmpeg_Transcoder::read_decode_convert_and_store </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>finished</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read frame from source file, decode and store in FIFO. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">finished</td><td>- 1 if at EOF. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, returns 0; on error, a negative AVERROR value. </dd></dl>
<p>&lt;* </p><dl class="todo"><dt><b><a class="el" href="todo.html#_todo000012">Todo:</a></b></dt><dd>Cue sheet track: Must check video stream, too and end if both all video and audio packets arrived. Discard packets exceeding duration. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ffmpeg__transcoder_8cc_source.html#l04095">4095</a> of file <a class="el" href="ffmpeg__transcoder_8cc_source.html">ffmpeg_transcoder.cc</a>.</p>

<p class="reference">References <a class="el" href="ffmpeg__transcoder_8cc_source.html#l03740">decode_frame()</a>, <a class="el" href="logging_8h_source.html#l00237">Logging::error()</a>, <a class="el" href="ffmpeg__utils_8cc_source.html#l01139">ffmpeg_geterror()</a>, <a class="el" href="ffmpeg__utils_8cc_source.html#l01153">ffmpeg_rescale_q()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l04012">flush_frames_all()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l07470">is_audio_stream()</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l00140">FFmpeg_Transcoder::INPUTFILE::m_audio</a>, <a class="el" href="structVIRTUALFILE.html#ac05832e00e22fb501023551962d2879c">VIRTUALFILE::m_cuesheet_track</a>, <a class="el" href="fileio_8h_source.html#l00235">VIRTUALFILE::CUESHEET_TRACK::m_duration</a>, <a class="el" href="fileio_8h_source.html#l00143">VIRTUALFILE::m_flags</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l00138">FFmpeg_Transcoder::INPUTFILE::m_format_ctx</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l01217">m_in</a>, <a class="el" href="fileio_8h_source.html#l00234">VIRTUALFILE::CUESHEET_TRACK::m_start</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l00121">FFmpeg_Transcoder::StreamRef::m_stream</a>, <a class="el" href="ffmpeg__base_8h_source.html#l00280">FFmpeg_Base::m_virtualfile</a>, <a class="el" href="logging_8h_source.html#l00161">Logging::trace()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l06458">virtname()</a>, and <a class="el" href="fileio_8h_source.html#l00113">VIRTUALFLAG_CUESHEET</a>.</p>

<p class="reference">Referenced by <a class="el" href="ffmpeg__transcoder_8cc_source.html#l05146">copy_audio_to_frame_buffer()</a>, and <a class="el" href="ffmpeg__transcoder_8cc_source.html#l05210">process_single_fr()</a>.</p>

</div>
</div>
<a id="aa4515e5c135b1ca3fd7fab1d8bc0d943"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4515e5c135b1ca3fd7fab1d8bc0d943">&#9670;&nbsp;</a></span>read_packet()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int FFmpeg_Transcoder::read_packet </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>opaque</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>buf_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classFFmpeg__Transcoder.html#aa4515e5c135b1ca3fd7fab1d8bc0d943" title="FFmpeg_Transcoder::read_packet.">FFmpeg_Transcoder::read_packet</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">opaque</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buf</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buf_size</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

<p class="definition">Definition at line <a class="el" href="ffmpeg__transcoder_8cc_source.html#l07572">7572</a> of file <a class="el" href="ffmpeg__transcoder_8cc_source.html">ffmpeg_transcoder.cc</a>.</p>

<p class="reference">References <a class="el" href="ffmpeg__transcoder_8h_source.html#l00071">FFmpeg_Transcoder::BUFFER_DATA::ptr</a>, and <a class="el" href="ffmpeg__transcoder_8h_source.html#l00072">FFmpeg_Transcoder::BUFFER_DATA::size</a>.</p>

<p class="reference">Referenced by <a class="el" href="ffmpeg__transcoder_8cc_source.html#l07590">add_external_subtitle_stream()</a>.</p>

</div>
</div>
<a id="a8b6c0aabe9bdc1b75aacb60f180c55fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b6c0aabe9bdc1b75aacb60f180c55fa">&#9670;&nbsp;</a></span>seek()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int64_t FFmpeg_Transcoder::seek </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>opaque</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>whence</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Custom seek function for FFmpeg. </p>
<p>Write to virtual files, currently only physical files.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">opaque</td><td>- Payload given to FFmpeg, basically the <a class="el" href="classFileIO.html" title="Base class for I/O.">FileIO</a> object </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>- Offset to seek to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">whence</td><td>- One of the regular <a class="el" href="classFFmpeg__Transcoder.html#a8b6c0aabe9bdc1b75aacb60f180c55fa" title="Custom seek function for FFmpeg.">seek()</a> constants like SEEK_SET/SEEK_END. Additionally FFmpeg constants like AVSEEK_SIZE are supported. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On successs returns 0. On error, returns -1 and sets errno accordingly. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ffmpeg__transcoder_8cc_source.html#l06225">6225</a> of file <a class="el" href="ffmpeg__transcoder_8cc_source.html">ffmpeg_transcoder.cc</a>.</p>

<p class="reference">References <a class="el" href="logging_8h_source.html#l00237">Logging::error()</a>, <a class="el" href="classFileIO.html#a0171ca18c497a09971e22cc5c381304b">FileIO::seek()</a>, and <a class="el" href="classFileIO.html#a28df61747de114001d67ef6abad2ca7d">FileIO::size()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ffmpeg__transcoder_8cc_source.html#l00306">open_input_file()</a>, and <a class="el" href="ffmpeg__transcoder_8cc_source.html#l02592">open_output_filestreams()</a>.</p>

</div>
</div>
<a id="af5fdd8b957b3f127d4b786b8a190b510"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5fdd8b957b3f127d4b786b8a190b510">&#9670;&nbsp;</a></span>seek_frame()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int FFmpeg_Transcoder::seek_frame </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Frame sets only: perform seek to a certain frame. </p>
<dl class="section return"><dt>Returns</dt><dd>0 on success, a negative AVERROR code on failure. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ffmpeg__transcoder_8cc_source.html#l05433">5433</a> of file <a class="el" href="ffmpeg__transcoder_8cc_source.html">ffmpeg_transcoder.cc</a>.</p>

<p class="reference">References <a class="el" href="buffer_8cc_source.html#l01015">Buffer::have_frame()</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l01230">m_buffer</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l01190">m_last_seek_frame_no</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l01189">m_seek_to_fifo</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l01188">m_seek_to_fifo_mutex</a>, and <a class="el" href="ffmpeg__transcoder_8cc_source.html#l05027">skip_decoded_frames()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ffmpeg__transcoder_8cc_source.html#l05210">process_single_fr()</a>.</p>

</div>
</div>
<a id="a8b7f7fba2c298180d3febf6bc8c4fd08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b7f7fba2c298180d3febf6bc8c4fd08">&#9670;&nbsp;</a></span>segment_count()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t FFmpeg_Transcoder::segment_count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of HLS segments of file. </p>
<dl class="section return"><dt>Returns</dt><dd>On success, returns the number of segments; on error, returns 0 (calculation failed). </dd></dl>

<p class="definition">Definition at line <a class="el" href="ffmpeg__transcoder_8cc_source.html#l06133">6133</a> of file <a class="el" href="ffmpeg__transcoder_8cc_source.html">ffmpeg_transcoder.cc</a>.</p>

<p class="reference">References <a class="el" href="ffmpeg__base_8h_source.html#l00280">FFmpeg_Base::m_virtualfile</a>, and <a class="el" href="ffmpeg__utils_8h_source.html#l00152">SAFE_VALUE</a>.</p>

<p class="reference">Referenced by <a class="el" href="ffmpeg__transcoder_8cc_source.html#l06703">stack_seek_segment()</a>, <a class="el" href="transcode_8cc_source.html#l00155">transcode_finish()</a>, <a class="el" href="transcode_8cc_source.html#l00329">transcoder_predict_filesize()</a>, and <a class="el" href="transcode_8cc_source.html#l00770">transcoder_thread()</a>.</p>

</div>
</div>
<a id="a4cfebc7d896c2fc66d6832fd477edb63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cfebc7d896c2fc66d6832fd477edb63">&#9670;&nbsp;</a></span>send_filters()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int FFmpeg_Transcoder::send_filters </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classFFmpeg__Frame.html">FFmpeg_Frame</a> *&#160;</td>
          <td class="paramname"><em>srcframe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>ret</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send video frame to the filters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">srcframe</td><td>- On input video frame to process, on output video frame that was filtered. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ret</td><td>- 0 if OK, or negative AVERROR value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 if OK, or negative AVERROR value. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ffmpeg__transcoder_8cc_source.html#l06609">6609</a> of file <a class="el" href="ffmpeg__transcoder_8cc_source.html">ffmpeg_transcoder.cc</a>.</p>

<p class="reference">References <a class="el" href="logging_8h_source.html#l00237">Logging::error()</a>, <a class="el" href="ffmpeg__utils_8cc_source.html#l01139">ffmpeg_geterror()</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l01210">m_buffer_sink_context</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l01211">m_buffer_source_context</a>, <a class="el" href="ffmpeg__frame_8h_source.html#l00119">FFmpeg_Frame::m_stream_idx</a>, <a class="el" href="ffmpeg__frame_8cc_source.html#l00117">FFmpeg_Frame::res()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l06458">virtname()</a>, and <a class="el" href="logging_8h_source.html#l00218">Logging::warning()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ffmpeg__transcoder_8cc_source.html#l03354">decode_video_frame()</a>.</p>

</div>
</div>
<a id="a9bf8d0e53fa97cd6d488c7d6ebf8df18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bf8d0e53fa97cd6d488c7d6ebf8df18">&#9670;&nbsp;</a></span>skip_decoded_frames()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int FFmpeg_Transcoder::skip_decoded_frames </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>frame_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>forced_seek</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Skip decoded frames or force seek to frame_no. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">frame_no</td><td>- Frame to seek to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">forced_seek</td><td>- Force seek even if np frames skipped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 if OK, or negative AVERROR value. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ffmpeg__transcoder_8cc_source.html#l05027">5027</a> of file <a class="el" href="ffmpeg__transcoder_8cc_source.html">ffmpeg_transcoder.cc</a>.</p>

<p class="reference">References <a class="el" href="ffmpeg__transcoder_8cc_source.html#l05006">do_seek_frame()</a>, <a class="el" href="logging_8h_source.html#l00237">Logging::error()</a>, <a class="el" href="ffmpeg__utils_8cc_source.html#l01139">ffmpeg_geterror()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l00079">FRAME_SEEK_THRESHOLD</a>, <a class="el" href="buffer_8cc_source.html#l01015">Buffer::have_frame()</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l01230">m_buffer</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l00138">FFmpeg_Transcoder::INPUTFILE::m_format_ctx</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l01217">m_in</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l01218">m_out</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l00121">FFmpeg_Transcoder::StreamRef::m_stream</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l00122">FFmpeg_Transcoder::StreamRef::m_stream_idx</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l00141">FFmpeg_Transcoder::INPUTFILE::m_video</a>, <a class="el" href="fileio_8h_source.html#l00154">VIRTUALFILE::m_video_frame_count</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l00160">FFmpeg_Transcoder::OUTPUTFILE::m_video_pts</a>, <a class="el" href="ffmpeg__base_8h_source.html#l00280">FFmpeg_Base::m_virtualfile</a>, <a class="el" href="ffmpeg__base_8cc_source.html#l00314">FFmpeg_Base::pts_to_frame()</a>, and <a class="el" href="ffmpeg__transcoder_8cc_source.html#l06458">virtname()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ffmpeg__transcoder_8cc_source.html#l05433">seek_frame()</a>.</p>

</div>
</div>
<a id="a104053334212dc85d388b6471760224f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a104053334212dc85d388b6471760224f">&#9670;&nbsp;</a></span>stack_seek_frame()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int FFmpeg_Transcoder::stack_seek_frame </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>frame_no</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Seek to a specific frame. Does not actually perform the seek, this is done asynchronously by the transcoder thread. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">frame_no</td><td>- Frame number to seek 1...n </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, returns 0; On error, negative AVERROR value and sets errno to EINVAL. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ffmpeg__transcoder_8cc_source.html#l06687">6687</a> of file <a class="el" href="ffmpeg__transcoder_8cc_source.html">ffmpeg_transcoder.cc</a>.</p>

<p class="reference">References <a class="el" href="logging_8h_source.html#l00237">Logging::error()</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l01189">m_seek_to_fifo</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l01188">m_seek_to_fifo_mutex</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l06128">video_frame_count()</a>, and <a class="el" href="ffmpeg__transcoder_8cc_source.html#l06458">virtname()</a>.</p>

<p class="reference">Referenced by <a class="el" href="transcode_8cc_source.html#l00770">transcoder_thread()</a>.</p>

</div>
</div>
<a id="ae4c437963492a1e162f3075f76ac9a3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4c437963492a1e162f3075f76ac9a3e">&#9670;&nbsp;</a></span>stack_seek_segment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int FFmpeg_Transcoder::stack_seek_segment </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>segment_no</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Seek to a specific HLS segment. Does not actually perform the seek, this is done asynchronously by the transcoder thread. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">segment_no</td><td>- Segment number to seek 1...n </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, returns 0; On error, negative AVERROR value and sets errno to EINVAL. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ffmpeg__transcoder_8cc_source.html#l06703">6703</a> of file <a class="el" href="ffmpeg__transcoder_8cc_source.html">ffmpeg_transcoder.cc</a>.</p>

<p class="reference">References <a class="el" href="logging_8h_source.html#l00237">Logging::error()</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l01189">m_seek_to_fifo</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l01188">m_seek_to_fifo_mutex</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l06133">segment_count()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l06128">video_frame_count()</a>, and <a class="el" href="ffmpeg__transcoder_8cc_source.html#l06458">virtname()</a>.</p>

<p class="reference">Referenced by <a class="el" href="transcode_8cc_source.html#l00770">transcoder_thread()</a>.</p>

</div>
</div>
<a id="ad5fc4ed5d3550cf962f842bf4b8e3425"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5fc4ed5d3550cf962f842bf4b8e3425">&#9670;&nbsp;</a></span>start_new_segment()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int FFmpeg_Transcoder::start_new_segment </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>HLS only: start a new HLS segment. </p>
<dl class="section return"><dt>Returns</dt><dd>0 on success, a negative AVERROR code on failure. </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000015">Todo:</a></b></dt><dd>Set reasonable size here </dd></dl>

<p class="definition">Definition at line <a class="el" href="ffmpeg__transcoder_8cc_source.html#l05490">5490</a> of file <a class="el" href="ffmpeg__transcoder_8cc_source.html">ffmpeg_transcoder.cc</a>.</p>

<p class="reference">References <a class="el" href="ffmpeg__transcoder_8cc_source.html#l06343">close_output_file()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l06138">encode_finish()</a>, <a class="el" href="logging_8h_source.html#l00237">Logging::error()</a>, <a class="el" href="ffmpeg__utils_8cc_source.html#l01139">ffmpeg_geterror()</a>, <a class="el" href="ffmpeg__utils_8cc_source.html#l01153">ffmpeg_rescale_q()</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l01248">FFMPEGFS_AUDIO</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l01249">FFMPEGFS_VIDEO</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l04994">flush_buffers()</a>, <a class="el" href="fileio_8cc_source.html#l00048">VIRTUALFILE::get_segment_count()</a>, <a class="el" href="logging_8h_source.html#l00199">Logging::info()</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l00140">FFmpeg_Transcoder::INPUTFILE::m_audio</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l01230">m_buffer</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l01221">m_current_segment</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l00138">FFmpeg_Transcoder::INPUTFILE::m_format_ctx</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l01191">m_have_seeked</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l01254">m_hls_packet_fifo</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l01217">m_in</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l01253">m_inhibit_stream_msk</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l01222">m_insert_keyframe</a>, <a class="el" href="ffmpegfs_8h_source.html#l00209">FFMPEGFS_PARAMS::m_min_seek_time_diff</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l01218">m_out</a>, <a class="el" href="fileio_8h_source.html#l00153">VIRTUALFILE::m_predicted_size</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l01232">m_reset_pts</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l01189">m_seek_to_fifo</a>, <a class="el" href="ffmpegfs_8h_source.html#l00208">FFMPEGFS_PARAMS::m_segment_duration</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l00121">FFmpeg_Transcoder::StreamRef::m_stream</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l00122">FFmpeg_Transcoder::StreamRef::m_stream_idx</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l00141">FFmpeg_Transcoder::INPUTFILE::m_video</a>, <a class="el" href="ffmpeg__base_8h_source.html#l00280">FFmpeg_Base::m_virtualfile</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l01255">open_output()</a>, <a class="el" href="ffmpegfs_8cc_source.html#l00072">params</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l01396">process_output()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l06295">purge_hls_fifo()</a>, <a class="el" href="buffer_8cc_source.html#l00335">Buffer::segment_exists()</a>, <a class="el" href="buffer_8cc_source.html#l00291">Buffer::set_segment()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l07499">stream_exists()</a>, <a class="el" href="buffer_8cc_source.html#l00799">Buffer::tell()</a>, and <a class="el" href="ffmpeg__transcoder_8cc_source.html#l06458">virtname()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ffmpeg__transcoder_8cc_source.html#l05210">process_single_fr()</a>.</p>

</div>
</div>
<a id="a2a228b0dad4daf77a0313dad46f12186"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a228b0dad4daf77a0313dad46f12186">&#9670;&nbsp;</a></span>store_packet()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int FFmpeg_Transcoder::store_packet </td>
          <td>(</td>
          <td class="paramtype">AVPacket *&#160;</td>
          <td class="paramname"><em>pkt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AVMediaType&#160;</td>
          <td class="paramname"><em>mediatype</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Store packet in output stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pkt</td><td>- Packet to store. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mediatype</td><td>- Typo of packet: audio, video, image (attachment) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, returns 0; on error, a negative AVERROR value. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ffmpeg__transcoder_8cc_source.html#l03634">3634</a> of file <a class="el" href="ffmpeg__transcoder_8cc_source.html">ffmpeg_transcoder.cc</a>.</p>

<p class="reference">References <a class="el" href="logging_8h_source.html#l00237">Logging::error()</a>, <a class="el" href="ffmpeg__utils_8cc_source.html#l01139">ffmpeg_geterror()</a>, <a class="el" href="ffmpeg__utils_8cc_source.html#l01168">ffmpeg_rescale_q_rnd()</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l01248">FFMPEGFS_AUDIO</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l01249">FFMPEGFS_VIDEO</a>, <a class="el" href="ffmpeg__utils_8cc_source.html#l01553">format_duration()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l07460">get_next_segment()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l07487">get_out_subtitle_stream()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l07465">goto_next_segment()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l06744">is_hls()</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l00140">FFmpeg_Transcoder::INPUTFILE::m_audio</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l00138">FFmpeg_Transcoder::INPUTFILE::m_format_ctx</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l01254">m_hls_packet_fifo</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l01253">m_inhibit_stream_msk</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l01218">m_out</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l00123">FFmpeg_Transcoder::StreamRef::m_start_time</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l00121">FFmpeg_Transcoder::StreamRef::m_stream</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l00141">FFmpeg_Transcoder::INPUTFILE::m_video</a>, <a class="el" href="logging_8h_source.html#l00161">Logging::trace()</a>, and <a class="el" href="ffmpeg__transcoder_8cc_source.html#l06458">virtname()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ffmpeg__transcoder_8cc_source.html#l02565">add_albumart_frame()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l03740">decode_frame()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l04245">encode_audio_frame()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l04620">encode_subtitle()</a>, and <a class="el" href="ffmpeg__transcoder_8cc_source.html#l04440">encode_video_frame()</a>.</p>

</div>
</div>
<a id="a98bee7147e10770ac6e8b1955a7b5a43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98bee7147e10770ac6e8b1955a7b5a43">&#9670;&nbsp;</a></span>stream_exists()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool FFmpeg_Transcoder::stream_exists </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>stream_idx</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if stream exists. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">stream_idx</td><td>- ID of stream to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 if stream exists, false if not. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ffmpeg__transcoder_8cc_source.html#l07499">7499</a> of file <a class="el" href="ffmpeg__transcoder_8cc_source.html">ffmpeg_transcoder.cc</a>.</p>

<p class="reference">References <a class="el" href="ffmpeg__utils_8h_source.html#l00074">INVALID_STREAM</a>.</p>

<p class="reference">Referenced by <a class="el" href="ffmpeg__transcoder_8cc_source.html#l06046">calculate_predicted_filesize()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l03197">decode()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l03740">decode_frame()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l04037">flush_frames_single()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l07470">is_audio_stream()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l07475">is_video_stream()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l00678">open_bestmatch_audio()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l00592">open_bestmatch_video()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l00306">open_input_file()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l01255">open_output()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l00844">open_output_file()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l02592">open_output_filestreams()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l05210">process_single_fr()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l05490">start_new_segment()</a>, and <a class="el" href="ffmpeg__transcoder_8cc_source.html#l02925">update_format()</a>.</p>

</div>
</div>
<a id="ac01386c453288f63a13c25cbea940c5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac01386c453288f63a13c25cbea940c5b">&#9670;&nbsp;</a></span>tagcpy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t size&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char * FFmpeg_Transcoder::tagcpy </td>
          <td>(</td>
          <td class="paramtype">char(&amp;)&#160;</td>
          <td class="paramname"><em>out</em>[size], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>in</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Safely copy a tag to a target buffer. If the input buffer size is larger than output the data will be truncated to avoid overruns. The function never appends a /0 terminator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>- Target buffer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">in</td><td>- Input buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Constant pointer to target buffer. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ffmpeg__transcoder_8cc_source.html#l04854">4854</a> of file <a class="el" href="ffmpeg__transcoder_8cc_source.html">ffmpeg_transcoder.cc</a>.</p>

</div>
</div>
<a id="a7cf0e2c40fbe581a645c8c8015bcc3db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cf0e2c40fbe581a645c8c8015bcc3db">&#9670;&nbsp;</a></span>total_overhead()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool FFmpeg_Transcoder::total_overhead </td>
          <td>(</td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>filesize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ffmpeg__utils_8h.html#adf12e2d9ad420681d96f755088d37237">FILETYPE</a>&#160;</td>
          <td class="paramname"><em>filetype</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Predict overhead in file size. This may (better will surely) be inaccurate. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">filesize</td><td>- Predicted file size in bytes, including overhead. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filetype</td><td>- File type: MP3, TS etc. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, returns true; on failure, returns false. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ffmpeg__transcoder_8cc_source.html#l05969">5969</a> of file <a class="el" href="ffmpeg__transcoder_8cc_source.html">ffmpeg_transcoder.cc</a>.</p>

<p class="reference">Referenced by <a class="el" href="ffmpeg__transcoder_8cc_source.html#l06046">calculate_predicted_filesize()</a>, and <a class="el" href="transcode_8cc_source.html#l00289">transcoder_set_filesize()</a>.</p>

</div>
</div>
<a id="a5aa9df18335022dc4127fb601b6c2ce2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5aa9df18335022dc4127fb601b6c2ce2">&#9670;&nbsp;</a></span>update_codec()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int FFmpeg_Transcoder::update_codec </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>opt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFFmpeg__Profiles.html#a8c96ed075fd81ebc334ad2a0e89bc114">PROFILE_OPTION_VEC</a> &amp;&#160;</td>
          <td class="paramname"><em>profile_option_vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prepare codec options. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">opt</td><td>- Codec private data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">profile_option_vec</td><td>- Selected profile option. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, returns 0; on error, a negative AVERROR value. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ffmpeg__transcoder_8cc_source.html#l01556">1556</a> of file <a class="el" href="ffmpeg__transcoder_8cc_source.html">ffmpeg_transcoder.cc</a>.</p>

<p class="reference">References <a class="el" href="ffmpeg__transcoder_8h_source.html#l01241">m_hwaccel_enable_enc_buffering</a>, <a class="el" href="ffmpeg__profiles_8h_source.html#l00049">OPT_HW_ONLY</a>, <a class="el" href="ffmpeg__base_8cc_source.html#l00207">FFmpeg_Base::opt_set_with_check()</a>, <a class="el" href="ffmpeg__profiles_8h_source.html#l00048">OPT_SW_ONLY</a>, <a class="el" href="logging_8h_source.html#l00161">Logging::trace()</a>, and <a class="el" href="ffmpeg__transcoder_8cc_source.html#l06458">virtname()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ffmpeg__transcoder_8cc_source.html#l01578">prepare_codec()</a>.</p>

</div>
</div>
<a id="ade3130afeae33293eac150d65a714c88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade3130afeae33293eac150d65a714c88">&#9670;&nbsp;</a></span>update_format()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int FFmpeg_Transcoder::update_format </td>
          <td>(</td>
          <td class="paramtype">AVDictionary **&#160;</td>
          <td class="paramname"><em>dict</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFFmpeg__Profiles.html#a8c96ed075fd81ebc334ad2a0e89bc114">PROFILE_OPTION_VEC</a> &amp;&#160;</td>
          <td class="paramname"><em>option_vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update format options. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dict</td><td>- Dictionary to update. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">option_vec</td><td>- Profile option to set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, returns 0; on error, a negative AVERROR value. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ffmpeg__transcoder_8cc_source.html#l02925">2925</a> of file <a class="el" href="ffmpeg__transcoder_8cc_source.html">ffmpeg_transcoder.cc</a>.</p>

<p class="reference">References <a class="el" href="ffmpeg__base_8cc_source.html#l00173">FFmpeg_Base::dict_set_with_check()</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l01218">m_out</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l00122">FFmpeg_Transcoder::StreamRef::m_stream_idx</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l00141">FFmpeg_Transcoder::INPUTFILE::m_video</a>, <a class="el" href="ffmpeg__profiles_8h_source.html#l00046">OPT_AUDIO</a>, <a class="el" href="ffmpeg__profiles_8h_source.html#l00047">OPT_VIDEO</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l07499">stream_exists()</a>, <a class="el" href="logging_8h_source.html#l00161">Logging::trace()</a>, and <a class="el" href="ffmpeg__transcoder_8cc_source.html#l06458">virtname()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ffmpeg__transcoder_8cc_source.html#l02954">prepare_format()</a>.</p>

</div>
</div>
<a id="a72f7d34c6a08488495a7a8e154e3d155"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72f7d34c6a08488495a7a8e154e3d155">&#9670;&nbsp;</a></span>video_frame_count()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t FFmpeg_Transcoder::video_frame_count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of video frames in file. </p>
<dl class="section return"><dt>Returns</dt><dd>On success, returns the number of frames; on error, returns 0 (calculation failed or no video source file). </dd></dl>

<p class="definition">Definition at line <a class="el" href="ffmpeg__transcoder_8cc_source.html#l06128">6128</a> of file <a class="el" href="ffmpeg__transcoder_8cc_source.html">ffmpeg_transcoder.cc</a>.</p>

<p class="reference">References <a class="el" href="ffmpeg__base_8h_source.html#l00280">FFmpeg_Base::m_virtualfile</a>, and <a class="el" href="ffmpeg__utils_8h_source.html#l00152">SAFE_VALUE</a>.</p>

<p class="reference">Referenced by <a class="el" href="ffmpeg__transcoder_8cc_source.html#l06687">stack_seek_frame()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l06703">stack_seek_segment()</a>, <a class="el" href="transcode_8cc_source.html#l00155">transcode_finish()</a>, <a class="el" href="transcode_8cc_source.html#l00329">transcoder_predict_filesize()</a>, and <a class="el" href="transcode_8cc_source.html#l00770">transcoder_thread()</a>.</p>

</div>
</div>
<a id="a03d1d37a915852aaa88a62331d729198"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03d1d37a915852aaa88a62331d729198">&#9670;&nbsp;</a></span>video_size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool FFmpeg_Transcoder::video_size </td>
          <td>(</td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>filesize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AVCodecID&#160;</td>
          <td class="paramname"><em>codec_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ffmpeg__utils_8h.html#a17468d10f0c67a4ee7b38aab09d9e096">BITRATE</a>&#160;</td>
          <td class="paramname"><em>bit_rate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>duration</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>interleaved</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AVRational &amp;&#160;</td>
          <td class="paramname"><em>framerate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Predict video file size. This may (better will surely) be inaccurate. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">filesize</td><td>- Predicted file size in bytes, including video stream size. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">codec_id</td><td>- Target codec ID. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bit_rate</td><td>- Target bit rate. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">duration</td><td>- File duration. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">width</td><td>- Target video width. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">height-</td><td>Target video height. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">interleaved</td><td>- True if target video is interleaved, false if not. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">framerate</td><td>- Frame rate of target video. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, returns true; on failure, returns false. </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000016">Todo:</a></b></dt><dd>AV1 prediction has not been tested yet </dd></dl>

<p class="definition">Definition at line <a class="el" href="ffmpeg__transcoder_8cc_source.html#l05887">5887</a> of file <a class="el" href="ffmpeg__transcoder_8cc_source.html">ffmpeg_transcoder.cc</a>.</p>

<p class="reference">References <a class="el" href="ffmpeg__utils_8h_source.html#l00146">BITRATE</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l06118">duration()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l01437">get_output_bit_rate()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l05620">get_prores_bitrate()</a>, <a class="el" href="ffmpegfs_8h_source.html#l00196">FFMPEGFS_PARAMS::m_level</a>, <a class="el" href="ffmpegfs_8h_source.html#l00203">FFMPEGFS_PARAMS::m_videobitrate</a>, and <a class="el" href="ffmpegfs_8cc_source.html#l00072">params</a>.</p>

<p class="reference">Referenced by <a class="el" href="ffmpeg__transcoder_8cc_source.html#l06046">calculate_predicted_filesize()</a>, and <a class="el" href="transcode_8cc_source.html#l00289">transcoder_set_filesize()</a>.</p>

</div>
</div>
<a id="aa09c2468c04eb793d4d006b6c79d4073"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa09c2468c04eb793d4d006b6c79d4073">&#9670;&nbsp;</a></span>virtname()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char * FFmpeg_Transcoder::virtname </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return virtual filename. Same as destination filename, but with virtual (mount) path.. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns filename. </dd></dl>

<p>Implements <a class="el" href="classFFmpeg__Base.html#a4569284de85795502fd1c56323e991dc">FFmpeg_Base</a>.</p>

<p class="definition">Definition at line <a class="el" href="ffmpeg__transcoder_8cc_source.html#l06458">6458</a> of file <a class="el" href="ffmpeg__transcoder_8cc_source.html">ffmpeg_transcoder.cc</a>.</p>

<p class="reference">References <a class="el" href="fileio_8h_source.html#l00147">VIRTUALFILE::m_virtfile</a>, and <a class="el" href="ffmpeg__base_8h_source.html#l00280">FFmpeg_Base::m_virtualfile</a>.</p>

<p class="reference">Referenced by <a class="el" href="ffmpeg__transcoder_8cc_source.html#l02565">add_albumart_frame()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l02457">add_albumart_stream()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l03980">add_samples_to_fifo()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l01631">add_stream()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l02378">add_stream_copy()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l02238">add_subtitle_stream()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l03178">alloc_picture()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l00796">can_copy_stream()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l03940">convert_samples()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l04861">copy_metadata()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l04758">create_audio_frame()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l03740">decode_frame()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l03564">decode_subtitle()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l03354">decode_video_frame()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l04245">encode_audio_frame()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l04323">encode_image_frame()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l04620">encode_subtitle()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l04440">encode_video_frame()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l05073">flush_delayed_audio()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l05103">flush_delayed_video()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l06810">hwdevice_ctx_add_ref()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l06791">hwdevice_ctx_create()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l06968">hwframe_copy_to_hw()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l06842">hwframe_ctx_set()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l02913">init_audio_fifo()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l04166">init_audio_output_frame()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l03908">init_converted_samples()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l06464">init_deinterlace_filters()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l02793">init_resampler()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l01594">init_rescaler()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l00592">open_bestmatch_video()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l01255">open_output()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l00844">open_output_file()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l02592">open_output_filestreams()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l01097">open_output_frame_set()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l04919">process_metadata()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l05210">process_single_fr()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l04095">read_decode_convert_and_store()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l06609">send_filters()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l05027">skip_decoded_frames()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l06687">stack_seek_frame()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l06703">stack_seek_segment()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l05490">start_new_segment()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l03634">store_packet()</a>, <a class="el" href="transcode_8cc_source.html#l00155">transcode_finish()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l01556">update_codec()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l02925">update_format()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l03139">write_output_file_header()</a>, and <a class="el" href="ffmpeg__transcoder_8cc_source.html#l04834">write_output_file_trailer()</a>.</p>

</div>
</div>
<a id="a9e8f3a668b66cec31e5b10042cf80c2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e8f3a668b66cec31e5b10042cf80c2a">&#9670;&nbsp;</a></span>write_output_file_header()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int FFmpeg_Transcoder::write_output_file_header </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write the header of the output file container. </p>
<dl class="section return"><dt>Returns</dt><dd>On success, returns 0; on error, a negative AVERROR value. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ffmpeg__transcoder_8cc_source.html#l03139">3139</a> of file <a class="el" href="ffmpeg__transcoder_8cc_source.html">ffmpeg_transcoder.cc</a>.</p>

<p class="reference">References <a class="el" href="logging_8h_source.html#l00237">Logging::error()</a>, <a class="el" href="ffmpeg__utils_8cc_source.html#l01139">ffmpeg_geterror()</a>, <a class="el" href="ffmpeg__utils_8cc_source.html#l00907">FFmpegfs_Format::filetype()</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l01228">m_current_format</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l00136">FFmpeg_Transcoder::INPUTFILE::m_filetype</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l00138">FFmpeg_Transcoder::INPUTFILE::m_format_ctx</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l01218">m_out</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l02954">prepare_format()</a>, and <a class="el" href="ffmpeg__transcoder_8cc_source.html#l06458">virtname()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ffmpeg__transcoder_8cc_source.html#l01396">process_output()</a>.</p>

</div>
</div>
<a id="aad58ed3d5a8dc2f608e94a696d4cc3ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad58ed3d5a8dc2f608e94a696d4cc3ac">&#9670;&nbsp;</a></span>write_output_file_trailer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int FFmpeg_Transcoder::write_output_file_trailer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write the trailer of the output file container. </p>
<dl class="section return"><dt>Returns</dt><dd>On success, returns 0. On error, returns a negative AVERROR value. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ffmpeg__transcoder_8cc_source.html#l04834">4834</a> of file <a class="el" href="ffmpeg__transcoder_8cc_source.html">ffmpeg_transcoder.cc</a>.</p>

<p class="reference">References <a class="el" href="logging_8h_source.html#l00237">Logging::error()</a>, <a class="el" href="ffmpeg__utils_8cc_source.html#l01139">ffmpeg_geterror()</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l00138">FFmpeg_Transcoder::INPUTFILE::m_format_ctx</a>, <a class="el" href="ffmpeg__transcoder_8h_source.html#l01218">m_out</a>, and <a class="el" href="ffmpeg__transcoder_8cc_source.html#l06458">virtname()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ffmpeg__transcoder_8cc_source.html#l06138">encode_finish()</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a0d4ff70078b4316d665aaadf566aad11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d4ff70078b4316d665aaadf566aad11">&#9670;&nbsp;</a></span>m_devicetype_map</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classFFmpeg__Transcoder.html#ac9f065a7a574e400abac168cec2a556f">FFmpeg_Transcoder::DEVICETYPE_MAP</a> FFmpeg_Transcoder::m_devicetype_map</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">{</div>
<div class="line">    { AV_HWDEVICE_TYPE_VAAPI,           AV_PIX_FMT_NV12 },          </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">}</div>
</div><!-- fragment -->
<p>List of AVPixelFormats mapped to hardware acceleration types. </p>

<p class="definition">Definition at line <a class="el" href="ffmpeg__transcoder_8h_source.html#l01238">1238</a> of file <a class="el" href="ffmpeg__transcoder_8h_source.html">ffmpeg_transcoder.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="ffmpeg__transcoder_8cc_source.html#l07413">find_sw_fmt_by_hw_type()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/<a class="el" href="ffmpeg__transcoder_8h_source.html">ffmpeg_transcoder.h</a></li>
<li>src/<a class="el" href="ffmpeg__transcoder_8cc_source.html">ffmpeg_transcoder.cc</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
