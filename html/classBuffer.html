<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>FFmpegfs Fuse Multi Media Filesystem: Buffer Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">FFmpegfs Fuse Multi Media Filesystem<span id="projectnumber">&#160;2.16</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="#pri-static-attribs">Static Private Attributes</a> &#124;
<a href="classBuffer-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Buffer Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>The <a class="el" href="classBuffer.html" title="The Buffer class.">Buffer</a> class.  
 <a href="classBuffer.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="buffer_8h_source.html">buffer.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Buffer:</div>
<div class="dyncontent">
<div class="center"><img src="classBuffer__inherit__graph.png" border="0" usemap="#aBuffer_inherit__map" alt="Inheritance graph"/></div>
<map name="aBuffer_inherit__map" id="aBuffer_inherit__map">
<area shape="rect" title="The Buffer class." alt="" coords="5,80,63,107"/>
<area shape="rect" href="classFileIO.html" title="Base class for I/O." alt="" coords="5,5,63,32"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for Buffer:</div>
<div class="dyncontent">
<div class="center"><img src="classBuffer__coll__graph.png" border="0" usemap="#aBuffer_coll__map" alt="Collaboration graph"/></div>
<map name="aBuffer_coll__map" id="aBuffer_coll__map">
<area shape="rect" title="The Buffer class." alt="" coords="888,111,945,137"/>
<area shape="rect" href="classFileIO.html" title="Base class for I/O." alt="" coords="659,11,717,37"/>
<area shape="rect" href="structVIRTUALFILE.html" title="Virtual file definition." alt="" coords="327,56,433,83"/>
<area shape="rect" href="structVIRTUALFILE_1_1CUESHEET__TRACK.html" title="Extra value structure for cue sheets." alt="" coords="593,62,783,103"/>
<area shape="rect" href="structVIRTUALFILE_1_1VCD__CHAPTER.html" title="Extra value structure for Video CDs." alt="" coords="5,5,221,32"/>
<area shape="rect" href="structVIRTUALFILE_1_1DVD__CHAPTER.html" title="Extra value structure for DVDs." alt="" coords="5,56,221,83"/>
<area shape="rect" href="structVIRTUALFILE_1_1BLURAY__CHAPTER.html" title="Extra value structure for Blu&#45;ray disks." alt="" coords="30,107,197,149"/>
<area shape="rect" href="structBuffer_1_1__tagCACHEINFO.html" title="Structure to hold current cache state." alt="" coords="603,128,773,155"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBuffer_1_1__tagCACHEINFO.html">_tagCACHEINFO</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure to hold current cache state.  <a href="structBuffer_1_1__tagCACHEINFO.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:aadb6390b55aac6776448a8adc81696ed"><td class="memItemLeft" align="right" valign="top"><a id="aadb6390b55aac6776448a8adc81696ed" name="aadb6390b55aac6776448a8adc81696ed"></a>
typedef struct <a class="el" href="structBuffer_1_1__tagCACHEINFO.html">Buffer::_tagCACHEINFO</a>&#160;</td><td class="memItemRight" valign="bottom"><b>CACHEINFO</b></td></tr>
<tr class="memdesc:aadb6390b55aac6776448a8adc81696ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure to hold current cache state. <br /></td></tr>
<tr class="separator:aadb6390b55aac6776448a8adc81696ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2b0f8fddd154c040e9b62dae6938bc0"><td class="memItemLeft" align="right" valign="top"><a id="ad2b0f8fddd154c040e9b62dae6938bc0" name="ad2b0f8fddd154c040e9b62dae6938bc0"></a>
typedef struct <a class="el" href="structBuffer_1_1__tagCACHEINFO.html">Buffer::_tagCACHEINFO</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>LPCACHEINFO</b></td></tr>
<tr class="memdesc:ad2b0f8fddd154c040e9b62dae6938bc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer version of CACHEINFO. <br /></td></tr>
<tr class="separator:ad2b0f8fddd154c040e9b62dae6938bc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a839b6c6f82af952cd68e2e112804dadf"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classBuffer.html#aadb6390b55aac6776448a8adc81696ed">CACHEINFO</a> const  *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBuffer.html#a839b6c6f82af952cd68e2e112804dadf">LPCCACHEINFO</a></td></tr>
<tr class="memdesc:a839b6c6f82af952cd68e2e112804dadf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to const version of CACHEINFO.  <a href="classBuffer.html#a839b6c6f82af952cd68e2e112804dadf">More...</a><br /></td></tr>
<tr class="separator:a839b6c6f82af952cd68e2e112804dadf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ae7ef2cd201190fde551dcb902627112b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBuffer.html#ae7ef2cd201190fde551dcb902627112b">Buffer</a> ()</td></tr>
<tr class="memdesc:ae7ef2cd201190fde551dcb902627112b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create <a class="el" href="classBuffer.html" title="The Buffer class.">Buffer</a> object.  <a href="classBuffer.html#ae7ef2cd201190fde551dcb902627112b">More...</a><br /></td></tr>
<tr class="separator:ae7ef2cd201190fde551dcb902627112b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59b8743e4a5f731bdd0c4185c9ef263b"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBuffer.html#a59b8743e4a5f731bdd0c4185c9ef263b">~Buffer</a> ()</td></tr>
<tr class="memdesc:a59b8743e4a5f731bdd0c4185c9ef263b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free <a class="el" href="classBuffer.html" title="The Buffer class.">Buffer</a> object.  <a href="classBuffer.html#a59b8743e4a5f731bdd0c4185c9ef263b">More...</a><br /></td></tr>
<tr class="separator:a59b8743e4a5f731bdd0c4185c9ef263b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a8b576768de0c73bc652d2da9546cc8"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="fileio_8h.html#a1199d38534b11312b0210e527499a805">VIRTUALTYPE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBuffer.html#a6a8b576768de0c73bc652d2da9546cc8">type</a> () const override</td></tr>
<tr class="memdesc:a6a8b576768de0c73bc652d2da9546cc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get type of this virtual file.  <a href="classBuffer.html#a6a8b576768de0c73bc652d2da9546cc8">More...</a><br /></td></tr>
<tr class="separator:a6a8b576768de0c73bc652d2da9546cc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e315544b35bbaf0706ef8fbd6bfdbfb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBuffer.html#a6e315544b35bbaf0706ef8fbd6bfdbfb">init</a> (bool erase_cache)</td></tr>
<tr class="memdesc:a6e315544b35bbaf0706ef8fbd6bfdbfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialise cache.  <a href="classBuffer.html#a6e315544b35bbaf0706ef8fbd6bfdbfb">More...</a><br /></td></tr>
<tr class="separator:a6e315544b35bbaf0706ef8fbd6bfdbfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae00cd56ba92c33805447ded6400cd0bd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBuffer.html#ae00cd56ba92c33805447ded6400cd0bd">set_segment</a> (uint32_t segment_no, size_t <a class="el" href="classBuffer.html#af19876bd44aaa1918ba81db4390b8bdf">size</a>)</td></tr>
<tr class="memdesc:ae00cd56ba92c33805447ded6400cd0bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the current segment.  <a href="classBuffer.html#ae00cd56ba92c33805447ded6400cd0bd">More...</a><br /></td></tr>
<tr class="separator:ae00cd56ba92c33805447ded6400cd0bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf8eacdb0ced6906905dbd90d356894d"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBuffer.html#acf8eacdb0ced6906905dbd90d356894d">segment_count</a> ()</td></tr>
<tr class="memdesc:acf8eacdb0ced6906905dbd90d356894d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get segment count.  <a href="classBuffer.html#acf8eacdb0ced6906905dbd90d356894d">More...</a><br /></td></tr>
<tr class="separator:acf8eacdb0ced6906905dbd90d356894d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa356d401405307f29e73586c7cad10c4"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBuffer.html#aa356d401405307f29e73586c7cad10c4">current_segment_no</a> ()</td></tr>
<tr class="memdesc:aa356d401405307f29e73586c7cad10c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the currently selected segment.  <a href="classBuffer.html#aa356d401405307f29e73586c7cad10c4">More...</a><br /></td></tr>
<tr class="separator:aa356d401405307f29e73586c7cad10c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35d04b77b37654d81397bbf6df193bd1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBuffer.html#a35d04b77b37654d81397bbf6df193bd1">segment_exists</a> (uint32_t segment_no)</td></tr>
<tr class="memdesc:a35d04b77b37654d81397bbf6df193bd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if segment exists.  <a href="classBuffer.html#a35d04b77b37654d81397bbf6df193bd1">More...</a><br /></td></tr>
<tr class="separator:a35d04b77b37654d81397bbf6df193bd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31676a28709fcd1cd236e4cbeb2d3bc2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBuffer.html#a31676a28709fcd1cd236e4cbeb2d3bc2">release</a> (int flags=<a class="el" href="buffer_8h.html#ae6bbe3443d78677335623b58e90dfbf0">CACHE_CLOSE_NOOPT</a>)</td></tr>
<tr class="memdesc:a31676a28709fcd1cd236e4cbeb2d3bc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release cache buffer.  <a href="classBuffer.html#a31676a28709fcd1cd236e4cbeb2d3bc2">More...</a><br /></td></tr>
<tr class="separator:a31676a28709fcd1cd236e4cbeb2d3bc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac456bcebc29eb15860d2ec2a49b41b00"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBuffer.html#ac456bcebc29eb15860d2ec2a49b41b00">bufsize</a> () const override</td></tr>
<tr class="memdesc:ac456bcebc29eb15860d2ec2a49b41b00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size of this buffer.  <a href="classBuffer.html#ac456bcebc29eb15860d2ec2a49b41b00">More...</a><br /></td></tr>
<tr class="separator:ac456bcebc29eb15860d2ec2a49b41b00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34523456990d9c9feb84803e82217ce1"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBuffer.html#a34523456990d9c9feb84803e82217ce1">openio</a> (<a class="el" href="fileio_8h.html#ae8356f209b2b74cc385a8d7551f1f27a">LPVIRTUALFILE</a> <a class="el" href="classFileIO.html#a2e330b909423f2118b8482732f50986a">virtualfile</a>) override</td></tr>
<tr class="memdesc:a34523456990d9c9feb84803e82217ce1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open a virtual file.  <a href="classBuffer.html#a34523456990d9c9feb84803e82217ce1">More...</a><br /></td></tr>
<tr class="separator:a34523456990d9c9feb84803e82217ce1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89a5520653ec88350b7c0e8dd5fb5bed"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBuffer.html#a89a5520653ec88350b7c0e8dd5fb5bed">readio</a> (void *data, size_t <a class="el" href="classBuffer.html#af19876bd44aaa1918ba81db4390b8bdf">size</a>) override</td></tr>
<tr class="memdesc:a89a5520653ec88350b7c0e8dd5fb5bed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Not implemented.  <a href="classBuffer.html#a89a5520653ec88350b7c0e8dd5fb5bed">More...</a><br /></td></tr>
<tr class="separator:a89a5520653ec88350b7c0e8dd5fb5bed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afca4140c510e88c2a3c2b505c4e7febe"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBuffer.html#afca4140c510e88c2a3c2b505c4e7febe">read_frame</a> (std::vector&lt; uint8_t &gt; *data, uint32_t frame_no)</td></tr>
<tr class="memdesc:afca4140c510e88c2a3c2b505c4e7febe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write image data for the frame number into the buffer.  <a href="classBuffer.html#afca4140c510e88c2a3c2b505c4e7febe">More...</a><br /></td></tr>
<tr class="separator:afca4140c510e88c2a3c2b505c4e7febe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0201a3b37fc6ba862d69373b82ece6e"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBuffer.html#ac0201a3b37fc6ba862d69373b82ece6e">error</a> () const override</td></tr>
<tr class="memdesc:ac0201a3b37fc6ba862d69373b82ece6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get last error.  <a href="classBuffer.html#ac0201a3b37fc6ba862d69373b82ece6e">More...</a><br /></td></tr>
<tr class="separator:ac0201a3b37fc6ba862d69373b82ece6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a2f7eefd5aba36d4600c0b449136cbb"><td class="memItemLeft" align="right" valign="top">virtual int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBuffer.html#a0a2f7eefd5aba36d4600c0b449136cbb">duration</a> () const override</td></tr>
<tr class="memdesc:a0a2f7eefd5aba36d4600c0b449136cbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the duration of the file, in AV_TIME_BASE fractional seconds.  <a href="classBuffer.html#a0a2f7eefd5aba36d4600c0b449136cbb">More...</a><br /></td></tr>
<tr class="separator:a0a2f7eefd5aba36d4600c0b449136cbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af19876bd44aaa1918ba81db4390b8bdf"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBuffer.html#af19876bd44aaa1918ba81db4390b8bdf">size</a> () const override</td></tr>
<tr class="memdesc:af19876bd44aaa1918ba81db4390b8bdf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the value of the internal buffer size pointer.  <a href="classBuffer.html#af19876bd44aaa1918ba81db4390b8bdf">More...</a><br /></td></tr>
<tr class="separator:af19876bd44aaa1918ba81db4390b8bdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab53c4d61870eb1107c750a433af447a1"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBuffer.html#ab53c4d61870eb1107c750a433af447a1">size</a> (uint32_t segment_no) const</td></tr>
<tr class="memdesc:ab53c4d61870eb1107c750a433af447a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the value of the internal buffer size pointer.  <a href="classBuffer.html#ab53c4d61870eb1107c750a433af447a1">More...</a><br /></td></tr>
<tr class="separator:ab53c4d61870eb1107c750a433af447a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf2303ab4476553b2f490be95d48e9d7"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBuffer.html#adf2303ab4476553b2f490be95d48e9d7">tell</a> () const override</td></tr>
<tr class="memdesc:adf2303ab4476553b2f490be95d48e9d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the value of the internal read position pointer.  <a href="classBuffer.html#adf2303ab4476553b2f490be95d48e9d7">More...</a><br /></td></tr>
<tr class="separator:adf2303ab4476553b2f490be95d48e9d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7c0ba630a439abf0b5ba4357b1eeec4"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBuffer.html#ac7c0ba630a439abf0b5ba4357b1eeec4">tell</a> (uint32_t segment_no) const</td></tr>
<tr class="memdesc:ac7c0ba630a439abf0b5ba4357b1eeec4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the value of the internal read position pointer.  <a href="classBuffer.html#ac7c0ba630a439abf0b5ba4357b1eeec4">More...</a><br /></td></tr>
<tr class="separator:ac7c0ba630a439abf0b5ba4357b1eeec4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4530682242000278f123dd4230765722"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBuffer.html#a4530682242000278f123dd4230765722">seek</a> (int64_t offset, int whence) override</td></tr>
<tr class="memdesc:a4530682242000278f123dd4230765722"><td class="mdescLeft">&#160;</td><td class="mdescRight">Seek to position in file.  <a href="classBuffer.html#a4530682242000278f123dd4230765722">More...</a><br /></td></tr>
<tr class="separator:a4530682242000278f123dd4230765722"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1eafabf58188673da1a3700d72628d7"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBuffer.html#ab1eafabf58188673da1a3700d72628d7">seek</a> (int64_t offset, int whence, uint32_t segment_no)</td></tr>
<tr class="memdesc:ab1eafabf58188673da1a3700d72628d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Seek to position in file.  <a href="classBuffer.html#ab1eafabf58188673da1a3700d72628d7">More...</a><br /></td></tr>
<tr class="separator:ab1eafabf58188673da1a3700d72628d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f84830369270e42e386585386716e95"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBuffer.html#a1f84830369270e42e386585386716e95">eof</a> () const override</td></tr>
<tr class="memdesc:a1f84830369270e42e386585386716e95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if at end of file.  <a href="classBuffer.html#a1f84830369270e42e386585386716e95">More...</a><br /></td></tr>
<tr class="separator:a1f84830369270e42e386585386716e95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6b9ebe68de81852063d2b4f6f7e6cd4"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBuffer.html#ae6b9ebe68de81852063d2b4f6f7e6cd4">eof</a> (uint32_t segment_no) const</td></tr>
<tr class="memdesc:ae6b9ebe68de81852063d2b4f6f7e6cd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if at end of file.  <a href="classBuffer.html#ae6b9ebe68de81852063d2b4f6f7e6cd4">More...</a><br /></td></tr>
<tr class="separator:ae6b9ebe68de81852063d2b4f6f7e6cd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65d7c1048d8c8713a6266fd78afc2e02"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBuffer.html#a65d7c1048d8c8713a6266fd78afc2e02">closeio</a> () override</td></tr>
<tr class="memdesc:a65d7c1048d8c8713a6266fd78afc2e02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close buffer.  <a href="classBuffer.html#a65d7c1048d8c8713a6266fd78afc2e02">More...</a><br /></td></tr>
<tr class="separator:a65d7c1048d8c8713a6266fd78afc2e02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45f05afcc82a5107db5ef8dbbd457572"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBuffer.html#a45f05afcc82a5107db5ef8dbbd457572">writeio</a> (const uint8_t *data, size_t length)</td></tr>
<tr class="memdesc:a45f05afcc82a5107db5ef8dbbd457572"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write data to the current position in the buffer. The position pointer will be updated.  <a href="classBuffer.html#a45f05afcc82a5107db5ef8dbbd457572">More...</a><br /></td></tr>
<tr class="separator:a45f05afcc82a5107db5ef8dbbd457572"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a812f0147433355162b1d0bb215aae3bd"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBuffer.html#a812f0147433355162b1d0bb215aae3bd">write_frame</a> (const uint8_t *data, size_t length, uint32_t frame_no)</td></tr>
<tr class="memdesc:a812f0147433355162b1d0bb215aae3bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write image data for the frame number into the buffer.  <a href="classBuffer.html#a812f0147433355162b1d0bb215aae3bd">More...</a><br /></td></tr>
<tr class="separator:a812f0147433355162b1d0bb215aae3bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a959151baf1ef09510d9e535844776690"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBuffer.html#a959151baf1ef09510d9e535844776690">flush</a> ()</td></tr>
<tr class="memdesc:a959151baf1ef09510d9e535844776690"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flush buffer to disk.  <a href="classBuffer.html#a959151baf1ef09510d9e535844776690">More...</a><br /></td></tr>
<tr class="separator:a959151baf1ef09510d9e535844776690"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b3dfc964718593fb99e6296ae90e982"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBuffer.html#a4b3dfc964718593fb99e6296ae90e982">clear</a> ()</td></tr>
<tr class="memdesc:a4b3dfc964718593fb99e6296ae90e982"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear (delete) buffer.  <a href="classBuffer.html#a4b3dfc964718593fb99e6296ae90e982">More...</a><br /></td></tr>
<tr class="separator:a4b3dfc964718593fb99e6296ae90e982"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa08968d973089252fc5e06e7af4c5303"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBuffer.html#aa08968d973089252fc5e06e7af4c5303">reserve</a> (size_t <a class="el" href="classBuffer.html#af19876bd44aaa1918ba81db4390b8bdf">size</a>)</td></tr>
<tr class="memdesc:aa08968d973089252fc5e06e7af4c5303"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reserve memory without changing size to reduce re-allocations.  <a href="classBuffer.html#aa08968d973089252fc5e06e7af4c5303">More...</a><br /></td></tr>
<tr class="separator:aa08968d973089252fc5e06e7af4c5303"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af40aa3d2d92dbae336dca9de9705c927"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBuffer.html#af40aa3d2d92dbae336dca9de9705c927">buffer_watermark</a> (uint32_t segment_no=0) const</td></tr>
<tr class="memdesc:af40aa3d2d92dbae336dca9de9705c927"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the current watermark of the file while transcoding.  <a href="classBuffer.html#af40aa3d2d92dbae336dca9de9705c927">More...</a><br /></td></tr>
<tr class="separator:af40aa3d2d92dbae336dca9de9705c927"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3641f3ebc9db8c804b8c23c3f0f4754"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBuffer.html#ac3641f3ebc9db8c804b8c23c3f0f4754">copy</a> (std::vector&lt; uint8_t &gt; *out_data, size_t offset, uint32_t segment_no=0)</td></tr>
<tr class="memdesc:ac3641f3ebc9db8c804b8c23c3f0f4754"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy buffered data into output buffer.  <a href="classBuffer.html#ac3641f3ebc9db8c804b8c23c3f0f4754">More...</a><br /></td></tr>
<tr class="separator:ac3641f3ebc9db8c804b8c23c3f0f4754"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3fece94b7da8cac563554333a781f82"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBuffer.html#af3fece94b7da8cac563554333a781f82">copy</a> (uint8_t *out_data, size_t offset, size_t <a class="el" href="classBuffer.html#ac456bcebc29eb15860d2ec2a49b41b00">bufsize</a>, uint32_t segment_no=0)</td></tr>
<tr class="memdesc:af3fece94b7da8cac563554333a781f82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy buffered data into output buffer.  <a href="classBuffer.html#af3fece94b7da8cac563554333a781f82">More...</a><br /></td></tr>
<tr class="separator:af3fece94b7da8cac563554333a781f82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88d7838706b8e4fa9f9c8f63812b6602"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBuffer.html#a88d7838706b8e4fa9f9c8f63812b6602">cachefile</a> (uint32_t segment_no) const</td></tr>
<tr class="memdesc:a88d7838706b8e4fa9f9c8f63812b6602"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get cache filename.  <a href="classBuffer.html#a88d7838706b8e4fa9f9c8f63812b6602">More...</a><br /></td></tr>
<tr class="separator:a88d7838706b8e4fa9f9c8f63812b6602"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a945f720e4cccfd811467cf0302121377"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBuffer.html#a945f720e4cccfd811467cf0302121377">have_frame</a> (uint32_t frame_no)</td></tr>
<tr class="memdesc:a945f720e4cccfd811467cf0302121377"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if we have the requested frame number. Works only when processing a frame set.  <a href="classBuffer.html#a945f720e4cccfd811467cf0302121377">More...</a><br /></td></tr>
<tr class="separator:a945f720e4cccfd811467cf0302121377"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fab95e5034961d75f12cdc861337972"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBuffer.html#a3fab95e5034961d75f12cdc861337972">finished_segment</a> ()</td></tr>
<tr class="memdesc:a3fab95e5034961d75f12cdc861337972"><td class="mdescLeft">&#160;</td><td class="mdescRight">Complete the segment decoding.  <a href="classBuffer.html#a3fab95e5034961d75f12cdc861337972">More...</a><br /></td></tr>
<tr class="separator:a3fab95e5034961d75f12cdc861337972"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cb529c4a6f6558cd26e450a72e149e9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBuffer.html#a7cb529c4a6f6558cd26e450a72e149e9">is_segment_finished</a> (uint32_t segment_no) const</td></tr>
<tr class="memdesc:a7cb529c4a6f6558cd26e450a72e149e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if transcoding of the segment is finished.  <a href="classBuffer.html#a7cb529c4a6f6558cd26e450a72e149e9">More...</a><br /></td></tr>
<tr class="separator:a7cb529c4a6f6558cd26e450a72e149e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1e0aaba88ec63658f8fe75056430da1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBuffer.html#af1e0aaba88ec63658f8fe75056430da1">open_file</a> (uint32_t segment_no, uint32_t flags, size_t defaultsize=0)</td></tr>
<tr class="memdesc:af1e0aaba88ec63658f8fe75056430da1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open the cache file if not already open.  <a href="classBuffer.html#af1e0aaba88ec63658f8fe75056430da1">More...</a><br /></td></tr>
<tr class="separator:af1e0aaba88ec63658f8fe75056430da1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4063a40b9acd193c18031f5e7964601"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBuffer.html#af4063a40b9acd193c18031f5e7964601">close_file</a> (uint32_t segment_no, uint32_t flags)</td></tr>
<tr class="memdesc:af4063a40b9acd193c18031f5e7964601"><td class="mdescLeft">&#160;</td><td class="mdescRight">If it hasn't already been done, close the cache file.  <a href="classBuffer.html#af4063a40b9acd193c18031f5e7964601">More...</a><br /></td></tr>
<tr class="separator:af4063a40b9acd193c18031f5e7964601"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classFileIO"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classFileIO')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classFileIO.html">FileIO</a></td></tr>
<tr class="memitem:a8b0d602c3461181e12c05f655dea5018 inherit pub_methods_classFileIO"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFileIO.html#a8b0d602c3461181e12c05f655dea5018">FileIO</a> ()</td></tr>
<tr class="memdesc:a8b0d602c3461181e12c05f655dea5018 inherit pub_methods_classFileIO"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create <a class="el" href="classFileIO.html" title="Base class for I/O.">FileIO</a> object.  <a href="classFileIO.html#a8b0d602c3461181e12c05f655dea5018">More...</a><br /></td></tr>
<tr class="separator:a8b0d602c3461181e12c05f655dea5018 inherit pub_methods_classFileIO"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cae1c200948a87a60cbc7a02856a5a6 inherit pub_methods_classFileIO"><td class="memItemLeft" align="right" valign="top"><a id="a5cae1c200948a87a60cbc7a02856a5a6" name="a5cae1c200948a87a60cbc7a02856a5a6"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><b>~FileIO</b> ()=default</td></tr>
<tr class="memdesc:a5cae1c200948a87a60cbc7a02856a5a6 inherit pub_methods_classFileIO"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free <a class="el" href="classFileIO.html" title="Base class for I/O.">FileIO</a> object. <br /></td></tr>
<tr class="separator:a5cae1c200948a87a60cbc7a02856a5a6 inherit pub_methods_classFileIO"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b56f0b1fcf994ff403335463d0eca9b inherit pub_methods_classFileIO"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="fileio_8h.html#a1199d38534b11312b0210e527499a805">VIRTUALTYPE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFileIO.html#a6b56f0b1fcf994ff403335463d0eca9b">type</a> () const =0</td></tr>
<tr class="memdesc:a6b56f0b1fcf994ff403335463d0eca9b inherit pub_methods_classFileIO"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get type of the virtual file.  <a href="classFileIO.html#a6b56f0b1fcf994ff403335463d0eca9b">More...</a><br /></td></tr>
<tr class="separator:a6b56f0b1fcf994ff403335463d0eca9b inherit pub_methods_classFileIO"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ef072d7a6f475c0b185c3912d828342 inherit pub_methods_classFileIO"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFileIO.html#a9ef072d7a6f475c0b185c3912d828342">bufsize</a> () const =0</td></tr>
<tr class="memdesc:a9ef072d7a6f475c0b185c3912d828342 inherit pub_methods_classFileIO"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the ideal buffer size.  <a href="classFileIO.html#a9ef072d7a6f475c0b185c3912d828342">More...</a><br /></td></tr>
<tr class="separator:a9ef072d7a6f475c0b185c3912d828342 inherit pub_methods_classFileIO"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac493dfa50e5cbc392c29feaccf4d9ce4 inherit pub_methods_classFileIO"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFileIO.html#ac493dfa50e5cbc392c29feaccf4d9ce4">openio</a> (<a class="el" href="fileio_8h.html#ae8356f209b2b74cc385a8d7551f1f27a">LPVIRTUALFILE</a> <a class="el" href="classFileIO.html#a2e330b909423f2118b8482732f50986a">virtualfile</a>)=0</td></tr>
<tr class="memdesc:ac493dfa50e5cbc392c29feaccf4d9ce4 inherit pub_methods_classFileIO"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open a virtual file.  <a href="classFileIO.html#ac493dfa50e5cbc392c29feaccf4d9ce4">More...</a><br /></td></tr>
<tr class="separator:ac493dfa50e5cbc392c29feaccf4d9ce4 inherit pub_methods_classFileIO"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b032367f4419b94afaad96a2c2d38d1 inherit pub_methods_classFileIO"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFileIO.html#a4b032367f4419b94afaad96a2c2d38d1">readio</a> (void *data, size_t <a class="el" href="classFileIO.html#a28df61747de114001d67ef6abad2ca7d">size</a>)=0</td></tr>
<tr class="memdesc:a4b032367f4419b94afaad96a2c2d38d1 inherit pub_methods_classFileIO"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read data from a file.  <a href="classFileIO.html#a4b032367f4419b94afaad96a2c2d38d1">More...</a><br /></td></tr>
<tr class="separator:a4b032367f4419b94afaad96a2c2d38d1 inherit pub_methods_classFileIO"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a705727f41def56f0d14c631514d3b115 inherit pub_methods_classFileIO"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFileIO.html#a705727f41def56f0d14c631514d3b115">error</a> () const =0</td></tr>
<tr class="memdesc:a705727f41def56f0d14c631514d3b115 inherit pub_methods_classFileIO"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get last error.  <a href="classFileIO.html#a705727f41def56f0d14c631514d3b115">More...</a><br /></td></tr>
<tr class="separator:a705727f41def56f0d14c631514d3b115 inherit pub_methods_classFileIO"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaffdefd15fa7c5e54a9733b1770c8bcd inherit pub_methods_classFileIO"><td class="memItemLeft" align="right" valign="top">virtual int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFileIO.html#aaffdefd15fa7c5e54a9733b1770c8bcd">duration</a> () const =0</td></tr>
<tr class="memdesc:aaffdefd15fa7c5e54a9733b1770c8bcd inherit pub_methods_classFileIO"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the duration of the file, in AV_TIME_BASE fractional seconds.  <a href="classFileIO.html#aaffdefd15fa7c5e54a9733b1770c8bcd">More...</a><br /></td></tr>
<tr class="separator:aaffdefd15fa7c5e54a9733b1770c8bcd inherit pub_methods_classFileIO"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28df61747de114001d67ef6abad2ca7d inherit pub_methods_classFileIO"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFileIO.html#a28df61747de114001d67ef6abad2ca7d">size</a> () const =0</td></tr>
<tr class="memdesc:a28df61747de114001d67ef6abad2ca7d inherit pub_methods_classFileIO"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the file size.  <a href="classFileIO.html#a28df61747de114001d67ef6abad2ca7d">More...</a><br /></td></tr>
<tr class="separator:a28df61747de114001d67ef6abad2ca7d inherit pub_methods_classFileIO"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a40140f766ff539cde0da854a1a9526 inherit pub_methods_classFileIO"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFileIO.html#a3a40140f766ff539cde0da854a1a9526">tell</a> () const =0</td></tr>
<tr class="memdesc:a3a40140f766ff539cde0da854a1a9526 inherit pub_methods_classFileIO"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get current read position.  <a href="classFileIO.html#a3a40140f766ff539cde0da854a1a9526">More...</a><br /></td></tr>
<tr class="separator:a3a40140f766ff539cde0da854a1a9526 inherit pub_methods_classFileIO"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0171ca18c497a09971e22cc5c381304b inherit pub_methods_classFileIO"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFileIO.html#a0171ca18c497a09971e22cc5c381304b">seek</a> (int64_t offset, int whence)=0</td></tr>
<tr class="memdesc:a0171ca18c497a09971e22cc5c381304b inherit pub_methods_classFileIO"><td class="mdescLeft">&#160;</td><td class="mdescRight">Seek to position in file.  <a href="classFileIO.html#a0171ca18c497a09971e22cc5c381304b">More...</a><br /></td></tr>
<tr class="separator:a0171ca18c497a09971e22cc5c381304b inherit pub_methods_classFileIO"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7bf956d13e66a11644c30c4b2b7d0ee inherit pub_methods_classFileIO"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFileIO.html#ad7bf956d13e66a11644c30c4b2b7d0ee">eof</a> () const =0</td></tr>
<tr class="memdesc:ad7bf956d13e66a11644c30c4b2b7d0ee inherit pub_methods_classFileIO"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if at end of file.  <a href="classFileIO.html#ad7bf956d13e66a11644c30c4b2b7d0ee">More...</a><br /></td></tr>
<tr class="separator:ad7bf956d13e66a11644c30c4b2b7d0ee inherit pub_methods_classFileIO"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68b26eb8099ac2b8b8d56d247b775d3a inherit pub_methods_classFileIO"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFileIO.html#a68b26eb8099ac2b8b8d56d247b775d3a">closeio</a> ()=0</td></tr>
<tr class="memdesc:a68b26eb8099ac2b8b8d56d247b775d3a inherit pub_methods_classFileIO"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close virtual file.  <a href="classFileIO.html#a68b26eb8099ac2b8b8d56d247b775d3a">More...</a><br /></td></tr>
<tr class="separator:a68b26eb8099ac2b8b8d56d247b775d3a inherit pub_methods_classFileIO"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e330b909423f2118b8482732f50986a inherit pub_methods_classFileIO"><td class="memItemLeft" align="right" valign="top"><a class="el" href="fileio_8h.html#ae8356f209b2b74cc385a8d7551f1f27a">LPVIRTUALFILE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFileIO.html#a2e330b909423f2118b8482732f50986a">virtualfile</a> ()</td></tr>
<tr class="memdesc:a2e330b909423f2118b8482732f50986a inherit pub_methods_classFileIO"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get virtual file object.  <a href="classFileIO.html#a2e330b909423f2118b8482732f50986a">More...</a><br /></td></tr>
<tr class="separator:a2e330b909423f2118b8482732f50986a inherit pub_methods_classFileIO"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcea64fae124756c68302ed355cc457f inherit pub_methods_classFileIO"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFileIO.html#afcea64fae124756c68302ed355cc457f">filename</a> () const</td></tr>
<tr class="memdesc:afcea64fae124756c68302ed355cc457f inherit pub_methods_classFileIO"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get source filename.  <a href="classFileIO.html#afcea64fae124756c68302ed355cc457f">More...</a><br /></td></tr>
<tr class="separator:afcea64fae124756c68302ed355cc457f inherit pub_methods_classFileIO"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a175ab839cce4af8b15749e31fd596e00 inherit pub_methods_classFileIO"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFileIO.html#a175ab839cce4af8b15749e31fd596e00">path</a> () const</td></tr>
<tr class="memdesc:a175ab839cce4af8b15749e31fd596e00 inherit pub_methods_classFileIO"><td class="mdescLeft">&#160;</td><td class="mdescRight">Path to source file (without file name)  <a href="classFileIO.html#a175ab839cce4af8b15749e31fd596e00">More...</a><br /></td></tr>
<tr class="separator:a175ab839cce4af8b15749e31fd596e00 inherit pub_methods_classFileIO"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a53adb0d9d3cd9c426d4384e46c116a08"><td class="memItemLeft" align="right" valign="top">static const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBuffer.html#a53adb0d9d3cd9c426d4384e46c116a08">make_cachefile_name</a> (std::string &amp;<a class="el" href="classBuffer.html#a88d7838706b8e4fa9f9c8f63812b6602">cachefile</a>, const std::string &amp;<a class="el" href="classFileIO.html#afcea64fae124756c68302ed355cc457f">filename</a>, const std::string &amp;fileext, bool is_idx)</td></tr>
<tr class="memdesc:a53adb0d9d3cd9c426d4384e46c116a08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make up a cache file name, including the full path.  <a href="classBuffer.html#a53adb0d9d3cd9c426d4384e46c116a08">More...</a><br /></td></tr>
<tr class="separator:a53adb0d9d3cd9c426d4384e46c116a08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d5aeca1d1b53238938a1d6d43b4e2dc"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBuffer.html#a7d5aeca1d1b53238938a1d6d43b4e2dc">remove_file</a> (const std::string &amp;<a class="el" href="classFileIO.html#afcea64fae124756c68302ed355cc457f">filename</a>)</td></tr>
<tr class="memdesc:a7d5aeca1d1b53238938a1d6d43b4e2dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove (unlink) the file.  <a href="classBuffer.html#a7d5aeca1d1b53238938a1d6d43b4e2dc">More...</a><br /></td></tr>
<tr class="separator:a7d5aeca1d1b53238938a1d6d43b4e2dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_methods_classFileIO"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classFileIO')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classFileIO.html">FileIO</a></td></tr>
<tr class="memitem:ab67ef47f0295909426a82d9fb29afa9e inherit pub_static_methods_classFileIO"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classFileIO.html">FileIO</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFileIO.html#ab67ef47f0295909426a82d9fb29afa9e">alloc</a> (<a class="el" href="fileio_8h.html#a1199d38534b11312b0210e527499a805">VIRTUALTYPE</a> <a class="el" href="classFileIO.html#a6b56f0b1fcf994ff403335463d0eca9b">type</a>)</td></tr>
<tr class="memdesc:ab67ef47f0295909426a82d9fb29afa9e inherit pub_static_methods_classFileIO"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate the correct object for <a class="el" href="classFileIO.html#a6b56f0b1fcf994ff403335463d0eca9b" title="Get type of the virtual file.">type()</a>.  <a href="classFileIO.html#ab67ef47f0295909426a82d9fb29afa9e">More...</a><br /></td></tr>
<tr class="separator:ab67ef47f0295909426a82d9fb29afa9e inherit pub_static_methods_classFileIO"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:ae4ea83b279915a9c0886dc621758e216"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBuffer.html#ae4ea83b279915a9c0886dc621758e216">remove_cachefile</a> (uint32_t segment_no=0) const</td></tr>
<tr class="memdesc:ae4ea83b279915a9c0886dc621758e216"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the cachefile.  <a href="classBuffer.html#ae4ea83b279915a9c0886dc621758e216">More...</a><br /></td></tr>
<tr class="separator:ae4ea83b279915a9c0886dc621758e216"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae98664dd11c6e2051d7de98cb15dee29"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBuffer.html#ae98664dd11c6e2051d7de98cb15dee29">is_open</a> ()</td></tr>
<tr class="memdesc:ae98664dd11c6e2051d7de98cb15dee29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the cache file is open.  <a href="classBuffer.html#ae98664dd11c6e2051d7de98cb15dee29">More...</a><br /></td></tr>
<tr class="separator:ae98664dd11c6e2051d7de98cb15dee29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classFileIO"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classFileIO')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classFileIO.html">FileIO</a></td></tr>
<tr class="memitem:a6596a9c65d31ef13a09d1fa162e76bba inherit pro_methods_classFileIO"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFileIO.html#a6596a9c65d31ef13a09d1fa162e76bba">set_virtualfile</a> (<a class="el" href="fileio_8h.html#ae8356f209b2b74cc385a8d7551f1f27a">LPVIRTUALFILE</a> <a class="el" href="classFileIO.html#a2e330b909423f2118b8482732f50986a">virtualfile</a>)</td></tr>
<tr class="memdesc:a6596a9c65d31ef13a09d1fa162e76bba inherit pro_methods_classFileIO"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the virtual file object.  <a href="classFileIO.html#a6596a9c65d31ef13a09d1fa162e76bba">More...</a><br /></td></tr>
<tr class="separator:a6596a9c65d31ef13a09d1fa162e76bba inherit pro_methods_classFileIO"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-methods" name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a303fc10672c2812a7b34bd203a6882ef"><td class="memItemLeft" align="right" valign="top">uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBuffer.html#a303fc10672c2812a7b34bd203a6882ef">write_prepare</a> (size_t length)</td></tr>
<tr class="memdesc:a303fc10672c2812a7b34bd203a6882ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepare for the writing operation.  <a href="classBuffer.html#a303fc10672c2812a7b34bd203a6882ef">More...</a><br /></td></tr>
<tr class="separator:a303fc10672c2812a7b34bd203a6882ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2408e983616a750858abadf29100c6f4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBuffer.html#a2408e983616a750858abadf29100c6f4">increment_pos</a> (size_t increment)</td></tr>
<tr class="memdesc:a2408e983616a750858abadf29100c6f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increment buffer position.  <a href="classBuffer.html#a2408e983616a750858abadf29100c6f4">More...</a><br /></td></tr>
<tr class="separator:a2408e983616a750858abadf29100c6f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbd9386f99f609c04764db011731f264"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBuffer.html#abbd9386f99f609c04764db011731f264">reallocate</a> (size_t newsize)</td></tr>
<tr class="memdesc:abbd9386f99f609c04764db011731f264"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reallocate the buffer to a new size.  <a href="classBuffer.html#abbd9386f99f609c04764db011731f264">More...</a><br /></td></tr>
<tr class="separator:abbd9386f99f609c04764db011731f264"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55b17588bedec5672bd5008575c5e1f8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBuffer.html#a55b17588bedec5672bd5008575c5e1f8">map_file</a> (const std::string &amp;<a class="el" href="classFileIO.html#afcea64fae124756c68302ed355cc457f">filename</a>, volatile int *fd, uint8_t **p, size_t *filesize, bool *isdefaultsize, size_t defaultsize, bool truncate) const</td></tr>
<tr class="memdesc:a55b17588bedec5672bd5008575c5e1f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map memory to a file.  <a href="classBuffer.html#a55b17588bedec5672bd5008575c5e1f8">More...</a><br /></td></tr>
<tr class="separator:a55b17588bedec5672bd5008575c5e1f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61e6ce35352f2102a12b08c564bf68c0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBuffer.html#a61e6ce35352f2102a12b08c564bf68c0">unmap_file</a> (const std::string &amp;<a class="el" href="classFileIO.html#afcea64fae124756c68302ed355cc457f">filename</a>, volatile int *fd, uint8_t **p, size_t len, size_t *filesize) const</td></tr>
<tr class="memdesc:a61e6ce35352f2102a12b08c564bf68c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unmap memory from the file.  <a href="classBuffer.html#a61e6ce35352f2102a12b08c564bf68c0">More...</a><br /></td></tr>
<tr class="separator:a61e6ce35352f2102a12b08c564bf68c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2eee1fab320110be86686ff522d2c433"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classBuffer.html#ad2b0f8fddd154c040e9b62dae6938bc0">LPCACHEINFO</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBuffer.html#a2eee1fab320110be86686ff522d2c433">cacheinfo</a> (uint32_t segment_no)</td></tr>
<tr class="memdesc:a2eee1fab320110be86686ff522d2c433"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get cache information.  <a href="classBuffer.html#a2eee1fab320110be86686ff522d2c433">More...</a><br /></td></tr>
<tr class="separator:a2eee1fab320110be86686ff522d2c433"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac73dbc698f23a66b900ccd5923df10a9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classBuffer.html#a839b6c6f82af952cd68e2e112804dadf">LPCCACHEINFO</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBuffer.html#ac73dbc698f23a66b900ccd5923df10a9">const_cacheinfo</a> (uint32_t segment_no) const</td></tr>
<tr class="memdesc:ac73dbc698f23a66b900ccd5923df10a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get cache information.  <a href="classBuffer.html#ac73dbc698f23a66b900ccd5923df10a9">More...</a><br /></td></tr>
<tr class="separator:ac73dbc698f23a66b900ccd5923df10a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-attribs" name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a7c412682c4217d94c97663d197f235c0"><td class="memItemLeft" align="right" valign="top">std::recursive_mutex&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBuffer.html#a7c412682c4217d94c97663d197f235c0">m_mutex</a></td></tr>
<tr class="memdesc:a7c412682c4217d94c97663d197f235c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access mutex.  <a href="classBuffer.html#a7c412682c4217d94c97663d197f235c0">More...</a><br /></td></tr>
<tr class="separator:a7c412682c4217d94c97663d197f235c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf27b7a77e5d22d16becf8ced3cb75ed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classBuffer.html#ad2b0f8fddd154c040e9b62dae6938bc0">LPCACHEINFO</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBuffer.html#adf27b7a77e5d22d16becf8ced3cb75ed">m_cur_ci</a></td></tr>
<tr class="memdesc:adf27b7a77e5d22d16becf8ced3cb75ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience pointer to current write segment.  <a href="classBuffer.html#adf27b7a77e5d22d16becf8ced3cb75ed">More...</a><br /></td></tr>
<tr class="separator:adf27b7a77e5d22d16becf8ced3cb75ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3291d599d037e29e1e9957e978258756"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBuffer.html#a3291d599d037e29e1e9957e978258756">m_cur_open</a></td></tr>
<tr class="memdesc:a3291d599d037e29e1e9957e978258756"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of open files.  <a href="classBuffer.html#a3291d599d037e29e1e9957e978258756">More...</a><br /></td></tr>
<tr class="separator:a3291d599d037e29e1e9957e978258756"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06d70fd4eff6ff0addb7bbd41f4654a1"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classBuffer.html#aadb6390b55aac6776448a8adc81696ed">CACHEINFO</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBuffer.html#a06d70fd4eff6ff0addb7bbd41f4654a1">m_ci</a></td></tr>
<tr class="memdesc:a06d70fd4eff6ff0addb7bbd41f4654a1"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classCache.html" title="The Cache class.">Cache</a> info.  <a href="classBuffer.html#a06d70fd4eff6ff0addb7bbd41f4654a1">More...</a><br /></td></tr>
<tr class="separator:a06d70fd4eff6ff0addb7bbd41f4654a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-static-attribs" name="pri-static-attribs"></a>
Static Private Attributes</h2></td></tr>
<tr class="memitem:a0c63511798ae2cafa041b14b70379ed0"><td class="memItemLeft" align="right" valign="top">static constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBuffer.html#a0c63511798ae2cafa041b14b70379ed0">PREALLOC_FACTOR</a> = 5</td></tr>
<tr class="memdesc:a0c63511798ae2cafa041b14b70379ed0"><td class="mdescLeft">&#160;</td><td class="mdescRight">PREALLOC_FACTOR - Number of elements allocated on reallocate calls Number of elements allocated on reallocate calls. The buffer keeps track of the typical buffer write size. To prevent repeated reallocations, <a class="el" href="classBuffer.html#abbd9386f99f609c04764db011731f264" title="Reallocate the buffer to a new size.">reallocate()</a> attempts to set aside enough memory for PREALLOC FACTOR average elements whenever it is invoked.  <a href="classBuffer.html#a0c63511798ae2cafa041b14b70379ed0">More...</a><br /></td></tr>
<tr class="separator:a0c63511798ae2cafa041b14b70379ed0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >The <a class="el" href="classBuffer.html" title="The Buffer class.">Buffer</a> class. </p>

<p class="definition">Definition at line <a class="el" href="buffer_8h_source.html#l00055">55</a> of file <a class="el" href="buffer_8h_source.html">buffer.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a839b6c6f82af952cd68e2e112804dadf" name="a839b6c6f82af952cd68e2e112804dadf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a839b6c6f82af952cd68e2e112804dadf">&#9670;&nbsp;</a></span>LPCCACHEINFO</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classBuffer.html#aadb6390b55aac6776448a8adc81696ed">CACHEINFO</a> const* <a class="el" href="classBuffer.html#a839b6c6f82af952cd68e2e112804dadf">Buffer::LPCCACHEINFO</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pointer to const version of CACHEINFO. </p>

<p class="definition">Definition at line <a class="el" href="buffer_8h_source.html#l00121">121</a> of file <a class="el" href="buffer_8h_source.html">buffer.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ae7ef2cd201190fde551dcb902627112b" name="ae7ef2cd201190fde551dcb902627112b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7ef2cd201190fde551dcb902627112b">&#9670;&nbsp;</a></span>Buffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Buffer::Buffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create <a class="el" href="classBuffer.html" title="The Buffer class.">Buffer</a> object. </p>

<p class="definition">Definition at line <a class="el" href="buffer_8cc_source.html#l00042">42</a> of file <a class="el" href="buffer_8cc_source.html">buffer.cc</a>.</p>

</div>
</div>
<a id="a59b8743e4a5f731bdd0c4185c9ef263b" name="a59b8743e4a5f731bdd0c4185c9ef263b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59b8743e4a5f731bdd0c4185c9ef263b">&#9670;&nbsp;</a></span>~Buffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Buffer::~Buffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Free <a class="el" href="classBuffer.html" title="The Buffer class.">Buffer</a> object. </p>
<p >Release memory and close files </p>

<p class="definition">Definition at line <a class="el" href="buffer_8cc_source.html#l00049">49</a> of file <a class="el" href="buffer_8cc_source.html">buffer.cc</a>.</p>

<p class="reference">References <a class="el" href="buffer_8cc_source.html#l00494">release()</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="af40aa3d2d92dbae336dca9de9705c927" name="af40aa3d2d92dbae336dca9de9705c927"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af40aa3d2d92dbae336dca9de9705c927">&#9670;&nbsp;</a></span>buffer_watermark()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t Buffer::buffer_watermark </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>segment_no</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the current watermark of the file while transcoding. </p>
<p >While transcoding, this value reflects the current size of the transcoded file. This is the maximum byte offset until the file can be read so far.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">segment_no</td><td>- If &gt; 0 returns watermark for specific segment. If 0, returns watermark for current write segment. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the current watermark. </dd></dl>

<p class="definition">Definition at line <a class="el" href="buffer_8cc_source.html#l00865">865</a> of file <a class="el" href="buffer_8cc_source.html">buffer.cc</a>.</p>

<p class="reference">References <a class="el" href="buffer_8cc_source.html#l01134">const_cacheinfo()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ffmpeg__transcoder_8cc_source.html#l06169">FFmpeg_Transcoder::encode_finish()</a>, <a class="el" href="cache__entry_8cc_source.html#l00262">Cache_Entry::size()</a>, <a class="el" href="transcode_8cc_source.html#l00777">transcode()</a>, <a class="el" href="transcode_8cc_source.html#l00156">transcode_finish()</a>, <a class="el" href="transcode_8cc_source.html#l00730">transcoder_buffer_watermark()</a>, and <a class="el" href="buffer_8cc_source.html#l00691">write_frame()</a>.</p>

</div>
</div>
<a id="ac456bcebc29eb15860d2ec2a49b41b00" name="ac456bcebc29eb15860d2ec2a49b41b00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac456bcebc29eb15860d2ec2a49b41b00">&#9670;&nbsp;</a></span>bufsize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t Buffer::bufsize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Size of this buffer. </p>
<dl class="section return"><dt>Returns</dt><dd>Not applicable, returns 0. </dd></dl>

<p>Implements <a class="el" href="classFileIO.html#a9ef072d7a6f475c0b185c3912d828342">FileIO</a>.</p>

<p class="definition">Definition at line <a class="el" href="buffer_8cc_source.html#l00059">59</a> of file <a class="el" href="buffer_8cc_source.html">buffer.cc</a>.</p>

<p class="reference">Referenced by <a class="el" href="buffer_8cc_source.html#l00883">copy()</a>.</p>

</div>
</div>
<a id="a88d7838706b8e4fa9f9c8f63812b6602" name="a88d7838706b8e4fa9f9c8f63812b6602"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88d7838706b8e4fa9f9c8f63812b6602">&#9670;&nbsp;</a></span>cachefile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string &amp; Buffer::cachefile </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>segment_no</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get cache filename. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">segment_no</td><td>- [1..n] HLS segment file number or 0 for the current segment. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns cache filename. </dd></dl>

<p class="definition">Definition at line <a class="el" href="buffer_8cc_source.html#l00957">957</a> of file <a class="el" href="buffer_8cc_source.html">buffer.cc</a>.</p>

<p class="reference">References <a class="el" href="buffer_8cc_source.html#l01134">const_cacheinfo()</a>.</p>

<p class="reference">Referenced by <a class="el" href="buffer_8cc_source.html#l00971">make_cachefile_name()</a>.</p>

</div>
</div>
<a id="a2eee1fab320110be86686ff522d2c433" name="a2eee1fab320110be86686ff522d2c433"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2eee1fab320110be86686ff522d2c433">&#9670;&nbsp;</a></span>cacheinfo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBuffer.html#ad2b0f8fddd154c040e9b62dae6938bc0">Buffer::LPCACHEINFO</a> Buffer::cacheinfo </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>segment_no</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get cache information. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">segment_no</td><td>- HLS segment file number [1..n] or 0 for the current segment. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to CACHEINFO object, or nullptr on error. </dd></dl>

<p class="definition">Definition at line <a class="el" href="buffer_8cc_source.html#l01118">1118</a> of file <a class="el" href="buffer_8cc_source.html">buffer.cc</a>.</p>

<p class="reference">References <a class="el" href="buffer_8h_source.html#l00477">m_ci</a>, <a class="el" href="buffer_8h_source.html#l00474">m_cur_ci</a>, and <a class="el" href="buffer_8cc_source.html#l00332">segment_count()</a>.</p>

<p class="reference">Referenced by <a class="el" href="buffer_8cc_source.html#l00772">seek()</a>.</p>

</div>
</div>
<a id="a4b3dfc964718593fb99e6296ae90e982" name="a4b3dfc964718593fb99e6296ae90e982"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b3dfc964718593fb99e6296ae90e982">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Buffer::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear (delete) buffer. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns true on success; false on error. Check errno for details. </dd></dl>

<p class="definition">Definition at line <a class="el" href="buffer_8cc_source.html#l00587">587</a> of file <a class="el" href="buffer_8cc_source.html">buffer.cc</a>.</p>

<p class="reference">References <a class="el" href="logging_8h_source.html#l00239">Logging::error()</a>, <a class="el" href="buffer_8h_source.html#l00477">m_ci</a>, <a class="el" href="buffer_8h_source.html#l00473">m_mutex</a>, and <a class="el" href="buffer_8cc_source.html#l00991">remove_file()</a>.</p>

<p class="reference">Referenced by <a class="el" href="cache__entry_8cc_source.html#l00087">Cache_Entry::clear()</a>.</p>

</div>
</div>
<a id="af4063a40b9acd193c18031f5e7964601" name="af4063a40b9acd193c18031f5e7964601"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4063a40b9acd193c18031f5e7964601">&#9670;&nbsp;</a></span>close_file()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Buffer::close_file </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>segment_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If it hasn't already been done, close the cache file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">segment_no</td><td>- [0..n-1] Index of segment file number. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>- CACHE_FLAG_* options </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true if the operation was successful or the file was already closed; false otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="buffer_8cc_source.html#l00137">137</a> of file <a class="el" href="buffer_8cc_source.html">buffer.cc</a>.</p>

<p class="reference">References <a class="el" href="buffer_8h_source.html#l00105">Buffer::_tagCACHEINFO::m_buffer</a>, <a class="el" href="buffer_8h_source.html#l00106">Buffer::_tagCACHEINFO::m_buffer_pos</a>, <a class="el" href="buffer_8h_source.html#l00108">Buffer::_tagCACHEINFO::m_buffer_size</a>, <a class="el" href="buffer_8h_source.html#l00107">Buffer::_tagCACHEINFO::m_buffer_watermark</a>, <a class="el" href="buffer_8h_source.html#l00103">Buffer::_tagCACHEINFO::m_cachefile</a>, <a class="el" href="buffer_8h_source.html#l00477">m_ci</a>, <a class="el" href="buffer_8h_source.html#l00475">m_cur_open</a>, <a class="el" href="buffer_8h_source.html#l00104">Buffer::_tagCACHEINFO::m_fd</a>, <a class="el" href="buffer_8h_source.html#l00116">Buffer::_tagCACHEINFO::m_flags</a>, <a class="el" href="buffer_8h_source.html#l00473">m_mutex</a>, <a class="el" href="logging_8h_source.html#l00163">Logging::trace()</a>, and <a class="el" href="buffer_8cc_source.html#l00444">unmap_file()</a>.</p>

<p class="reference">Referenced by <a class="el" href="fuseops_8cc_source.html#l01302">ffmpegfs_release()</a>, <a class="el" href="buffer_8cc_source.html#l00494">release()</a>, and <a class="el" href="buffer_8cc_source.html#l00306">set_segment()</a>.</p>

</div>
</div>
<a id="a65d7c1048d8c8713a6266fd78afc2e02" name="a65d7c1048d8c8713a6266fd78afc2e02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65d7c1048d8c8713a6266fd78afc2e02">&#9670;&nbsp;</a></span>closeio()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Buffer::closeio </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Close buffer. </p>

<p>Implements <a class="el" href="classFileIO.html#a68b26eb8099ac2b8b8d56d247b775d3a">FileIO</a>.</p>

<p class="definition">Definition at line <a class="el" href="buffer_8cc_source.html#l01054">1054</a> of file <a class="el" href="buffer_8cc_source.html">buffer.cc</a>.</p>

<p class="reference">References <a class="el" href="buffer_8cc_source.html#l00494">release()</a>.</p>

</div>
</div>
<a id="ac73dbc698f23a66b900ccd5923df10a9" name="ac73dbc698f23a66b900ccd5923df10a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac73dbc698f23a66b900ccd5923df10a9">&#9670;&nbsp;</a></span>const_cacheinfo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBuffer.html#a839b6c6f82af952cd68e2e112804dadf">Buffer::LPCCACHEINFO</a> Buffer::const_cacheinfo </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>segment_no</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get cache information. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">segment_no</td><td>- HLS segment file number [1..n] or 0 for the current segment. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to CACHEINFO object, or nullptr on error. </dd></dl>

<p class="definition">Definition at line <a class="el" href="buffer_8cc_source.html#l01134">1134</a> of file <a class="el" href="buffer_8cc_source.html">buffer.cc</a>.</p>

<p class="reference">References <a class="el" href="buffer_8h_source.html#l00477">m_ci</a>, and <a class="el" href="buffer_8h_source.html#l00474">m_cur_ci</a>.</p>

<p class="reference">Referenced by <a class="el" href="buffer_8cc_source.html#l00865">buffer_watermark()</a>, <a class="el" href="buffer_8cc_source.html#l00957">cachefile()</a>, <a class="el" href="buffer_8cc_source.html#l00883">copy()</a>, <a class="el" href="buffer_8cc_source.html#l01105">is_segment_finished()</a>, <a class="el" href="buffer_8cc_source.html#l00852">size()</a>, and <a class="el" href="buffer_8cc_source.html#l00829">tell()</a>.</p>

</div>
</div>
<a id="ac3641f3ebc9db8c804b8c23c3f0f4754" name="ac3641f3ebc9db8c804b8c23c3f0f4754"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3641f3ebc9db8c804b8c23c3f0f4754">&#9670;&nbsp;</a></span>copy() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Buffer::copy </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; uint8_t &gt; *&#160;</td>
          <td class="paramname"><em>out_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>segment_no</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy buffered data into output buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">out_data</td><td>- <a class="el" href="classBuffer.html" title="The Buffer class.">Buffer</a> to copy data to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>- Offset in buffer to copy data from. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">segment_no</td><td>- HLS segment file number [1..n] or 0 for current segment. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true on success; false on error. </dd></dl>

<p class="definition">Definition at line <a class="el" href="buffer_8cc_source.html#l00878">878</a> of file <a class="el" href="buffer_8cc_source.html">buffer.cc</a>.</p>

<p class="reference">References <a class="el" href="buffer_8cc_source.html#l00878">copy()</a>.</p>

<p class="reference">Referenced by <a class="el" href="buffer_8cc_source.html#l00878">copy()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l02978">FFmpeg_Transcoder::create_fake_wav_header()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l03036">FFmpeg_Transcoder::read_aiff_chunk()</a>, and <a class="el" href="buffer_8cc_source.html#l01012">read_frame()</a>.</p>

</div>
</div>
<a id="af3fece94b7da8cac563554333a781f82" name="af3fece94b7da8cac563554333a781f82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3fece94b7da8cac563554333a781f82">&#9670;&nbsp;</a></span>copy() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Buffer::copy </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>out_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bufsize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>segment_no</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy buffered data into output buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">out_data</td><td>- <a class="el" href="classBuffer.html" title="The Buffer class.">Buffer</a> to copy data to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>- Offset in buffer to copy data from. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bufsize</td><td>- Size of out_data buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">segment_no</td><td>- [1..n] HLS segment file number or 0 for the current segment. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true on success; false on error. </dd></dl>

<p class="definition">Definition at line <a class="el" href="buffer_8cc_source.html#l00883">883</a> of file <a class="el" href="buffer_8cc_source.html">buffer.cc</a>.</p>

<p class="reference">References <a class="el" href="buffer_8cc_source.html#l00059">bufsize()</a>, <a class="el" href="buffer_8cc_source.html#l01134">const_cacheinfo()</a>, <a class="el" href="logging_8h_source.html#l00239">Logging::error()</a>, and <a class="el" href="buffer_8h_source.html#l00473">m_mutex</a>.</p>

</div>
</div>
<a id="aa356d401405307f29e73586c7cad10c4" name="aa356d401405307f29e73586c7cad10c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa356d401405307f29e73586c7cad10c4">&#9670;&nbsp;</a></span>current_segment_no()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t Buffer::current_segment_no </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the currently selected segment. </p>
<dl class="section return"><dt>Returns</dt><dd>current segment number [1..n], or 0 if none is chosen. </dd></dl>

<p class="definition">Definition at line <a class="el" href="buffer_8cc_source.html#l00339">339</a> of file <a class="el" href="buffer_8cc_source.html">buffer.cc</a>.</p>

<p class="reference">References <a class="el" href="buffer_8h_source.html#l00477">m_ci</a>, <a class="el" href="buffer_8h_source.html#l00474">m_cur_ci</a>, <a class="el" href="buffer_8h_source.html#l00473">m_mutex</a>, and <a class="el" href="buffer_8cc_source.html#l00332">segment_count()</a>.</p>

<p class="reference">Referenced by <a class="el" href="buffer_8cc_source.html#l00306">set_segment()</a>.</p>

</div>
</div>
<a id="a0a2f7eefd5aba36d4600c0b449136cbb" name="a0a2f7eefd5aba36d4600c0b449136cbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a2f7eefd5aba36d4600c0b449136cbb">&#9670;&nbsp;</a></span>duration()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int64_t Buffer::duration </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the duration of the file, in AV_TIME_BASE fractional seconds. </p>
<dl class="section return"><dt>Returns</dt><dd>Not applicable to buffer, always returns AV_NOPTS_VALUE. </dd></dl>

<p>Implements <a class="el" href="classFileIO.html#aaffdefd15fa7c5e54a9733b1770c8bcd">FileIO</a>.</p>

<p class="definition">Definition at line <a class="el" href="buffer_8cc_source.html#l00842">842</a> of file <a class="el" href="buffer_8cc_source.html">buffer.cc</a>.</p>

</div>
</div>
<a id="a1f84830369270e42e386585386716e95" name="a1f84830369270e42e386585386716e95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f84830369270e42e386585386716e95">&#9670;&nbsp;</a></span>eof() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Buffer::eof </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if at end of file. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns true if at end of buffer. </dd></dl>

<p>Implements <a class="el" href="classFileIO.html#ad7bf956d13e66a11644c30c4b2b7d0ee">FileIO</a>.</p>

<p class="definition">Definition at line <a class="el" href="buffer_8cc_source.html#l01044">1044</a> of file <a class="el" href="buffer_8cc_source.html">buffer.cc</a>.</p>

<p class="reference">References <a class="el" href="buffer_8cc_source.html#l01044">eof()</a>.</p>

<p class="reference">Referenced by <a class="el" href="buffer_8cc_source.html#l01044">eof()</a>, and <a class="el" href="ffmpeg__transcoder_8cc_source.html#l03036">FFmpeg_Transcoder::read_aiff_chunk()</a>.</p>

</div>
</div>
<a id="ae6b9ebe68de81852063d2b4f6f7e6cd4" name="ae6b9ebe68de81852063d2b4f6f7e6cd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6b9ebe68de81852063d2b4f6f7e6cd4">&#9670;&nbsp;</a></span>eof() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Buffer::eof </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>segment_no</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if at end of file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">segment_no</td><td>- [1..n] HLS segment file number or 0 for the current segment. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true if at end of buffer. </dd></dl>

<p class="definition">Definition at line <a class="el" href="buffer_8cc_source.html#l01049">1049</a> of file <a class="el" href="buffer_8cc_source.html">buffer.cc</a>.</p>

<p class="reference">References <a class="el" href="buffer_8cc_source.html#l00847">size()</a>, and <a class="el" href="buffer_8cc_source.html#l00824">tell()</a>.</p>

</div>
</div>
<a id="ac0201a3b37fc6ba862d69373b82ece6e" name="ac0201a3b37fc6ba862d69373b82ece6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0201a3b37fc6ba862d69373b82ece6e">&#9670;&nbsp;</a></span>error()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Buffer::error </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get last error. </p>
<dl class="section return"><dt>Returns</dt><dd>errno value of last error. </dd></dl>

<p>Implements <a class="el" href="classFileIO.html#a705727f41def56f0d14c631514d3b115">FileIO</a>.</p>

<p class="definition">Definition at line <a class="el" href="buffer_8cc_source.html#l01039">1039</a> of file <a class="el" href="buffer_8cc_source.html">buffer.cc</a>.</p>

</div>
</div>
<a id="a3fab95e5034961d75f12cdc861337972" name="a3fab95e5034961d75f12cdc861337972"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fab95e5034961d75f12cdc861337972">&#9670;&nbsp;</a></span>finished_segment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Buffer::finished_segment </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Complete the segment decoding. </p>

<p class="definition">Definition at line <a class="el" href="buffer_8cc_source.html#l01093">1093</a> of file <a class="el" href="buffer_8cc_source.html">buffer.cc</a>.</p>

<p class="reference">References <a class="el" href="buffer_8cc_source.html#l00559">flush()</a>, <a class="el" href="buffer_8h_source.html#l00474">m_cur_ci</a>, and <a class="el" href="buffer_8h_source.html#l00109">Buffer::_tagCACHEINFO::m_seg_finished</a>.</p>

<p class="reference">Referenced by <a class="el" href="ffmpeg__transcoder_8cc_source.html#l06169">FFmpeg_Transcoder::encode_finish()</a>.</p>

</div>
</div>
<a id="a959151baf1ef09510d9e535844776690" name="a959151baf1ef09510d9e535844776690"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a959151baf1ef09510d9e535844776690">&#9670;&nbsp;</a></span>flush()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Buffer::flush </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flush buffer to disk. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns true on success; false on error. Check errno for details. </dd></dl>

<p class="definition">Definition at line <a class="el" href="buffer_8cc_source.html#l00559">559</a> of file <a class="el" href="buffer_8cc_source.html">buffer.cc</a>.</p>

<p class="reference">References <a class="el" href="logging_8h_source.html#l00239">Logging::error()</a>, <a class="el" href="buffer_8h_source.html#l00105">Buffer::_tagCACHEINFO::m_buffer</a>, <a class="el" href="buffer_8h_source.html#l00113">Buffer::_tagCACHEINFO::m_buffer_idx</a>, <a class="el" href="buffer_8h_source.html#l00108">Buffer::_tagCACHEINFO::m_buffer_size</a>, <a class="el" href="buffer_8h_source.html#l00114">Buffer::_tagCACHEINFO::m_buffer_size_idx</a>, <a class="el" href="buffer_8h_source.html#l00103">Buffer::_tagCACHEINFO::m_cachefile</a>, <a class="el" href="buffer_8h_source.html#l00111">Buffer::_tagCACHEINFO::m_cachefile_idx</a>, <a class="el" href="buffer_8h_source.html#l00474">m_cur_ci</a>, <a class="el" href="buffer_8h_source.html#l00473">m_mutex</a>, and <a class="el" href="buffer_8cc_source.html#l00332">segment_count()</a>.</p>

<p class="reference">Referenced by <a class="el" href="buffer_8cc_source.html#l01093">finished_segment()</a>, <a class="el" href="cache__entry_8cc_source.html#l00248">Cache_Entry::flush()</a>, and <a class="el" href="buffer_8cc_source.html#l00494">release()</a>.</p>

</div>
</div>
<a id="a945f720e4cccfd811467cf0302121377" name="a945f720e4cccfd811467cf0302121377"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a945f720e4cccfd811467cf0302121377">&#9670;&nbsp;</a></span>have_frame()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Buffer::have_frame </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>frame_no</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if we have the requested frame number. Works only when processing a frame set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">frame_no</td><td>- 1...frames </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true if the frame is already in the cache, false if not. </dd></dl>

<p class="definition">Definition at line <a class="el" href="buffer_8cc_source.html#l01059">1059</a> of file <a class="el" href="buffer_8cc_source.html">buffer.cc</a>.</p>

<p class="reference">References <a class="el" href="buffer_8h_source.html#l00113">Buffer::_tagCACHEINFO::m_buffer_idx</a>, <a class="el" href="buffer_8h_source.html#l00474">m_cur_ci</a>, <a class="el" href="buffer_8h_source.html#l00473">m_mutex</a>, and <a class="el" href="fileio_8cc_source.html#l00114">FileIO::virtualfile()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ffmpeg__transcoder_8cc_source.html#l05465">FFmpeg_Transcoder::seek_frame()</a>, and <a class="el" href="ffmpeg__transcoder_8cc_source.html#l05058">FFmpeg_Transcoder::skip_decoded_frames()</a>.</p>

</div>
</div>
<a id="a2408e983616a750858abadf29100c6f4" name="a2408e983616a750858abadf29100c6f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2408e983616a750858abadf29100c6f4">&#9670;&nbsp;</a></span>increment_pos()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Buffer::increment_pos </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>increment</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Increment buffer position. </p>
<p >Increment the location of the internal pointer. This cannot fail and so returns void. It does not ensure the position is valid memory. That is done by the write_prepare methods via reallocate. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">increment</td><td>- Increment size. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="buffer_8cc_source.html#l00762">762</a> of file <a class="el" href="buffer_8cc_source.html">buffer.cc</a>.</p>

<p class="reference">References <a class="el" href="buffer_8h_source.html#l00106">Buffer::_tagCACHEINFO::m_buffer_pos</a>, and <a class="el" href="buffer_8h_source.html#l00474">m_cur_ci</a>.</p>

<p class="reference">Referenced by <a class="el" href="buffer_8cc_source.html#l00664">writeio()</a>.</p>

</div>
</div>
<a id="a6e315544b35bbaf0706ef8fbd6bfdbfb" name="a6e315544b35bbaf0706ef8fbd6bfdbfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e315544b35bbaf0706ef8fbd6bfdbfb">&#9670;&nbsp;</a></span>init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Buffer::init </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>erase_cache</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialise cache. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">erase_cache</td><td>- If true, delete the old file before opening. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true on success; false on error. </dd></dl>

<p class="definition">Definition at line <a class="el" href="buffer_8cc_source.html#l00179">179</a> of file <a class="el" href="buffer_8cc_source.html">buffer.cc</a>.</p>

<p class="reference">References <a class="el" href="ffmpegfs_8cc_source.html#l00239">FFMPEGFS_PARAMS::current_format()</a>, <a class="el" href="logging_8h_source.html#l00239">Logging::error()</a>, <a class="el" href="fileio_8cc_source.html#l00124">FileIO::filename()</a>, <a class="el" href="fileio_8cc_source.html#l00046">VIRTUALFILE::get_segment_count()</a>, <a class="el" href="buffer_8cc_source.html#l01078">is_open()</a>, <a class="el" href="buffer_8h_source.html#l00477">m_ci</a>, <a class="el" href="buffer_8h_source.html#l00474">m_cur_ci</a>, <a class="el" href="buffer_8h_source.html#l00473">m_mutex</a>, <a class="el" href="fileio_8h_source.html#l00156">VIRTUALFILE::m_video_frame_count</a>, <a class="el" href="buffer_8cc_source.html#l00971">make_cachefile_name()</a>, <a class="el" href="ffmpeg__utils_8cc_source.html#l02086">make_filename()</a>, <a class="el" href="buffer_8cc_source.html#l00361">map_file()</a>, <a class="el" href="ffmpeg__utils_8cc_source.html#l01376">mktree()</a>, <a class="el" href="ffmpeg__utils_8cc_source.html#l01122">new_strdup()</a>, <a class="el" href="ffmpegfs_8cc_source.html#l00076">params</a>, <a class="el" href="buffer_8cc_source.html#l00544">remove_cachefile()</a>, <a class="el" href="fileio_8cc_source.html#l00114">FileIO::virtualfile()</a>, <a class="el" href="fileio_8h_source.html#l00113">VIRTUALFLAG_FRAME</a>, and <a class="el" href="fileio_8h_source.html#l00114">VIRTUALFLAG_HLS</a>.</p>

<p class="reference">Referenced by <a class="el" href="cache__entry_8cc_source.html#l00162">Cache_Entry::openio()</a>.</p>

</div>
</div>
<a id="ae98664dd11c6e2051d7de98cb15dee29" name="ae98664dd11c6e2051d7de98cb15dee29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae98664dd11c6e2051d7de98cb15dee29">&#9670;&nbsp;</a></span>is_open()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Buffer::is_open </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the cache file is open. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns true if the cache file is open; false if not. </dd></dl>

<p class="definition">Definition at line <a class="el" href="buffer_8cc_source.html#l01078">1078</a> of file <a class="el" href="buffer_8cc_source.html">buffer.cc</a>.</p>

<p class="reference">References <a class="el" href="buffer_8h_source.html#l00477">m_ci</a>, and <a class="el" href="buffer_8h_source.html#l00473">m_mutex</a>.</p>

<p class="reference">Referenced by <a class="el" href="buffer_8cc_source.html#l00179">init()</a>, and <a class="el" href="buffer_8cc_source.html#l00494">release()</a>.</p>

</div>
</div>
<a id="a7cb529c4a6f6558cd26e450a72e149e9" name="a7cb529c4a6f6558cd26e450a72e149e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cb529c4a6f6558cd26e450a72e149e9">&#9670;&nbsp;</a></span>is_segment_finished()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Buffer::is_segment_finished </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>segment_no</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if transcoding of the segment is finished. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">segment_no</td><td>- [1..n] HLS segment file number or 0 for the current segment. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true if finished, false if not. </dd></dl>

<p class="definition">Definition at line <a class="el" href="buffer_8cc_source.html#l01105">1105</a> of file <a class="el" href="buffer_8cc_source.html">buffer.cc</a>.</p>

<p class="reference">References <a class="el" href="buffer_8cc_source.html#l01134">const_cacheinfo()</a>.</p>

<p class="reference">Referenced by <a class="el" href="transcode_8cc_source.html#l00081">transcode_until()</a>.</p>

</div>
</div>
<a id="a53adb0d9d3cd9c426d4384e46c116a08" name="a53adb0d9d3cd9c426d4384e46c116a08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53adb0d9d3cd9c426d4384e46c116a08">&#9670;&nbsp;</a></span>make_cachefile_name()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string &amp; Buffer::make_cachefile_name </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>cachefile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fileext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make up a cache file name, including the full path. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">cachefile</td><td>- Name of cache file. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filename</td><td>- Source file name. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fileext</td><td>- File extension (MP4, WEBM etc.). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">is_idx</td><td>- If true, create an index file; otherwise, create a cache. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the name of the cache/index file. </dd></dl>

<p class="definition">Definition at line <a class="el" href="buffer_8cc_source.html#l00971">971</a> of file <a class="el" href="buffer_8cc_source.html">buffer.cc</a>.</p>

<p class="reference">References <a class="el" href="buffer_8cc_source.html#l00957">cachefile()</a>, <a class="el" href="fileio_8cc_source.html#l00124">FileIO::filename()</a>, <a class="el" href="ffmpegfs_8h_source.html#l00198">FFMPEGFS_PARAMS::m_mountpath</a>, <a class="el" href="ffmpegfs_8cc_source.html#l00076">params</a>, and <a class="el" href="transcode_8cc_source.html#l00195">transcoder_cache_path()</a>.</p>

<p class="reference">Referenced by <a class="el" href="buffer_8cc_source.html#l00179">init()</a>, <a class="el" href="fuseops_8cc_source.html#l01759">load_path()</a>, and <a class="el" href="fuseops_8cc_source.html#l02000">make_hls_fileset()</a>.</p>

</div>
</div>
<a id="a55b17588bedec5672bd5008575c5e1f8" name="a55b17588bedec5672bd5008575c5e1f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55b17588bedec5672bd5008575c5e1f8">&#9670;&nbsp;</a></span>map_file()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Buffer::map_file </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">volatile int *&#160;</td>
          <td class="paramname"><em>fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t **&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>filesize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>isdefaultsize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>defaultsize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>truncate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Map memory to a file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">filename</td><td>- Name of the cache file to open. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">fd</td><td>- The file descriptor of the open cache file. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">p</td><td>- Memory pointer to the cache file. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">filesize</td><td>- Actual size of the cache file after this call. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">isdefaultsize</td><td>-<br  />
In: If false, the file size will be the size of the existing file, returning the size in filesize. If the file does not exist, it will be sized to defaultsize. If true, the defaultsize will be used in any case, resizing an existing file if necessary.<br  />
Out: true if the file size was set to default. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">defaultsize</td><td>- The default size of the file if it does not exist. This parameter can be zero, in which case the size will be set to the system's page size. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">truncate</td><td>- If true, when the file is opened, it is truncated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true if successful and fd, p, filesize, and isdefaultsize are filled in, or false on error. </dd></dl>

<p class="definition">Definition at line <a class="el" href="buffer_8cc_source.html#l00361">361</a> of file <a class="el" href="buffer_8cc_source.html">buffer.cc</a>.</p>

<p class="reference">References <a class="el" href="logging_8h_source.html#l00239">Logging::error()</a>, <a class="el" href="fileio_8cc_source.html#l00124">FileIO::filename()</a>, <a class="el" href="ffmpeg__utils_8cc_source.html#l01632">format_size()</a>, and <a class="el" href="logging_8h_source.html#l00163">Logging::trace()</a>.</p>

<p class="reference">Referenced by <a class="el" href="buffer_8cc_source.html#l00179">init()</a>, and <a class="el" href="buffer_8cc_source.html#l00077">open_file()</a>.</p>

</div>
</div>
<a id="af1e0aaba88ec63658f8fe75056430da1" name="af1e0aaba88ec63658f8fe75056430da1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1e0aaba88ec63658f8fe75056430da1">&#9670;&nbsp;</a></span>open_file()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Buffer::open_file </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>segment_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>defaultsize</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Open the cache file if not already open. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">segment_no</td><td>- [0..n-1] Index of segment file number. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>- CACHE_FLAG_* options. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">defaultsize</td><td>- If nonzero, after opening, the file will be resized to this value. Works on writeable files only. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true if the operation was successful or the file was already open; false otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="buffer_8cc_source.html#l00077">77</a> of file <a class="el" href="buffer_8cc_source.html">buffer.cc</a>.</p>

<p class="reference">References <a class="el" href="buffer_8h_source.html#l00050">CACHE_FLAG_RW</a>, <a class="el" href="logging_8h_source.html#l00182">Logging::debug()</a>, <a class="el" href="buffer_8h_source.html#l00105">Buffer::_tagCACHEINFO::m_buffer</a>, <a class="el" href="buffer_8h_source.html#l00106">Buffer::_tagCACHEINFO::m_buffer_pos</a>, <a class="el" href="buffer_8h_source.html#l00108">Buffer::_tagCACHEINFO::m_buffer_size</a>, <a class="el" href="buffer_8h_source.html#l00107">Buffer::_tagCACHEINFO::m_buffer_watermark</a>, <a class="el" href="buffer_8h_source.html#l00118">Buffer::_tagCACHEINFO::m_buffer_write_size</a>, <a class="el" href="buffer_8h_source.html#l00119">Buffer::_tagCACHEINFO::m_buffer_writes</a>, <a class="el" href="buffer_8h_source.html#l00103">Buffer::_tagCACHEINFO::m_cachefile</a>, <a class="el" href="buffer_8h_source.html#l00477">m_ci</a>, <a class="el" href="buffer_8h_source.html#l00475">m_cur_open</a>, <a class="el" href="buffer_8h_source.html#l00104">Buffer::_tagCACHEINFO::m_fd</a>, <a class="el" href="buffer_8h_source.html#l00116">Buffer::_tagCACHEINFO::m_flags</a>, <a class="el" href="buffer_8h_source.html#l00473">m_mutex</a>, <a class="el" href="buffer_8cc_source.html#l00361">map_file()</a>, <a class="el" href="buffer_8cc_source.html#l00627">reserve()</a>, and <a class="el" href="logging_8h_source.html#l00163">Logging::trace()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ffmpeg__transcoder_8cc_source.html#l01264">FFmpeg_Transcoder::open_output()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l01114">FFmpeg_Transcoder::open_output_frame_set()</a>, <a class="el" href="buffer_8cc_source.html#l00306">set_segment()</a>, <a class="el" href="transcode_8cc_source.html#l00471">transcoder_read()</a>, and <a class="el" href="transcode_8cc_source.html#l00605">transcoder_read_frame()</a>.</p>

</div>
</div>
<a id="a34523456990d9c9feb84803e82217ce1" name="a34523456990d9c9feb84803e82217ce1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34523456990d9c9feb84803e82217ce1">&#9670;&nbsp;</a></span>openio()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Buffer::openio </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="fileio_8h.html#ae8356f209b2b74cc385a8d7551f1f27a">LPVIRTUALFILE</a>&#160;</td>
          <td class="paramname"><em>virtualfile</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Open a virtual file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">virtualfile</td><td>- LPCVIRTUALFILE of file to open </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Upon successful completion, <a class="el" href="classBuffer.html#a34523456990d9c9feb84803e82217ce1" title="Open a virtual file.">openio()</a> returns 0. On error, an nonzero value is returned and errno is set to indicate the error. </dd></dl>

<p>Implements <a class="el" href="classFileIO.html#ac493dfa50e5cbc392c29feaccf4d9ce4">FileIO</a>.</p>

<p class="definition">Definition at line <a class="el" href="buffer_8cc_source.html#l00064">64</a> of file <a class="el" href="buffer_8cc_source.html">buffer.cc</a>.</p>

<p class="reference">References <a class="el" href="fileio_8cc_source.html#l00097">FileIO::set_virtualfile()</a>, and <a class="el" href="fileio_8cc_source.html#l00114">FileIO::virtualfile()</a>.</p>

<p class="reference">Referenced by <a class="el" href="cache__entry_8cc_source.html#l00039">Cache_Entry::Cache_Entry()</a>.</p>

</div>
</div>
<a id="afca4140c510e88c2a3c2b505c4e7febe" name="afca4140c510e88c2a3c2b505c4e7febe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afca4140c510e88c2a3c2b505c4e7febe">&#9670;&nbsp;</a></span>read_frame()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t Buffer::read_frame </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; uint8_t &gt; *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>frame_no</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write image data for the frame number into the buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">data</td><td>- <a class="el" href="classBuffer.html" title="The Buffer class.">Buffer</a> to read data in. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">frame_no</td><td>- Number of the frame to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Upon successful completion, <a class="el" href="classBuffer.html#a89a5520653ec88350b7c0e8dd5fb5bed" title="Not implemented.">readio()</a> returns the number of bytes read. <br  />
 This may be less than size. <br  />
 On error, the value 0 is returned and errno is set to indicate the error. <br  />
 If at the end of the file, 0 may be returned by errno not set. <a class="el" href="classBuffer.html#ac0201a3b37fc6ba862d69373b82ece6e" title="Get last error.">error()</a> will return 0 if at EOF. <br  />
 If the image frame is not yet read, the function also returns 0 and errno is EAGAIN. </dd></dl>

<p class="definition">Definition at line <a class="el" href="buffer_8cc_source.html#l01012">1012</a> of file <a class="el" href="buffer_8cc_source.html">buffer.cc</a>.</p>

<p class="reference">References <a class="el" href="buffer_8cc_source.html#l00878">copy()</a>, <a class="el" href="buffer_8h_source.html#l00113">Buffer::_tagCACHEINFO::m_buffer_idx</a>, <a class="el" href="buffer_8h_source.html#l00474">m_cur_ci</a>, <a class="el" href="buffer_8h_source.html#l00473">m_mutex</a>, and <a class="el" href="fileio_8cc_source.html#l00114">FileIO::virtualfile()</a>.</p>

<p class="reference">Referenced by <a class="el" href="transcode_8cc_source.html#l00605">transcoder_read_frame()</a>.</p>

</div>
</div>
<a id="a89a5520653ec88350b7c0e8dd5fb5bed" name="a89a5520653ec88350b7c0e8dd5fb5bed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89a5520653ec88350b7c0e8dd5fb5bed">&#9670;&nbsp;</a></span>readio()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t Buffer::readio </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Not implemented. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">data</td><td>- unused </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>- unused </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Always returns 0 and errno is EPERM. </dd></dl>

<p>Implements <a class="el" href="classFileIO.html#a4b032367f4419b94afaad96a2c2d38d1">FileIO</a>.</p>

<p class="definition">Definition at line <a class="el" href="buffer_8cc_source.html#l01005">1005</a> of file <a class="el" href="buffer_8cc_source.html">buffer.cc</a>.</p>

</div>
</div>
<a id="abbd9386f99f609c04764db011731f264" name="abbd9386f99f609c04764db011731f264"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbd9386f99f609c04764db011731f264">&#9670;&nbsp;</a></span>reallocate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Buffer::reallocate </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>newsize</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reallocate the buffer to a new size. </p>
<p >Ensure the allocation has at least the size of bytes available. If not, reallocate memory to make more available. Fill the newly allocated memory with zeroes. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">newsize</td><td>- New buffer size. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true on success; false on error. </dd></dl>

<p class="definition">Definition at line <a class="el" href="buffer_8cc_source.html#l00929">929</a> of file <a class="el" href="buffer_8cc_source.html">buffer.cc</a>.</p>

<p class="reference">References <a class="el" href="fileio_8cc_source.html#l00124">FileIO::filename()</a>, <a class="el" href="buffer_8h_source.html#l00118">Buffer::_tagCACHEINFO::m_buffer_write_size</a>, <a class="el" href="buffer_8h_source.html#l00119">Buffer::_tagCACHEINFO::m_buffer_writes</a>, <a class="el" href="buffer_8h_source.html#l00474">m_cur_ci</a>, <a class="el" href="buffer_8h_source.html#l00064">PREALLOC_FACTOR</a>, <a class="el" href="buffer_8cc_source.html#l00627">reserve()</a>, <a class="el" href="buffer_8cc_source.html#l00847">size()</a>, and <a class="el" href="logging_8h_source.html#l00163">Logging::trace()</a>.</p>

<p class="reference">Referenced by <a class="el" href="buffer_8cc_source.html#l00745">write_prepare()</a>.</p>

</div>
</div>
<a id="a31676a28709fcd1cd236e4cbeb2d3bc2" name="a31676a28709fcd1cd236e4cbeb2d3bc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31676a28709fcd1cd236e4cbeb2d3bc2">&#9670;&nbsp;</a></span>release()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Buffer::release </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="buffer_8h.html#ae6bbe3443d78677335623b58e90dfbf0">CACHE_CLOSE_NOOPT</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Release cache buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>- One of the CACHE_CLOSE_* flags. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true on success; false on error. </dd></dl>

<p class="definition">Definition at line <a class="el" href="buffer_8cc_source.html#l00494">494</a> of file <a class="el" href="buffer_8cc_source.html">buffer.cc</a>.</p>

<p class="reference">References <a class="el" href="buffer_8h_source.html#l00043">CACHE_CHECK_BIT</a>, <a class="el" href="buffer_8h_source.html#l00047">CACHE_CLOSE_DELETE</a>, <a class="el" href="buffer_8h_source.html#l00049">CACHE_FLAG_RO</a>, <a class="el" href="buffer_8h_source.html#l00050">CACHE_FLAG_RW</a>, <a class="el" href="buffer_8cc_source.html#l00137">close_file()</a>, <a class="el" href="buffer_8cc_source.html#l00559">flush()</a>, <a class="el" href="buffer_8cc_source.html#l01078">is_open()</a>, <a class="el" href="buffer_8h_source.html#l00477">m_ci</a>, <a class="el" href="buffer_8h_source.html#l00473">m_mutex</a>, <a class="el" href="buffer_8cc_source.html#l00544">remove_cachefile()</a>, <a class="el" href="buffer_8cc_source.html#l00332">segment_count()</a>, and <a class="el" href="buffer_8cc_source.html#l00444">unmap_file()</a>.</p>

<p class="reference">Referenced by <a class="el" href="cache__entry_8cc_source.html#l00208">Cache_Entry::close_buffer()</a>, <a class="el" href="buffer_8cc_source.html#l01054">closeio()</a>, and <a class="el" href="buffer_8cc_source.html#l00049">~Buffer()</a>.</p>

</div>
</div>
<a id="ae4ea83b279915a9c0886dc621758e216" name="ae4ea83b279915a9c0886dc621758e216"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4ea83b279915a9c0886dc621758e216">&#9670;&nbsp;</a></span>remove_cachefile()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Buffer::remove_cachefile </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>segment_no</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove the cachefile. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">segment_no</td><td>- [1..n] HLS segment file number or 0 for the current segment. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true on success; false on error. </dd></dl>

<p class="definition">Definition at line <a class="el" href="buffer_8cc_source.html#l00544">544</a> of file <a class="el" href="buffer_8cc_source.html">buffer.cc</a>.</p>

<p class="reference">References <a class="el" href="buffer_8h_source.html#l00103">Buffer::_tagCACHEINFO::m_cachefile</a>, <a class="el" href="buffer_8h_source.html#l00111">Buffer::_tagCACHEINFO::m_cachefile_idx</a>, <a class="el" href="buffer_8h_source.html#l00477">m_ci</a>, <a class="el" href="buffer_8h_source.html#l00474">m_cur_ci</a>, and <a class="el" href="buffer_8cc_source.html#l00991">remove_file()</a>.</p>

<p class="reference">Referenced by <a class="el" href="buffer_8cc_source.html#l00179">init()</a>, and <a class="el" href="buffer_8cc_source.html#l00494">release()</a>.</p>

</div>
</div>
<a id="a7d5aeca1d1b53238938a1d6d43b4e2dc" name="a7d5aeca1d1b53238938a1d6d43b4e2dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d5aeca1d1b53238938a1d6d43b4e2dc">&#9670;&nbsp;</a></span>remove_file()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Buffer::remove_file </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove (unlink) the file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">filename</td><td>- Name of the file to remove. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true on success; false on error. </dd></dl>

<p class="definition">Definition at line <a class="el" href="buffer_8cc_source.html#l00991">991</a> of file <a class="el" href="buffer_8cc_source.html">buffer.cc</a>.</p>

<p class="reference">References <a class="el" href="fileio_8cc_source.html#l00124">FileIO::filename()</a>, and <a class="el" href="logging_8h_source.html#l00220">Logging::warning()</a>.</p>

<p class="reference">Referenced by <a class="el" href="buffer_8cc_source.html#l00587">clear()</a>, and <a class="el" href="buffer_8cc_source.html#l00544">remove_cachefile()</a>.</p>

</div>
</div>
<a id="aa08968d973089252fc5e06e7af4c5303" name="aa08968d973089252fc5e06e7af4c5303"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa08968d973089252fc5e06e7af4c5303">&#9670;&nbsp;</a></span>reserve()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Buffer::reserve </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reserve memory without changing size to reduce re-allocations. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>- Size of buffer to reserve. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true on success; false on error. </dd></dl>

<p class="definition">Definition at line <a class="el" href="buffer_8cc_source.html#l00627">627</a> of file <a class="el" href="buffer_8cc_source.html">buffer.cc</a>.</p>

<p class="reference">References <a class="el" href="logging_8h_source.html#l00239">Logging::error()</a>, <a class="el" href="buffer_8h_source.html#l00105">Buffer::_tagCACHEINFO::m_buffer</a>, <a class="el" href="buffer_8h_source.html#l00108">Buffer::_tagCACHEINFO::m_buffer_size</a>, <a class="el" href="buffer_8h_source.html#l00103">Buffer::_tagCACHEINFO::m_cachefile</a>, <a class="el" href="buffer_8h_source.html#l00474">m_cur_ci</a>, <a class="el" href="buffer_8h_source.html#l00104">Buffer::_tagCACHEINFO::m_fd</a>, <a class="el" href="buffer_8h_source.html#l00473">m_mutex</a>, and <a class="el" href="buffer_8cc_source.html#l00847">size()</a>.</p>

<p class="reference">Referenced by <a class="el" href="buffer_8cc_source.html#l00077">open_file()</a>, <a class="el" href="buffer_8cc_source.html#l00929">reallocate()</a>, <a class="el" href="buffer_8cc_source.html#l00306">set_segment()</a>, and <a class="el" href="transcode_8cc_source.html#l00156">transcode_finish()</a>.</p>

</div>
</div>
<a id="a4530682242000278f123dd4230765722" name="a4530682242000278f123dd4230765722"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4530682242000278f123dd4230765722">&#9670;&nbsp;</a></span>seek() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Buffer::seek </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>whence</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Seek to position in file. </p>
<p >Repositions the offset of the open file to the argument offset according to the directive whence. May block for a long time if the buffer has not been filled to the requested offset.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>- offset in bytes </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">whence</td><td>- how to seek: <br  />
SEEK_SET: The offset is set to offset bytes. <br  />
SEEK_CUR: The offset is set to its current location plus offset bytes. <br  />
SEEK_END: The offset is set to the size of the file plus offset bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Upon successful completion, <a class="el" href="classBuffer.html#a4530682242000278f123dd4230765722" title="Seek to position in file.">seek()</a> returns the resulting offset location as measured in bytes from the beginning of the file. </dd></dl>

<p>Implements <a class="el" href="classFileIO.html#a0171ca18c497a09971e22cc5c381304b">FileIO</a>.</p>

<p class="definition">Definition at line <a class="el" href="buffer_8cc_source.html#l00767">767</a> of file <a class="el" href="buffer_8cc_source.html">buffer.cc</a>.</p>

<p class="reference">References <a class="el" href="buffer_8cc_source.html#l00767">seek()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ffmpeg__transcoder_8cc_source.html#l03081">FFmpeg_Transcoder::create_fake_aiff_header()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l02978">FFmpeg_Transcoder::create_fake_wav_header()</a>, <a class="el" href="buffer_8cc_source.html#l00767">seek()</a>, and <a class="el" href="buffer_8cc_source.html#l00691">write_frame()</a>.</p>

</div>
</div>
<a id="ab1eafabf58188673da1a3700d72628d7" name="ab1eafabf58188673da1a3700d72628d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1eafabf58188673da1a3700d72628d7">&#9670;&nbsp;</a></span>seek() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Buffer::seek </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>whence</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>segment_no</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Seek to position in file. </p>
<p >Repositions the offset of the open file to the argument offset according to the directive whence. May block for a long time if the buffer has not been filled to the requested offset.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>- offset in bytes </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">whence</td><td>- how to seek: <br  />
SEEK_SET: The offset is set to offset bytes. <br  />
SEEK_CUR: The offset is set to its current location plus offset bytes. <br  />
SEEK_END: The offset is set to the size of the file plus offset bytes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">segment_no</td><td>- [1..n] HLS segment file number or 0 for the current segment. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Upon successful completion, <a class="el" href="classBuffer.html#a4530682242000278f123dd4230765722" title="Seek to position in file.">seek()</a> returns the resulting offset location as measured in bytes from the beginning of the file. </dd></dl>

<p class="definition">Definition at line <a class="el" href="buffer_8cc_source.html#l00772">772</a> of file <a class="el" href="buffer_8cc_source.html">buffer.cc</a>.</p>

<p class="reference">References <a class="el" href="buffer_8cc_source.html#l01118">cacheinfo()</a>, <a class="el" href="buffer_8h_source.html#l00105">Buffer::_tagCACHEINFO::m_buffer</a>, <a class="el" href="buffer_8h_source.html#l00106">Buffer::_tagCACHEINFO::m_buffer_pos</a>, <a class="el" href="buffer_8cc_source.html#l00847">size()</a>, and <a class="el" href="buffer_8cc_source.html#l00824">tell()</a>.</p>

</div>
</div>
<a id="acf8eacdb0ced6906905dbd90d356894d" name="acf8eacdb0ced6906905dbd90d356894d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf8eacdb0ced6906905dbd90d356894d">&#9670;&nbsp;</a></span>segment_count()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t Buffer::segment_count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get segment count. </p>
<dl class="section return"><dt>Returns</dt><dd>Number of segments. </dd></dl>

<p class="definition">Definition at line <a class="el" href="buffer_8cc_source.html#l00332">332</a> of file <a class="el" href="buffer_8cc_source.html">buffer.cc</a>.</p>

<p class="reference">References <a class="el" href="buffer_8h_source.html#l00477">m_ci</a>, and <a class="el" href="buffer_8h_source.html#l00473">m_mutex</a>.</p>

<p class="reference">Referenced by <a class="el" href="buffer_8cc_source.html#l01118">cacheinfo()</a>, <a class="el" href="buffer_8cc_source.html#l00339">current_segment_no()</a>, <a class="el" href="buffer_8cc_source.html#l00559">flush()</a>, <a class="el" href="buffer_8cc_source.html#l00494">release()</a>, <a class="el" href="buffer_8cc_source.html#l00350">segment_exists()</a>, and <a class="el" href="buffer_8cc_source.html#l00306">set_segment()</a>.</p>

</div>
</div>
<a id="a35d04b77b37654d81397bbf6df193bd1" name="a35d04b77b37654d81397bbf6df193bd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35d04b77b37654d81397bbf6df193bd1">&#9670;&nbsp;</a></span>segment_exists()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Buffer::segment_exists </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>segment_no</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if segment exists. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">segment_no</td><td>- [1..n] HLS segment file number. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true if it exists, or false if it still has to be decoded. </dd></dl>

<p class="definition">Definition at line <a class="el" href="buffer_8cc_source.html#l00350">350</a> of file <a class="el" href="buffer_8cc_source.html">buffer.cc</a>.</p>

<p class="reference">References <a class="el" href="ffmpeg__utils_8cc_source.html#l02092">file_exists()</a>, <a class="el" href="buffer_8h_source.html#l00477">m_ci</a>, <a class="el" href="buffer_8h_source.html#l00474">m_cur_ci</a>, <a class="el" href="buffer_8h_source.html#l00473">m_mutex</a>, and <a class="el" href="buffer_8cc_source.html#l00332">segment_count()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ffmpeg__transcoder_8cc_source.html#l05519">FFmpeg_Transcoder::start_new_segment()</a>, and <a class="el" href="transcode_8cc_source.html#l00471">transcoder_read()</a>.</p>

</div>
</div>
<a id="ae00cd56ba92c33805447ded6400cd0bd" name="ae00cd56ba92c33805447ded6400cd0bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae00cd56ba92c33805447ded6400cd0bd">&#9670;&nbsp;</a></span>set_segment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Buffer::set_segment </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>segment_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the current segment. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">segment_no</td><td>- [1..n] HLS segment file number. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>- Estimated size of segment. Should be large enough to hold the resulting size. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true on success; if segment_no is 0 or greater, then <a class="el" href="classBuffer.html#acf8eacdb0ced6906905dbd90d356894d" title="Get segment count.">segment_count()</a> returns false and sets errno to EINVALID. </dd></dl>

<p class="definition">Definition at line <a class="el" href="buffer_8cc_source.html#l00306">306</a> of file <a class="el" href="buffer_8cc_source.html">buffer.cc</a>.</p>

<p class="reference">References <a class="el" href="buffer_8h_source.html#l00050">CACHE_FLAG_RW</a>, <a class="el" href="buffer_8cc_source.html#l00137">close_file()</a>, <a class="el" href="buffer_8cc_source.html#l00339">current_segment_no()</a>, <a class="el" href="buffer_8h_source.html#l00477">m_ci</a>, <a class="el" href="buffer_8h_source.html#l00474">m_cur_ci</a>, <a class="el" href="buffer_8h_source.html#l00473">m_mutex</a>, <a class="el" href="buffer_8cc_source.html#l00077">open_file()</a>, <a class="el" href="buffer_8cc_source.html#l00627">reserve()</a>, <a class="el" href="buffer_8cc_source.html#l00332">segment_count()</a>, and <a class="el" href="buffer_8cc_source.html#l00847">size()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ffmpeg__transcoder_8cc_source.html#l05519">FFmpeg_Transcoder::start_new_segment()</a>.</p>

</div>
</div>
<a id="af19876bd44aaa1918ba81db4390b8bdf" name="af19876bd44aaa1918ba81db4390b8bdf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af19876bd44aaa1918ba81db4390b8bdf">&#9670;&nbsp;</a></span>size() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t Buffer::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the value of the internal buffer size pointer. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the value of the internal buffer size pointer. </dd></dl>

<p>Implements <a class="el" href="classFileIO.html#a28df61747de114001d67ef6abad2ca7d">FileIO</a>.</p>

<p class="definition">Definition at line <a class="el" href="buffer_8cc_source.html#l00847">847</a> of file <a class="el" href="buffer_8cc_source.html">buffer.cc</a>.</p>

<p class="reference">References <a class="el" href="buffer_8cc_source.html#l00847">size()</a>.</p>

<p class="reference">Referenced by <a class="el" href="buffer_8cc_source.html#l01049">eof()</a>, <a class="el" href="buffer_8cc_source.html#l00929">reallocate()</a>, <a class="el" href="buffer_8cc_source.html#l00627">reserve()</a>, <a class="el" href="buffer_8cc_source.html#l00772">seek()</a>, <a class="el" href="buffer_8cc_source.html#l00306">set_segment()</a>, and <a class="el" href="buffer_8cc_source.html#l00847">size()</a>.</p>

</div>
</div>
<a id="ab53c4d61870eb1107c750a433af447a1" name="ab53c4d61870eb1107c750a433af447a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab53c4d61870eb1107c750a433af447a1">&#9670;&nbsp;</a></span>size() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t Buffer::size </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>segment_no</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the value of the internal buffer size pointer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">segment_no</td><td>- [1..n] HLS segment file number or 0 for the current segment. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the value of the internal buffer size pointer. </dd></dl>

<p class="definition">Definition at line <a class="el" href="buffer_8cc_source.html#l00852">852</a> of file <a class="el" href="buffer_8cc_source.html">buffer.cc</a>.</p>

<p class="reference">References <a class="el" href="buffer_8cc_source.html#l01134">const_cacheinfo()</a>.</p>

</div>
</div>
<a id="adf2303ab4476553b2f490be95d48e9d7" name="adf2303ab4476553b2f490be95d48e9d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf2303ab4476553b2f490be95d48e9d7">&#9670;&nbsp;</a></span>tell() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t Buffer::tell </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the value of the internal read position pointer. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the value of the internal read position pointer. </dd></dl>

<p>Implements <a class="el" href="classFileIO.html#a3a40140f766ff539cde0da854a1a9526">FileIO</a>.</p>

<p class="definition">Definition at line <a class="el" href="buffer_8cc_source.html#l00824">824</a> of file <a class="el" href="buffer_8cc_source.html">buffer.cc</a>.</p>

<p class="reference">References <a class="el" href="buffer_8cc_source.html#l00824">tell()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ffmpeg__transcoder_8cc_source.html#l03081">FFmpeg_Transcoder::create_fake_aiff_header()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l02978">FFmpeg_Transcoder::create_fake_wav_header()</a>, <a class="el" href="buffer_8cc_source.html#l01049">eof()</a>, <a class="el" href="buffer_8cc_source.html#l00772">seek()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l05519">FFmpeg_Transcoder::start_new_segment()</a>, <a class="el" href="buffer_8cc_source.html#l00824">tell()</a>, <a class="el" href="transcode_8cc_source.html#l00081">transcode_until()</a>, and <a class="el" href="transcode_8cc_source.html#l00735">transcoder_buffer_tell()</a>.</p>

</div>
</div>
<a id="ac7c0ba630a439abf0b5ba4357b1eeec4" name="ac7c0ba630a439abf0b5ba4357b1eeec4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7c0ba630a439abf0b5ba4357b1eeec4">&#9670;&nbsp;</a></span>tell() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t Buffer::tell </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>segment_no</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the value of the internal read position pointer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">segment_no</td><td>- [1..n] HLS segment file number or 0 for the current segment. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the value of the internal read position pointer. </dd></dl>

<p class="definition">Definition at line <a class="el" href="buffer_8cc_source.html#l00829">829</a> of file <a class="el" href="buffer_8cc_source.html">buffer.cc</a>.</p>

<p class="reference">References <a class="el" href="buffer_8cc_source.html#l01134">const_cacheinfo()</a>.</p>

</div>
</div>
<a id="a6a8b576768de0c73bc652d2da9546cc8" name="a6a8b576768de0c73bc652d2da9546cc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a8b576768de0c73bc652d2da9546cc8">&#9670;&nbsp;</a></span>type()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="fileio_8h.html#a1199d38534b11312b0210e527499a805">VIRTUALTYPE</a> Buffer::type </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get type of this virtual file. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns VIRTUALTYPE_BUFFER. </dd></dl>

<p>Implements <a class="el" href="classFileIO.html#a6b56f0b1fcf994ff403335463d0eca9b">FileIO</a>.</p>

<p class="definition">Definition at line <a class="el" href="buffer_8cc_source.html#l00054">54</a> of file <a class="el" href="buffer_8cc_source.html">buffer.cc</a>.</p>

<p class="reference">References <a class="el" href="fileio_8h_source.html#l00104">VIRTUALTYPE_BUFFER</a>.</p>

</div>
</div>
<a id="a61e6ce35352f2102a12b08c564bf68c0" name="a61e6ce35352f2102a12b08c564bf68c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61e6ce35352f2102a12b08c564bf68c0">&#9670;&nbsp;</a></span>unmap_file()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Buffer::unmap_file </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">volatile int *&#160;</td>
          <td class="paramname"><em>fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t **&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>filesize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unmap memory from the file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">filename</td><td>- Name of cache file to unmap. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fd</td><td>- The file descriptor of the open cache file. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>- Memory pointer to the cache file. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>- Length of the allocated block. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filesize</td><td>- Actual size of the cache file. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true on success; false on error. </dd></dl>

<p class="definition">Definition at line <a class="el" href="buffer_8cc_source.html#l00444">444</a> of file <a class="el" href="buffer_8cc_source.html">buffer.cc</a>.</p>

<p class="reference">References <a class="el" href="logging_8h_source.html#l00239">Logging::error()</a>, <a class="el" href="fileio_8cc_source.html#l00124">FileIO::filename()</a>, and <a class="el" href="logging_8h_source.html#l00163">Logging::trace()</a>.</p>

<p class="reference">Referenced by <a class="el" href="buffer_8cc_source.html#l00137">close_file()</a>, and <a class="el" href="buffer_8cc_source.html#l00494">release()</a>.</p>

</div>
</div>
<a id="a812f0147433355162b1d0bb215aae3bd" name="a812f0147433355162b1d0bb215aae3bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a812f0147433355162b1d0bb215aae3bd">&#9670;&nbsp;</a></span>write_frame()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t Buffer::write_frame </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>frame_no</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write image data for the frame number into the buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>- <a class="el" href="classBuffer.html" title="The Buffer class.">Buffer</a> with data to write. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>- Length of buffer to write. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">frame_no</td><td>- Number of the frame to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the bytes written to the buffer. If less than length, this indicates an error. Consult errno for details. </dd></dl>

<p class="definition">Definition at line <a class="el" href="buffer_8cc_source.html#l00691">691</a> of file <a class="el" href="buffer_8cc_source.html">buffer.cc</a>.</p>

<p class="reference">References <a class="el" href="buffer_8cc_source.html#l00865">buffer_watermark()</a>, <a class="el" href="fileio_8h_source.html#l00066">IMAGE_FRAME_TAG</a>, <a class="el" href="buffer_8h_source.html#l00113">Buffer::_tagCACHEINFO::m_buffer_idx</a>, <a class="el" href="buffer_8h_source.html#l00474">m_cur_ci</a>, <a class="el" href="fileio_8h_source.html#l00077">IMAGE_FRAME::m_frame_no</a>, <a class="el" href="buffer_8h_source.html#l00473">m_mutex</a>, <a class="el" href="fileio_8h_source.html#l00078">IMAGE_FRAME::m_offset</a>, <a class="el" href="fileio_8h_source.html#l00079">IMAGE_FRAME::m_size</a>, <a class="el" href="fileio_8h_source.html#l00076">IMAGE_FRAME::m_tag</a>, <a class="el" href="buffer_8cc_source.html#l00767">seek()</a>, <a class="el" href="fileio_8cc_source.html#l00114">FileIO::virtualfile()</a>, and <a class="el" href="buffer_8cc_source.html#l00664">writeio()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ffmpeg__transcoder_8cc_source.html#l04336">FFmpeg_Transcoder::encode_image_frame()</a>.</p>

</div>
</div>
<a id="a303fc10672c2812a7b34bd203a6882ef" name="a303fc10672c2812a7b34bd203a6882ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a303fc10672c2812a7b34bd203a6882ef">&#9670;&nbsp;</a></span>write_prepare()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t * Buffer::write_prepare </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prepare for the writing operation. </p>
<p >Ensure the buffer has sufficient space for the quantity of data and return a pointer to where the data may be written. The position pointer should be updated afterward with <a class="el" href="classBuffer.html#a2408e983616a750858abadf29100c6f4" title="Increment buffer position.">increment_pos()</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>- <a class="el" href="classBuffer.html" title="The Buffer class.">Buffer</a> length to prepare. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a pointer to the memory to write to. </dd></dl>

<p class="definition">Definition at line <a class="el" href="buffer_8cc_source.html#l00745">745</a> of file <a class="el" href="buffer_8cc_source.html">buffer.cc</a>.</p>

<p class="reference">References <a class="el" href="buffer_8h_source.html#l00105">Buffer::_tagCACHEINFO::m_buffer</a>, <a class="el" href="buffer_8h_source.html#l00106">Buffer::_tagCACHEINFO::m_buffer_pos</a>, <a class="el" href="buffer_8h_source.html#l00107">Buffer::_tagCACHEINFO::m_buffer_watermark</a>, <a class="el" href="buffer_8h_source.html#l00474">m_cur_ci</a>, and <a class="el" href="buffer_8cc_source.html#l00929">reallocate()</a>.</p>

<p class="reference">Referenced by <a class="el" href="buffer_8cc_source.html#l00664">writeio()</a>.</p>

</div>
</div>
<a id="a45f05afcc82a5107db5ef8dbbd457572" name="a45f05afcc82a5107db5ef8dbbd457572"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45f05afcc82a5107db5ef8dbbd457572">&#9670;&nbsp;</a></span>writeio()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t Buffer::writeio </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write data to the current position in the buffer. The position pointer will be updated. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>- <a class="el" href="classBuffer.html" title="The Buffer class.">Buffer</a> with data to write. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>- Length of buffer to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the bytes written to the buffer. If less than length, this indicates an error. Consult errno for details. </dd></dl>

<p class="definition">Definition at line <a class="el" href="buffer_8cc_source.html#l00664">664</a> of file <a class="el" href="buffer_8cc_source.html">buffer.cc</a>.</p>

<p class="reference">References <a class="el" href="buffer_8cc_source.html#l00762">increment_pos()</a>, <a class="el" href="buffer_8h_source.html#l00105">Buffer::_tagCACHEINFO::m_buffer</a>, <a class="el" href="buffer_8h_source.html#l00118">Buffer::_tagCACHEINFO::m_buffer_write_size</a>, <a class="el" href="buffer_8h_source.html#l00119">Buffer::_tagCACHEINFO::m_buffer_writes</a>, <a class="el" href="buffer_8h_source.html#l00474">m_cur_ci</a>, <a class="el" href="buffer_8h_source.html#l00473">m_mutex</a>, and <a class="el" href="buffer_8cc_source.html#l00745">write_prepare()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ffmpeg__transcoder_8cc_source.html#l03081">FFmpeg_Transcoder::create_fake_aiff_header()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l02978">FFmpeg_Transcoder::create_fake_wav_header()</a>, <a class="el" href="ffmpeg__transcoder_8cc_source.html#l06238">FFmpeg_Transcoder::output_write()</a>, and <a class="el" href="buffer_8cc_source.html#l00691">write_frame()</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a06d70fd4eff6ff0addb7bbd41f4654a1" name="a06d70fd4eff6ff0addb7bbd41f4654a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06d70fd4eff6ff0addb7bbd41f4654a1">&#9670;&nbsp;</a></span>m_ci</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classBuffer.html#aadb6390b55aac6776448a8adc81696ed">CACHEINFO</a>&gt; Buffer::m_ci</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classCache.html" title="The Cache class.">Cache</a> info. </p>

<p class="definition">Definition at line <a class="el" href="buffer_8h_source.html#l00477">477</a> of file <a class="el" href="buffer_8h_source.html">buffer.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="buffer_8cc_source.html#l01118">cacheinfo()</a>, <a class="el" href="buffer_8cc_source.html#l00587">clear()</a>, <a class="el" href="buffer_8cc_source.html#l00137">close_file()</a>, <a class="el" href="buffer_8cc_source.html#l01134">const_cacheinfo()</a>, <a class="el" href="buffer_8cc_source.html#l00339">current_segment_no()</a>, <a class="el" href="buffer_8cc_source.html#l00179">init()</a>, <a class="el" href="buffer_8cc_source.html#l01078">is_open()</a>, <a class="el" href="buffer_8cc_source.html#l00077">open_file()</a>, <a class="el" href="buffer_8cc_source.html#l00494">release()</a>, <a class="el" href="buffer_8cc_source.html#l00544">remove_cachefile()</a>, <a class="el" href="buffer_8cc_source.html#l00332">segment_count()</a>, <a class="el" href="buffer_8cc_source.html#l00350">segment_exists()</a>, and <a class="el" href="buffer_8cc_source.html#l00306">set_segment()</a>.</p>

</div>
</div>
<a id="adf27b7a77e5d22d16becf8ced3cb75ed" name="adf27b7a77e5d22d16becf8ced3cb75ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf27b7a77e5d22d16becf8ced3cb75ed">&#9670;&nbsp;</a></span>m_cur_ci</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBuffer.html#ad2b0f8fddd154c040e9b62dae6938bc0">LPCACHEINFO</a> Buffer::m_cur_ci</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convenience pointer to current write segment. </p>

<p class="definition">Definition at line <a class="el" href="buffer_8h_source.html#l00474">474</a> of file <a class="el" href="buffer_8h_source.html">buffer.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="buffer_8cc_source.html#l01118">cacheinfo()</a>, <a class="el" href="buffer_8cc_source.html#l01134">const_cacheinfo()</a>, <a class="el" href="buffer_8cc_source.html#l00339">current_segment_no()</a>, <a class="el" href="buffer_8cc_source.html#l01093">finished_segment()</a>, <a class="el" href="buffer_8cc_source.html#l00559">flush()</a>, <a class="el" href="buffer_8cc_source.html#l01059">have_frame()</a>, <a class="el" href="buffer_8cc_source.html#l00762">increment_pos()</a>, <a class="el" href="buffer_8cc_source.html#l00179">init()</a>, <a class="el" href="buffer_8cc_source.html#l01012">read_frame()</a>, <a class="el" href="buffer_8cc_source.html#l00929">reallocate()</a>, <a class="el" href="buffer_8cc_source.html#l00544">remove_cachefile()</a>, <a class="el" href="buffer_8cc_source.html#l00627">reserve()</a>, <a class="el" href="buffer_8cc_source.html#l00350">segment_exists()</a>, <a class="el" href="buffer_8cc_source.html#l00306">set_segment()</a>, <a class="el" href="buffer_8cc_source.html#l00691">write_frame()</a>, <a class="el" href="buffer_8cc_source.html#l00745">write_prepare()</a>, and <a class="el" href="buffer_8cc_source.html#l00664">writeio()</a>.</p>

</div>
</div>
<a id="a3291d599d037e29e1e9957e978258756" name="a3291d599d037e29e1e9957e978258756"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3291d599d037e29e1e9957e978258756">&#9670;&nbsp;</a></span>m_cur_open</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t Buffer::m_cur_open</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Number of open files. </p>

<p class="definition">Definition at line <a class="el" href="buffer_8h_source.html#l00475">475</a> of file <a class="el" href="buffer_8h_source.html">buffer.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="buffer_8cc_source.html#l00137">close_file()</a>, and <a class="el" href="buffer_8cc_source.html#l00077">open_file()</a>.</p>

</div>
</div>
<a id="a7c412682c4217d94c97663d197f235c0" name="a7c412682c4217d94c97663d197f235c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c412682c4217d94c97663d197f235c0">&#9670;&nbsp;</a></span>m_mutex</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::recursive_mutex Buffer::m_mutex</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access mutex. </p>

<p class="definition">Definition at line <a class="el" href="buffer_8h_source.html#l00473">473</a> of file <a class="el" href="buffer_8h_source.html">buffer.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="buffer_8cc_source.html#l00587">clear()</a>, <a class="el" href="buffer_8cc_source.html#l00137">close_file()</a>, <a class="el" href="buffer_8cc_source.html#l00883">copy()</a>, <a class="el" href="buffer_8cc_source.html#l00339">current_segment_no()</a>, <a class="el" href="buffer_8cc_source.html#l00559">flush()</a>, <a class="el" href="buffer_8cc_source.html#l01059">have_frame()</a>, <a class="el" href="buffer_8cc_source.html#l00179">init()</a>, <a class="el" href="buffer_8cc_source.html#l01078">is_open()</a>, <a class="el" href="buffer_8cc_source.html#l00077">open_file()</a>, <a class="el" href="buffer_8cc_source.html#l01012">read_frame()</a>, <a class="el" href="buffer_8cc_source.html#l00494">release()</a>, <a class="el" href="buffer_8cc_source.html#l00627">reserve()</a>, <a class="el" href="buffer_8cc_source.html#l00332">segment_count()</a>, <a class="el" href="buffer_8cc_source.html#l00350">segment_exists()</a>, <a class="el" href="buffer_8cc_source.html#l00306">set_segment()</a>, <a class="el" href="buffer_8cc_source.html#l00691">write_frame()</a>, and <a class="el" href="buffer_8cc_source.html#l00664">writeio()</a>.</p>

</div>
</div>
<a id="a0c63511798ae2cafa041b14b70379ed0" name="a0c63511798ae2cafa041b14b70379ed0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c63511798ae2cafa041b14b70379ed0">&#9670;&nbsp;</a></span>PREALLOC_FACTOR</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr int Buffer::PREALLOC_FACTOR = 5</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>PREALLOC_FACTOR - Number of elements allocated on reallocate calls Number of elements allocated on reallocate calls. The buffer keeps track of the typical buffer write size. To prevent repeated reallocations, <a class="el" href="classBuffer.html#abbd9386f99f609c04764db011731f264" title="Reallocate the buffer to a new size.">reallocate()</a> attempts to set aside enough memory for PREALLOC FACTOR average elements whenever it is invoked. </p>

<p class="definition">Definition at line <a class="el" href="buffer_8h_source.html#l00064">64</a> of file <a class="el" href="buffer_8h_source.html">buffer.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="buffer_8cc_source.html#l00929">reallocate()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/<a class="el" href="buffer_8h_source.html">buffer.h</a></li>
<li>src/<a class="el" href="buffer_8cc_source.html">buffer.cc</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4
</small></address>
</body>
</html>
